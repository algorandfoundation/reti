#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 64 16 200 157 300 2100000 1000000 30857 TMPL_NFD_REGISTRY_APP_ID
    bytecblock "stakers" "creatorApp" 0x151f7c75 "validatorId" "poolId" "staked" "roundsPerDay" "stakeAccumulator" 0x0002 "binRoundStart" "numStakers" "rewardAccumulator" "ewma" 0x75aff61d 0x64 "minEntryStake" "lastPayout" "epochNumber" 0x000100000000000f4240 0x0001 0x0c2245e1 0x068101 0x00000000000000000000000000000001 0x00000000000000000000000000000000 0xa2dc51b5 0x572767d1 0x4df8d86e 0x0003
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn NumAppArgs
    bz main_after_if_else@20
    pushbytess 0x59e90aa6 0x3172ca9d 0x47cfcc04 0xf9c70cbd 0x421b5abe 0xf5892d56 0x5cfbb057 0x63f3f28b 0x86a3725c 0xefc2608d 0x9cee2e40 0x51ef3b21 0xa24e2717 // method "createApplication(uint64,uint64,uint64,uint64)void", method "gas()void", method "initStorage(pay)void", method "addStake(pay,address)uint64", method "removeStake(address,uint64)void", method "claimTokens()void", method "getStakerInfo(address)(address,uint64,uint64,uint64,uint64)", method "payTokenReward(address,uint64,uint64)void", method "updateAlgodVer(string)void", method "epochBalanceUpdate()void", method "goOnline(pay,byte[32],byte[32],byte[64],uint64,uint64,uint64)void", method "goOffline()void", method "linkToNFD(uint64,string)void"
    bytec 20 // method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_gas_route@4 main_initStorage_route@5 main_addStake_route@6 main_removeStake_route@7 main_claimTokens_route@8 main_getStakerInfo_route@9 main_payTokenReward_route@10 main_updateAlgodVer_route@11 main_epochBalanceUpdate_route@12 main_goOnline_route@13 main_goOffline_route@14 main_linkToNFD_route@15 main_proxiedSetTokenPayoutRatio_route@16

main_after_if_else@20:
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    intc_0 // 0
    return

main_proxiedSetTokenPayoutRatio_route@16:
    // contracts/stakingPool.algo.ts:987
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    // contracts/stakingPool.algo.ts:987
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    callsub proxiedSetTokenPayoutRatio
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_linkToNFD_route@15:
    // contracts/stakingPool.algo.ts:966
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // contracts/stakingPool.algo.ts:966
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    callsub linkToNFD
    intc_1 // 1
    return

main_goOffline_route@14:
    // contracts/stakingPool.algo.ts:953
    // goOffline(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub goOffline
    intc_1 // 1
    return

main_goOnline_route@13:
    // contracts/stakingPool.algo.ts:925-933
    // goOnline(
    //     feePayment: gtxn.PaymentTxn,
    //     votePK: bytes<32>,
    //     selectionPK: bytes<32>,
    //     stateProofPK: bytes<64>,
    //     voteFirst: uint64,
    //     voteLast: uint64,
    //     voteKeyDilution: uint64,
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // contracts/stakingPool.algo.ts:925-933
    // goOnline(
    //     feePayment: gtxn.PaymentTxn,
    //     votePK: bytes<32>,
    //     selectionPK: bytes<32>,
    //     stateProofPK: bytes<64>,
    //     voteFirst: uint64,
    //     voteLast: uint64,
    //     voteKeyDilution: uint64,
    // ): void {
    callsub goOnline
    intc_1 // 1
    return

main_epochBalanceUpdate_route@12:
    // contracts/stakingPool.algo.ts:547
    // epochBalanceUpdate(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub epochBalanceUpdate
    intc_1 // 1
    return

main_updateAlgodVer_route@11:
    // contracts/stakingPool.algo.ts:534
    // updateAlgodVer(algodVer: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/stakingPool.algo.ts:534
    // updateAlgodVer(algodVer: string): void {
    callsub updateAlgodVer
    intc_1 // 1
    return

main_payTokenReward_route@10:
    // contracts/stakingPool.algo.ts:508
    // payTokenReward(staker: Address, rewardToken: uint64, amountToSend: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // contracts/stakingPool.algo.ts:508
    // payTokenReward(staker: Address, rewardToken: uint64, amountToSend: uint64): void {
    callsub payTokenReward
    intc_1 // 1
    return

main_getStakerInfo_route@9:
    // contracts/stakingPool.algo.ts:487
    // @abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    // contracts/stakingPool.algo.ts:487
    // @abimethod({ readonly: true })
    callsub getStakerInfo
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_claimTokens_route@8:
    // contracts/stakingPool.algo.ts:416
    // claimTokens(): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub claimTokens
    intc_1 // 1
    return

main_removeStake_route@7:
    // contracts/stakingPool.algo.ts:304
    // removeStake(staker: Address, amountToUnstake: uint64): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // contracts/stakingPool.algo.ts:304
    // removeStake(staker: Address, amountToUnstake: uint64): void {
    callsub removeStake
    intc_1 // 1
    return

main_addStake_route@6:
    // contracts/stakingPool.algo.ts:219
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Address): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // contracts/stakingPool.algo.ts:219
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Address): uint64 {
    callsub addStake
    itob
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_initStorage_route@5:
    // contracts/stakingPool.algo.ts:179
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // contracts/stakingPool.algo.ts:179
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    callsub initStorage
    intc_1 // 1
    return

main_gas_route@4:
    // contracts/stakingPool.algo.ts:163
    // gas(): void {}
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_1 // 1
    return

main_createApplication_route@3:
    // contracts/stakingPool.algo.ts:129-134
    // createApplication(
    //     creatingContractId: Application,
    //     validatorId: uint64,
    //     poolId: uint64,
    //     minEntryStake: uint64,
    // ): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // contracts/stakingPool.algo.ts:68-69
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // contracts/stakingPool.algo.ts:129-134
    // createApplication(
    //     creatingContractId: Application,
    //     validatorId: uint64,
    //     poolId: uint64,
    //     minEntryStake: uint64,
    // ): void {
    callsub createApplication
    intc_1 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10 // 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@7
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 21 // 0x068101
    itxn_field ApprovalProgram
    bytec 21 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@6:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_after_while@7:
    retsub


// contracts/utils.algo.ts::wideRatio(numeratorFactors: bytes, denominatorFactors: bytes) -> uint64, bytes, bytes:
wideRatio:
    // contracts/utils.algo.ts:4
    // export function wideRatio(numeratorFactors: uint64[], denominatorFactors: uint64[]): uint64 {
    proto 2 3
    intc_0 // 0
    pushbytes ""
    dup
    // contracts/utils.algo.ts:5
    // let numerator = new Uint128(1n)
    bytec 22 // 0x00000000000000000000000000000001
    // contracts/utils.algo.ts:6
    // for (const factor of numeratorFactors) {
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_0 // 0

wideRatio_for_header@1:
    // contracts/utils.algo.ts:6
    // for (const factor of numeratorFactors) {
    frame_dig 5
    frame_dig 4
    <
    bz wideRatio_after_for@4
    frame_dig -2
    extract 2 0
    frame_dig 5
    dup
    cover 2
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/utils.algo.ts:7
    // numerator = new Uint128(BigUint(factor) * numerator.native)
    frame_dig 3
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    frame_bury 3
    intc_1 // 1
    +
    frame_bury 5
    b wideRatio_for_header@1

wideRatio_after_for@4:
    // contracts/utils.algo.ts:10
    // let denominator = new Uint128(1n)
    bytec 22 // 0x00000000000000000000000000000001
    frame_bury 0
    // contracts/utils.algo.ts:11
    // for (const factor of denominatorFactors) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 1
    intc_0 // 0
    frame_bury 2

wideRatio_for_header@5:
    // contracts/utils.algo.ts:11
    // for (const factor of denominatorFactors) {
    frame_dig 2
    frame_dig 1
    <
    bz wideRatio_after_for@8
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 2
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/utils.algo.ts:12
    // denominator = new Uint128(BigUint(factor) * denominator.native)
    frame_dig 0
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 2
    b wideRatio_for_header@5

wideRatio_after_for@8:
    // contracts/utils.algo.ts:15
    // const ratio: biguint = numerator.native / denominator.native
    frame_dig 3
    frame_dig 0
    b/
    // contracts/utils.algo.ts:16
    // return new Uint64(ratio).native
    dup
    len
    pushint 8 // 8
    <=
    assert // overflow
    pushint 8 // 8
    bzero
    b|
    btoi
    frame_dig -2
    frame_dig -1
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub


// contracts/stakingPool.algo.ts::StakingPool.createApplication(creatingContractId: uint64, validatorId: uint64, poolId: uint64, minEntryStake: uint64) -> void:
createApplication:
    // contracts/stakingPool.algo.ts:129-134
    // createApplication(
    //     creatingContractId: Application,
    //     validatorId: uint64,
    //     poolId: uint64,
    //     minEntryStake: uint64,
    // ): void {
    proto 4 0
    // contracts/stakingPool.algo.ts:135
    // if (creatingContractId === Application(0)) {
    frame_dig -4
    bnz createApplication_else_body@2
    // contracts/stakingPool.algo.ts:137
    // assert(validatorId === 0)
    frame_dig -3
    !
    assert
    // contracts/stakingPool.algo.ts:138
    // assert(poolId === 0)
    frame_dig -2
    !
    assert

createApplication_after_if_else@3:
    // contracts/stakingPool.algo.ts:143
    // assert(minEntryStake >= MIN_ALGO_STAKE_PER_POOL, 'staking pool must have minimum entry of 1 algo')
    frame_dig -1
    intc 8 // 1000000
    >=
    assert // staking pool must have minimum entry of 1 algo
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:144
    // this.creatingValidatorContractAppId.value = creatingContractId.id
    frame_dig -4
    app_global_put
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:145
    // this.validatorId.value = validatorId
    frame_dig -3
    app_global_put
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:146
    // this.poolId.value = poolId
    frame_dig -2
    app_global_put
    // contracts/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:147
    // this.numStakers.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:148
    // this.totalAlgoStaked.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:88
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:149
    // this.minEntryStake.value = minEntryStake
    frame_dig -1
    app_global_put
    // contracts/stakingPool.algo.ts:91
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:150
    // this.lastPayout.value = Global.round // set to init block to establish baseline
    global Round
    app_global_put
    // contracts/stakingPool.algo.ts:94
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:151
    // this.epochNumber.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:153
    // this.setRoundsPerDay()
    callsub setRoundsPerDay
    // contracts/stakingPool.algo.ts:154
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    global Round
    dup
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:154
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    app_global_get_ex
    assert // check GlobalState exists
    %
    -
    // contracts/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:154
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:155
    // this.stakeAccumulator.value = new Uint128(0)
    bytec 23 // 0x00000000000000000000000000000000
    app_global_put
    // contracts/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:156
    // this.rewardAccumulator.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:157
    // this.weightedMovingAverage.value = new Uint128(0)
    bytec 23 // 0x00000000000000000000000000000000
    app_global_put
    retsub

createApplication_else_body@2:
    // contracts/stakingPool.algo.ts:140
    // assert(validatorId !== 0)
    frame_dig -3
    assert
    // contracts/stakingPool.algo.ts:141
    // assert(poolId !== 0)
    frame_dig -2
    assert
    b createApplication_after_if_else@3


// contracts/stakingPool.algo.ts::StakingPool.initStorage(mbrPayment: uint64) -> void:
initStorage:
    // contracts/stakingPool.algo.ts:179
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    proto 1 0
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:180
    // assert(!this.stakers.exists, 'staking pool already initialized')
    box_len
    bury 1
    !
    assert // staking pool already initialized
    // contracts/stakingPool.algo.ts:183-186
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:184
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:184
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:185
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:185
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:183-186
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc 5 // 157
    // contracts/stakingPool.algo.ts:188
    // const isTokenEligible = validatorConfig.rewardTokenId !== 0
    extract_uint64
    dup
    // contracts/stakingPool.algo.ts:189
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    bz initStorage_bool_false@4
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:189
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz initStorage_bool_false@4
    intc_1 // 1

initStorage_bool_merge@5:
    // contracts/stakingPool.algo.ts:189
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    pushint 100000 // 100000
    *
    // contracts/stakingPool.algo.ts:191-193
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // extraMBR +
    // this.costForBoxStorage(7 /* 'stakers' name */ + arc4EncodedLength<StakedInfo>() * MAX_STAKERS_PER_POOL)
    pushint 5225300 // 5225300
    +
    // contracts/stakingPool.algo.ts:196
    // assertMatch(mbrPayment, { receiver: Global.currentApplicationAddress, amount: PoolInitMbr })
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    frame_dig -1
    gtxns Amount
    uncover 2
    ==
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:197
    // this.stakers.create()
    pushint 12800 // 12800
    box_create
    pop
    // contracts/stakingPool.algo.ts:199
    // if (isTokenEligible && this.poolId.value === 1) {
    frame_dig 0
    bz initStorage_after_if_else@9
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:199
    // if (isTokenEligible && this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz initStorage_after_if_else@9
    // contracts/stakingPool.algo.ts:201-205
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:203
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/stakingPool.algo.ts:204
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig 0
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:201-205
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

initStorage_after_if_else@9:
    retsub

initStorage_bool_false@4:
    intc_0 // 0
    b initStorage_bool_merge@5


// contracts/stakingPool.algo.ts::StakingPool.addStake(stakedAmountPayment: uint64, staker: bytes) -> uint64:
addStake:
    // contracts/stakingPool.algo.ts:219
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Address): uint64 {
    proto 2 1
    intc_0 // 0
    dup
    pushbytes ""
    dup
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:220
    // assert(this.stakers.exists, 'staking pool must be initialized first')
    box_len
    bury 1
    assert // staking pool must be initialized first
    // contracts/stakingPool.algo.ts:224
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:224
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/stakingPool.algo.ts:223-226
    // assert(
    //     Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    //     'stake can only be added via the validator contract',
    // )
    assert // stake can only be added via the validator contract
    // contracts/stakingPool.algo.ts:227
    // assert(staker.native !== Global.zeroAddress)
    frame_dig -1
    global ZeroAddress
    !=
    assert
    // contracts/stakingPool.algo.ts:230
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:234-238
    // assertMatch(stakedAmountPayment, {
    //     sender: Application(this.creatingValidatorContractAppId.value).address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    frame_dig -2
    gtxns Sender
    // contracts/stakingPool.algo.ts:235
    // sender: Application(this.creatingValidatorContractAppId.value).address,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:235
    // sender: Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // contracts/stakingPool.algo.ts:234-238
    // assertMatch(stakedAmountPayment, {
    //     sender: Application(this.creatingValidatorContractAppId.value).address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    ==
    frame_dig -2
    gtxns Receiver
    // contracts/stakingPool.algo.ts:236
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/stakingPool.algo.ts:234-238
    // assertMatch(stakedAmountPayment, {
    //     sender: Application(this.creatingValidatorContractAppId.value).address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    ==
    &&
    frame_dig -2
    gtxns Amount
    dup
    uncover 2
    intc_1 // 1
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:243
    // const entryRound: uint64 = Global.round + ALGORAND_STAKING_BLOCK_DELAY
    global Round
    pushint 320 // 320
    +
    swap
    // contracts/stakingPool.algo.ts:244
    // let firstEmpty: uint64 = 0
    intc_0 // 0
    swap
    // contracts/stakingPool.algo.ts:246
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:246
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    +
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:246
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:248
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:248
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:248
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:250
    // this.stakeAccumulator.value.native + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:250
    // this.stakeAccumulator.value.native + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    itob
    dup
    cover 3
    uncover 2
    itob
    b*
    b+
    // contracts/stakingPool.algo.ts:249-251
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.native + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:249-251
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.native + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:254
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

addStake_while_top@1:
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:254
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 8
    intc 4 // 200
    <
    bz addStake_after_while@8
    // contracts/stakingPool.algo.ts:255
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:256
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 8
    intc_2 // 64
    *
    dup
    frame_bury 2
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:256
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 1
    // contracts/stakingPool.algo.ts:256-257
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    dup
    frame_bury 0
    // contracts/stakingPool.algo.ts:257
    // if (cmpStaker.account === staker) {
    frame_dig -1
    ==
    bz addStake_after_if_else@4
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:256
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 2
    dup
    cover 2
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // contracts/stakingPool.algo.ts:259
    // cmpStaker.balance += stakedAmountPayment.amount
    extract_uint64
    frame_dig 4
    +
    itob
    frame_dig 1
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:260
    // cmpStaker.entryRound = entryRound
    frame_dig 5
    dup
    cover 2
    itob
    replace2 56
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:263
    // this.stakers.value[i] = clone(cmpStaker)
    uncover 3
    uncover 2
    box_replace
    // contracts/stakingPool.algo.ts:265
    // return entryRound
    frame_bury 0
    retsub

addStake_after_if_else@4:
    frame_dig 6
    dup
    frame_bury 3
    // contracts/stakingPool.algo.ts:267
    // if (firstEmpty === 0 && cmpStaker.account.native === Global.zeroAddress) {
    bnz addStake_after_if_else@7
    frame_dig 0
    global ZeroAddress
    ==
    frame_dig 6
    frame_bury 3
    bz addStake_after_if_else@7
    // contracts/stakingPool.algo.ts:268
    // firstEmpty = i + 1
    frame_dig 8
    intc_1 // 1
    +
    frame_bury 3

addStake_after_if_else@7:
    frame_dig 3
    frame_bury 6
    // contracts/stakingPool.algo.ts:254
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 8
    intc_1 // 1
    +
    frame_bury 8
    b addStake_while_top@1

addStake_after_while@8:
    // contracts/stakingPool.algo.ts:272
    // if (firstEmpty === 0) {
    frame_dig 6
    dup
    !
    !
    assert // Staking pool full
    // contracts/stakingPool.algo.ts:279
    // assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:88
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:279
    // assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 4
    <=
    assert // must stake at least the minimum for this pool
    // contracts/stakingPool.algo.ts:281
    // assert(this.stakers.value[firstEmpty - 1].account.native === Global.zeroAddress)
    intc_1 // 1
    -
    intc_2 // 64
    *
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:281
    // assert(this.stakers.value[firstEmpty - 1].account.native === Global.zeroAddress)
    dig 1
    intc_2 // 64
    box_extract
    extract 0 32
    global ZeroAddress
    ==
    assert
    // contracts/stakingPool.algo.ts:282-288
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    frame_dig -1
    frame_dig 7
    concat
    // contracts/stakingPool.algo.ts:285
    // totalRewarded: 0,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:282-288
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    frame_dig 5
    dup
    cover 2
    itob
    concat
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:282-288
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    uncover 3
    uncover 2
    box_replace
    // contracts/stakingPool.algo.ts:289
    // this.numStakers.value += 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:289
    // this.numStakers.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // contracts/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:289
    // this.numStakers.value += 1
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:290
    // return entryRound
    frame_bury 0
    retsub


// contracts/stakingPool.algo.ts::StakingPool.removeStake(staker: bytes, amountToUnstake: uint64) -> void:
removeStake:
    // contracts/stakingPool.algo.ts:304
    // removeStake(staker: Address, amountToUnstake: uint64): void {
    proto 2 0
    intc_0 // 0
    dup
    pushbytes ""
    dupn 6
    // contracts/stakingPool.algo.ts:307
    // if (staker.native !== Txn.sender) {
    frame_dig -2
    txn Sender
    !=
    bz removeStake_after_if_else@2
    // contracts/stakingPool.algo.ts:309
    // this.isOwnerOrManagerCaller(),
    callsub isOwnerOrManagerCaller
    // contracts/stakingPool.algo.ts:308-311
    // assert(
    //     this.isOwnerOrManagerCaller(),
    //     'If staker is not sender in removeStake call, then sender MUST be owner or manager of validator',
    // )
    assert // If staker is not sender in removeStake call, then sender MUST be owner or manager of validator

removeStake_after_if_else@2:
    // contracts/stakingPool.algo.ts:314
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:316
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    frame_bury 6

removeStake_while_top@3:
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:316
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 6
    dup
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:317
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:318
    // const cmpStaker = clone(this.stakers.value[i])
    intc_2 // 64
    *
    dup
    frame_bury 5
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:318
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 0
    // contracts/stakingPool.algo.ts:318-319
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    // contracts/stakingPool.algo.ts:319
    // if (cmpStaker.account === staker) {
    frame_dig -2
    ==
    bz removeStake_after_if_else@25
    frame_dig -1
    frame_bury 4
    // contracts/stakingPool.algo.ts:320
    // if (amountToUnstake === 0) {
    frame_dig -1
    bnz removeStake_after_if_else@7
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:318
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 5
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // contracts/stakingPool.algo.ts:322
    // amountToUnstake = cmpStaker.balance
    extract_uint64
    dup
    frame_bury -1
    frame_bury 4

removeStake_after_if_else@7:
    frame_dig 4
    frame_bury -1
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:318
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 5
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // contracts/stakingPool.algo.ts:324
    // if (cmpStaker.balance < amountToUnstake) {
    extract_uint64
    dup
    frame_dig -1
    <
    !
    assert // Insufficient balance
    // contracts/stakingPool.algo.ts:327
    // cmpStaker.balance -= amountToUnstake
    frame_dig -1
    -
    itob
    frame_dig 0
    swap
    replace2 32
    dup
    frame_bury 0
    // contracts/stakingPool.algo.ts:328
    // this.totalAlgoStaked.value -= amountToUnstake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:328
    // this.totalAlgoStaked.value -= amountToUnstake
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    -
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:328
    // this.totalAlgoStaked.value -= amountToUnstake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:330
    // let amountRewardTokenRemoved: uint64 = 0
    intc_0 // 0
    frame_bury 2
    // contracts/stakingPool.algo.ts:331
    // if (cmpStaker.rewardTokenBalance > 0) {
    dup
    pushint 48 // 48
    extract_uint64
    dup
    frame_bury 3
    swap
    frame_bury 1
    bz removeStake_after_if_else@16
    // contracts/stakingPool.algo.ts:333
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:333
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz removeStake_else_body@14
    // contracts/stakingPool.algo.ts:334-337
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:335
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:335
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:336
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:336
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:334-337
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:342-346
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker.native,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    itxn_begin
    intc 5 // 157
    // contracts/stakingPool.algo.ts:343
    // xferAsset: validatorConfig.rewardTokenId,
    extract_uint64
    frame_dig 3
    itxn_field AssetAmount
    frame_dig -2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:342-346
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker.native,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:348
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    frame_dig 0
    swap
    replace2 48
    frame_bury 0

removeStake_after_if_else@15:
    frame_dig 3
    frame_bury 2
    frame_dig 0
    frame_bury 1

removeStake_after_if_else@16:
    frame_dig 1
    dup
    frame_bury 0
    // contracts/stakingPool.algo.ts:360
    // cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    pushint 32 // 32
    extract_uint64
    dup
    frame_bury 8
    bz removeStake_bool_true@18
    intc_0 // 0
    // contracts/stakingPool.algo.ts:88
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:360
    // cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 8
    <=
    bz removeStake_bool_false@19

removeStake_bool_true@18:
    intc_1 // 1

removeStake_bool_merge@20:
    // contracts/stakingPool.algo.ts:359-362
    // assert(
    //     cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    //     'cannot reduce balance below minimum allowed stake unless all is removed',
    // )
    assert // cannot reduce balance below minimum allowed stake unless all is removed
    // contracts/stakingPool.algo.ts:367-371
    // itxn.payment({
    //     amount: amountToUnstake,
    //     receiver: staker.native,
    //     note: 'unstaked',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:370
    // note: 'unstaked',
    pushbytes "unstaked"
    itxn_field Note
    frame_dig -2
    itxn_field Receiver
    frame_dig -1
    itxn_field Amount
    // contracts/stakingPool.algo.ts:367-371
    // itxn.payment({
    //     amount: amountToUnstake,
    //     receiver: staker.native,
    //     note: 'unstaked',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:372
    // let stakerRemoved = false
    intc_0 // 0
    frame_bury 7
    frame_dig 0
    frame_bury 1
    // contracts/stakingPool.algo.ts:373
    // if (cmpStaker.balance === 0) {
    frame_dig 8
    bnz removeStake_after_if_else@23
    // contracts/stakingPool.algo.ts:375
    // this.numStakers.value -= 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:375
    // this.numStakers.value -= 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    -
    // contracts/stakingPool.algo.ts:83
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:375
    // this.numStakers.value -= 1
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:376
    // cmpStaker.account = new Address(Global.zeroAddress)
    frame_dig 0
    global ZeroAddress
    replace2 0
    // contracts/stakingPool.algo.ts:377
    // cmpStaker.totalRewarded = 0
    intc_0 // 0
    itob
    swap
    dig 1
    replace2 40
    // contracts/stakingPool.algo.ts:378
    // cmpStaker.rewardTokenBalance = 0
    swap
    replace2 48
    // contracts/stakingPool.algo.ts:379
    // stakerRemoved = true
    intc_1 // 1
    frame_bury 7
    frame_bury 1

removeStake_after_if_else@23:
    frame_dig 1
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:382
    // this.stakers.value[i] = clone(cmpStaker)
    frame_dig 5
    uncover 2
    box_replace
    // contracts/stakingPool.algo.ts:384
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:384
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:384
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:385
    // const subtractAmount = BigUint(amountToUnstake * roundsLeftInBin)
    frame_dig -1
    *
    itob
    // contracts/stakingPool.algo.ts:386
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.native - subtractAmount)
    intc_0 // 0
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:386
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.native - subtractAmount)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    b-
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:386
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.native - subtractAmount)
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:391-404
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         amountToUnstake,
    //         amountRewardTokenRemoved,
    //         stakerRemoved,
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:392
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:392
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:395
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:395
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:396
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:396
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:397
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:394-398
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:400
    // amountToUnstake,
    frame_dig -1
    itob
    // contracts/stakingPool.algo.ts:401
    // amountRewardTokenRemoved,
    frame_dig 2
    itob
    // contracts/stakingPool.algo.ts:402
    // stakerRemoved,
    pushbytes 0x00
    intc_0 // 0
    frame_dig 7
    setbit
    // contracts/stakingPool.algo.ts:391-404
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         amountToUnstake,
    //         amountRewardTokenRemoved,
    //         stakerRemoved,
    //     ],
    // })
    bytec 24 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:405
    // return
    retsub

removeStake_bool_false@19:
    intc_0 // 0
    b removeStake_bool_merge@20

removeStake_else_body@14:
    // contracts/stakingPool.algo.ts:354
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    frame_dig 0
    swap
    replace2 48
    frame_bury 0
    b removeStake_after_if_else@15

removeStake_after_if_else@25:
    // contracts/stakingPool.algo.ts:316
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 6
    intc_1 // 1
    +
    frame_bury 6
    b removeStake_while_top@3


// contracts/stakingPool.algo.ts::StakingPool.claimTokens() -> void:
claimTokens:
    // contracts/stakingPool.algo.ts:416
    // claimTokens(): void {
    proto 0 0
    intc_0 // 0
    dup
    pushbytes ""
    dup
    // contracts/stakingPool.algo.ts:420
    // const staker = Txn.sender
    txn Sender
    // contracts/stakingPool.algo.ts:422
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

claimTokens_while_top@1:
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:422
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 5
    dup
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:423
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:424
    // const cmpStaker = clone(this.stakers.value[i])
    intc_2 // 64
    *
    dup
    frame_bury 3
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:424
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 1
    // contracts/stakingPool.algo.ts:424-425
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account.native === staker) {
    extract 0 32
    // contracts/stakingPool.algo.ts:425
    // if (cmpStaker.account.native === staker) {
    frame_dig 4
    ==
    bz claimTokens_after_if_else@12
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:424
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 3
    intc_2 // 64
    box_extract
    dup
    extract 48 8
    frame_bury 0
    pushint 48 // 48
    // contracts/stakingPool.algo.ts:426
    // if (cmpStaker.rewardTokenBalance === 0) {
    extract_uint64
    dup
    frame_bury 2
    bnz claimTokens_after_if_else@5
    // contracts/stakingPool.algo.ts:427
    // return
    retsub

claimTokens_after_if_else@5:
    // contracts/stakingPool.algo.ts:431
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:431
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz claimTokens_else_body@9
    // contracts/stakingPool.algo.ts:432-435
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:433
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:433
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:434
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:434
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:432-435
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:439-443
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    itxn_begin
    intc 5 // 157
    // contracts/stakingPool.algo.ts:440
    // xferAsset: validatorConfig.rewardTokenId,
    extract_uint64
    frame_dig 2
    itxn_field AssetAmount
    frame_dig 4
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:439-443
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:445
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    frame_dig 1
    swap
    replace2 48
    frame_bury 1

claimTokens_after_if_else@10:
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:455
    // this.stakers.value[i] = clone(cmpStaker)
    frame_dig 3
    frame_dig 1
    box_replace
    // contracts/stakingPool.algo.ts:460-473
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         new Address(staker),
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:461
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:461
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:464
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:464
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:465
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:465
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:466
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:463-467
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:469
    // 0, // no algo removed
    intc_0 // 0
    itob
    // contracts/stakingPool.algo.ts:460-473
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         new Address(staker),
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    bytec 24 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    frame_dig 4
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    // contracts/stakingPool.algo.ts:471
    // false, // staker isn't being removed.
    pushbytes 0x00
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // contracts/stakingPool.algo.ts:460-473
    // abiCall(ValidatorRegistryInterface.prototype.stakeRemoved, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         new Address(staker),
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:474
    // return
    retsub

claimTokens_else_body@9:
    // contracts/stakingPool.algo.ts:451
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    frame_dig 1
    swap
    replace2 48
    frame_bury 1
    b claimTokens_after_if_else@10

claimTokens_after_if_else@12:
    // contracts/stakingPool.algo.ts:422
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 5
    intc_1 // 1
    +
    frame_bury 5
    b claimTokens_while_top@1


// contracts/stakingPool.algo.ts::StakingPool.getStakerInfo(staker: bytes) -> bytes:
getStakerInfo:
    // contracts/stakingPool.algo.ts:487-488
    // @abimethod({ readonly: true })
    // getStakerInfo(staker: Address): StakedInfo {
    proto 1 1
    pushbytes ""
    // contracts/stakingPool.algo.ts:489
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

getStakerInfo_while_top@1:
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:489
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 1
    dup
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:490
    // ensureBudget(200)
    intc 4 // 200
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:491
    // if (this.stakers.value[i].account === staker) {
    intc_2 // 64
    *
    dup
    frame_bury 0
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:491
    // if (this.stakers.value[i].account === staker) {
    swap
    intc_2 // 64
    box_extract
    extract 0 32
    frame_dig -1
    ==
    bz getStakerInfo_after_if_else@4
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:492
    // return this.stakers.value[i]
    frame_dig 0
    intc_2 // 64
    box_extract
    frame_bury 0
    retsub

getStakerInfo_after_if_else@4:
    // contracts/stakingPool.algo.ts:489
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 1
    intc_1 // 1
    +
    frame_bury 1
    b getStakerInfo_while_top@1


// contracts/stakingPool.algo.ts::StakingPool.payTokenReward(staker: bytes, rewardToken: uint64, amountToSend: uint64) -> void:
payTokenReward:
    // contracts/stakingPool.algo.ts:508
    // payTokenReward(staker: Address, rewardToken: uint64, amountToSend: uint64): void {
    proto 3 0
    // contracts/stakingPool.algo.ts:511
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:511
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/stakingPool.algo.ts:510-513
    // assert(
    //     Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    //     'this can only be called via the validator contract',
    // )
    assert // this can only be called via the validator contract
    // contracts/stakingPool.algo.ts:514
    // assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:514
    // assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // must be pool 1 in order to be called to pay out token rewards
    // contracts/stakingPool.algo.ts:515
    // assert(rewardToken !== 0, 'can only claim token rewards from validator that has them')
    frame_dig -2
    assert // can only claim token rewards from validator that has them
    // contracts/stakingPool.algo.ts:518-522
    // itxn.assetTransfer({
    //     xferAsset: rewardToken,
    //     assetReceiver: staker.native,
    //     assetAmount: amountToSend,
    // }).submit()
    itxn_begin
    frame_dig -1
    itxn_field AssetAmount
    frame_dig -3
    itxn_field AssetReceiver
    frame_dig -2
    itxn_field XferAsset
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// contracts/stakingPool.algo.ts::StakingPool.updateAlgodVer(algodVer: bytes) -> void:
updateAlgodVer:
    // contracts/stakingPool.algo.ts:534
    // updateAlgodVer(algodVer: string): void {
    proto 1 0
    // contracts/stakingPool.algo.ts:535
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:97
    // algodVer = GlobalState<bytes>({ key: 'algodVer' })
    pushbytes "algodVer"
    // contracts/stakingPool.algo.ts:536
    // this.algodVer.value = Bytes(algodVer)
    frame_dig -1
    app_global_put
    retsub


// contracts/stakingPool.algo.ts::StakingPool.epochBalanceUpdate() -> void:
epochBalanceUpdate:
    // contracts/stakingPool.algo.ts:547
    // epochBalanceUpdate(): void {
    proto 0 0
    intc_0 // 0
    dupn 6
    pushbytes ""
    dupn 34
    intc_0 // 0
    // contracts/stakingPool.algo.ts:549-552
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:550
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:550
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:551
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:551
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:549-552
    // const validatorConfig = abiCall(ValidatorRegistryInterface.prototype.getValidatorConfig, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:558
    // const epochRoundLength = validatorConfig.epochRoundLength.native
    dup
    pushint 173 // 173
    extract_uint32
    dup
    cover 2
    // contracts/stakingPool.algo.ts:559
    // const curRound = Global.round
    global Round
    // contracts/stakingPool.algo.ts:560
    // const thisEpochBegin: uint64 = curRound - (curRound % epochRoundLength)
    dup
    dig 2
    %
    dig 1
    swap
    -
    dup
    cover 2
    cover 4
    // contracts/stakingPool.algo.ts:563
    // const lastPayoutEpoch: uint64 = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
    intc_0 // 0
    // contracts/stakingPool.algo.ts:91
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:563
    // const lastPayoutEpoch: uint64 = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
    app_global_get_ex
    assert // check GlobalState exists
    dup
    uncover 4
    %
    -
    // contracts/stakingPool.algo.ts:565
    // assert(lastPayoutEpoch !== thisEpochBegin, "can't call epochBalanceUpdate in same epoch as prior call")
    uncover 2
    !=
    assert // can't call epochBalanceUpdate in same epoch as prior call
    // contracts/stakingPool.algo.ts:567
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:91
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:570
    // this.lastPayout.value = curRound
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:571
    // this.epochNumber.value += 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:94
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:571
    // this.epochNumber.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // contracts/stakingPool.algo.ts:94
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:571
    // this.epochNumber.value += 1
    swap
    app_global_put
    intc 5 // 157
    // contracts/stakingPool.algo.ts:576
    // const isTokenEligible = validatorConfig.rewardTokenId !== 0
    extract_uint64
    dup
    // contracts/stakingPool.algo.ts:577
    // let poolOneAppID = Global.currentApplicationId.id
    global CurrentApplicationID
    swap
    // contracts/stakingPool.algo.ts:578
    // let poolOneAddress = Global.currentApplicationAddress
    global CurrentApplicationAddress
    dup
    cover 2
    swap
    // contracts/stakingPool.algo.ts:583
    // if (isTokenEligible) {
    bz epochBalanceUpdate_after_if_else@11
    // contracts/stakingPool.algo.ts:584
    // if (this.poolId.value !== 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:584
    // if (this.poolId.value !== 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    !=
    bz epochBalanceUpdate_after_if_else@5
    // contracts/stakingPool.algo.ts:586-589
    // poolOneAppID = abiCall(ValidatorRegistryInterface.prototype.getPoolAppId, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value, 1],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:587
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:587
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:588
    // args: [this.validatorId.value, 1],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:588
    // args: [this.validatorId.value, 1],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    intc_1 // 1
    itob
    // contracts/stakingPool.algo.ts:586-589
    // poolOneAppID = abiCall(ValidatorRegistryInterface.prototype.getPoolAppId, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value, 1],
    // }).returnValue
    bytec 25 // method "getPoolAppId(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    dup
    frame_bury 47
    // contracts/stakingPool.algo.ts:591
    // poolOneAddress = Application(poolOneAppID).address
    app_params_get AppAddress
    swap
    frame_bury 48
    assert // application exists

epochBalanceUpdate_after_if_else@5:
    // contracts/stakingPool.algo.ts:596
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:596
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz epochBalanceUpdate_else_body@8
    // contracts/stakingPool.algo.ts:597-600
    // tokenPayoutRatio = abiCall(ValidatorRegistryInterface.prototype.setTokenPayoutRatio, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:598
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:598
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:599
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:599
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:597-600
    // tokenPayoutRatio = abiCall(ValidatorRegistryInterface.prototype.setTokenPayoutRatio, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 26 // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    frame_bury 42
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix

epochBalanceUpdate_after_if_else@10:
    frame_dig 48
    frame_bury 49

epochBalanceUpdate_after_if_else@11:
    frame_dig 49
    frame_bury 48
    // contracts/stakingPool.algo.ts:618-621
    // const validatorState = abiCall(ValidatorRegistryInterface.prototype.getValidatorState, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:619
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:619
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:620
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:620
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:618-621
    // const validatorState = abiCall(ValidatorRegistryInterface.prototype.getValidatorState, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:622
    // const rewardTokenHeldBack = validatorState.rewardTokenHeldBack
    dup
    pushint 22 // 22
    extract_uint64
    frame_bury 26
    // contracts/stakingPool.algo.ts:629
    // Global.currentApplicationAddress.balance -
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // contracts/stakingPool.algo.ts:630
    // this.totalAlgoStaked.value -
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:630
    // this.totalAlgoStaked.value -
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:629-630
    // Global.currentApplicationAddress.balance -
    // this.totalAlgoStaked.value -
    -
    // contracts/stakingPool.algo.ts:631
    // Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contracts/stakingPool.algo.ts:629-631
    // Global.currentApplicationAddress.balance -
    // this.totalAlgoStaked.value -
    // Global.currentApplicationAddress.minBalance
    -
    frame_bury 7
    // contracts/stakingPool.algo.ts:632
    // let isPoolSaturated = false
    intc_0 // 0
    frame_bury 19
    // contracts/stakingPool.algo.ts:1033
    // return op.onlineStake()
    online_stake
    // contracts/stakingPool.algo.ts:1020
    // return wideRatio([online, MAX_VALIDATOR_SOFT_PCT_OF_ONLINE_1DECIMAL], [1000])
    itob
    bytec 8 // 0x0002
    swap
    concat
    pushint 100 // 100
    itob
    concat
    pushint 1000 // 1000
    itob
    frame_bury 2
    pushbytes 0x000100000000000003e8
    callsub wideRatio
    popn 2
    dup
    frame_bury 10
    // contracts/stakingPool.algo.ts:641
    // if (validatorState.totalAlgoStaked > algoSaturationAmt) {
    swap
    pushint 14 // 14
    extract_uint64
    dup
    frame_bury 39
    <
    bz epochBalanceUpdate_after_if_else@14
    // contracts/stakingPool.algo.ts:642
    // isPoolSaturated = true
    intc_1 // 1
    frame_bury 19

epochBalanceUpdate_after_if_else@14:
    // contracts/stakingPool.algo.ts:648
    // let tokenRewardAvail: uint64 = 0
    intc_0 // 0
    dup
    frame_bury 31
    // contracts/stakingPool.algo.ts:649
    // let tokenRewardPaidOut: uint64 = 0
    intc_0 // 0
    frame_bury 34
    // contracts/stakingPool.algo.ts:650
    // let validatorCommissionPaidOut: uint64 = 0
    intc_0 // 0
    frame_bury 36
    // contracts/stakingPool.algo.ts:651
    // let excessToFeeSink: uint64 = 0
    intc_0 // 0
    frame_bury 15
    frame_bury 32
    // contracts/stakingPool.algo.ts:652
    // if (isTokenEligible) {
    frame_dig 46
    bz epochBalanceUpdate_after_if_else@18
    // contracts/stakingPool.algo.ts:654
    // op.AssetHolding.assetBalance(poolOneAddress, validatorConfig.rewardTokenId)[0] -
    frame_dig 48
    frame_dig 46
    asset_holding_get AssetBalance
    pop
    // contracts/stakingPool.algo.ts:654-655
    // op.AssetHolding.assetBalance(poolOneAddress, validatorConfig.rewardTokenId)[0] -
    // op.btoi(Bytes(rewardTokenHeldBack))
    frame_dig 26
    -
    // contracts/stakingPool.algo.ts:659
    // if (tokenRewardBal >= validatorConfig.rewardPerPayout) {
    frame_dig 43
    pushint 165 // 165
    extract_uint64
    dup
    frame_bury 40
    >=
    bz epochBalanceUpdate_after_if_else@17
    // contracts/stakingPool.algo.ts:665
    // const ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:665
    // const ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    -
    frame_dig 42
    extract 0 192
    swap
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/stakingPool.algo.ts:668
    // tokenRewardAvail = wideRatio([validatorConfig.rewardPerPayout, ourPoolPctOfWhole], [1_000_000])
    frame_dig 40
    itob
    bytec 8 // 0x0002
    swap
    concat
    swap
    concat
    bytec 18 // 0x000100000000000f4240
    callsub wideRatio
    popn 2
    frame_bury 31

epochBalanceUpdate_after_if_else@17:
    frame_dig 31
    frame_bury 32

epochBalanceUpdate_after_if_else@18:
    frame_dig 32
    dup
    frame_bury 31
    // contracts/stakingPool.algo.ts:671
    // if (tokenRewardAvail === 0) {
    bnz epochBalanceUpdate_after_if_else@22
    // contracts/stakingPool.algo.ts:676
    // if (algoRewardAvail < 1_000_000) {
    frame_dig 7
    intc 8 // 1000000
    <
    bz epochBalanceUpdate_after_if_else@22
    // contracts/stakingPool.algo.ts:677
    // log('!token&&!noalgo to pay')
    pushbytes "!token&&!noalgo to pay"
    log
    // contracts/stakingPool.algo.ts:678
    // return
    retsub

epochBalanceUpdate_after_if_else@22:
    // contracts/stakingPool.algo.ts:682
    // if (isPoolSaturated) {
    frame_dig 19
    bz epochBalanceUpdate_else_body@27
    // contracts/stakingPool.algo.ts:689
    // [algoRewardAvail, validatorConfig.percentToValidator.native],
    frame_dig 43
    pushint 177 // 177
    extract_uint32
    frame_dig 7
    dup
    cover 2
    itob
    bytec 8 // 0x0002
    swap
    concat
    swap
    itob
    dig 1
    swap
    concat
    // contracts/stakingPool.algo.ts:690
    // [1_000_000],
    bytec 18 // 0x000100000000000f4240
    // contracts/stakingPool.algo.ts:688-691
    // const normalValidatorCommission = wideRatio(
    //     [algoRewardAvail, validatorConfig.percentToValidator.native],
    //     [1_000_000],
    // )
    callsub wideRatio
    popn 2
    swap
    // contracts/stakingPool.algo.ts:694
    // [algoRewardAvail, algoSaturationAmt],
    frame_dig 10
    itob
    concat
    // contracts/stakingPool.algo.ts:695
    // [op.btoi(Bytes(validatorState.totalAlgoStaked))],
    frame_dig 39
    itob
    btoi
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:693-696
    // let diminishedReward = wideRatio(
    //     [algoRewardAvail, algoSaturationAmt],
    //     [op.btoi(Bytes(validatorState.totalAlgoStaked))],
    // )
    callsub wideRatio
    popn 2
    dup
    frame_bury 13
    // contracts/stakingPool.algo.ts:698
    // if (diminishedReward > algoRewardAvail - normalValidatorCommission) {
    cover 2
    -
    dup
    frame_bury 14
    >
    bz epochBalanceUpdate_after_if_else@25
    frame_dig 14
    frame_bury 13

epochBalanceUpdate_after_if_else@25:
    // contracts/stakingPool.algo.ts:702
    // excessToFeeSink = algoRewardAvail - diminishedReward
    frame_dig 7
    frame_dig 13
    dup
    cover 2
    -
    dup
    frame_bury 15
    // contracts/stakingPool.algo.ts:703-707
    // itxn.payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:705
    // receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    txn FirstValid
    intc_1 // 1
    -
    block BlkFeeSink
    // contracts/stakingPool.algo.ts:706
    // note: 'pool saturated, excess to fee sink',
    pushbytes "pool saturated, excess to fee sink"
    itxn_field Note
    itxn_field Receiver
    itxn_field Amount
    // contracts/stakingPool.algo.ts:703-707
    // itxn.payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    frame_bury 7

epochBalanceUpdate_after_if_else@39:
    // contracts/stakingPool.algo.ts:757
    // let increasedStake: uint64 = 0
    intc_0 // 0
    frame_bury 17
    // contracts/stakingPool.algo.ts:781
    // if (algoRewardAvail !== 0 || tokenRewardAvail !== 0) {
    frame_dig 7
    bnz epochBalanceUpdate_if_body@41
    frame_dig 34
    frame_bury 35
    frame_dig 17
    frame_bury 18
    frame_dig 31
    bz epochBalanceUpdate_after_if_else@68

epochBalanceUpdate_if_body@41:
    // contracts/stakingPool.algo.ts:782
    // let partialStakersTotalStake: uint64 = 0
    intc_0 // 0
    frame_bury 24
    // contracts/stakingPool.algo.ts:786
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    frame_bury 16
    frame_dig 7
    frame_bury 8
    frame_dig 31
    frame_bury 32

epochBalanceUpdate_while_top@42:
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:786
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 16
    intc 4 // 200
    <
    bz epochBalanceUpdate_after_while@53
    // contracts/stakingPool.algo.ts:787
    // ensureBudget(400)
    pushint 400 // 400
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:788
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 16
    intc_2 // 64
    *
    dup
    frame_bury 11
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:788
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 3
    // contracts/stakingPool.algo.ts:788-789
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account.native !== Global.zeroAddress) {
    extract 0 32
    // contracts/stakingPool.algo.ts:789
    // if (cmpStaker.account.native !== Global.zeroAddress) {
    global ZeroAddress
    !=
    frame_dig 17
    frame_bury 18
    frame_dig 8
    frame_bury 9
    frame_dig 34
    frame_bury 35
    frame_dig 32
    frame_bury 33
    frame_dig 24
    frame_bury 25
    bz epochBalanceUpdate_after_if_else@52
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:788
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 11
    intc_2 // 64
    box_extract
    pushint 56 // 56
    // contracts/stakingPool.algo.ts:790
    // if (cmpStaker.entryRound >= thisEpochBegin) {
    extract_uint64
    dup
    frame_bury 41
    frame_dig 45
    >=
    bz epochBalanceUpdate_else_body@46
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:788
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 11
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // contracts/stakingPool.algo.ts:793
    // partialStakersTotalStake += cmpStaker.balance
    extract_uint64
    frame_dig 24
    +
    frame_bury 24

epochBalanceUpdate_after_if_else@51:
    frame_dig 17
    frame_bury 18
    frame_dig 8
    frame_bury 9
    frame_dig 34
    frame_bury 35
    frame_dig 32
    frame_bury 33
    frame_dig 24
    frame_bury 25

epochBalanceUpdate_after_if_else@52:
    frame_dig 18
    frame_bury 17
    frame_dig 9
    frame_bury 8
    frame_dig 35
    frame_bury 34
    frame_dig 33
    frame_bury 32
    frame_dig 25
    frame_bury 24
    // contracts/stakingPool.algo.ts:786
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 16
    intc_1 // 1
    +
    frame_bury 16
    b epochBalanceUpdate_while_top@42

epochBalanceUpdate_else_body@46:
    // contracts/stakingPool.algo.ts:797
    // const timeInPool: uint64 = thisEpochBegin - cmpStaker.entryRound
    frame_dig 45
    frame_dig 41
    -
    dup
    frame_bury 27
    // contracts/stakingPool.algo.ts:801
    // if (timeInPool < epochRoundLength) {
    frame_dig 44
    <
    frame_dig 17
    frame_bury 18
    frame_dig 8
    frame_bury 9
    frame_dig 34
    frame_bury 35
    frame_dig 32
    frame_bury 33
    frame_dig 24
    frame_bury 25
    bz epochBalanceUpdate_after_if_else@50
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:788
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 11
    intc_2 // 64
    box_extract
    pushint 32 // 32
    // contracts/stakingPool.algo.ts:802
    // partialStakersTotalStake += cmpStaker.balance
    extract_uint64
    dup
    frame_bury 37
    frame_dig 24
    +
    frame_bury 24
    // contracts/stakingPool.algo.ts:803
    // timePercentage = (timeInPool * 1000) / epochRoundLength
    frame_dig 27
    pushint 1000 // 1000
    *
    frame_dig 44
    /
    frame_bury 28
    frame_dig 34
    frame_bury 35
    frame_dig 32
    dup
    frame_bury 33
    frame_dig 3
    frame_bury 4
    // contracts/stakingPool.algo.ts:805
    // if (tokenRewardAvail > 0) {
    bz epochBalanceUpdate_after_if_else@49
    // contracts/stakingPool.algo.ts:808
    // [cmpStaker.balance, origTokenReward, timePercentage],
    frame_dig 37
    itob
    bytec 27 // 0x0003
    swap
    concat
    frame_dig 31
    itob
    concat
    frame_dig 28
    itob
    concat
    // contracts/stakingPool.algo.ts:809
    // [this.totalAlgoStaked.value, 1000],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:809
    // [this.totalAlgoStaked.value, 1000],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 2
    concat
    // contracts/stakingPool.algo.ts:807-810
    // const stakerTokenReward = wideRatio(
    //     [cmpStaker.balance, origTokenReward, timePercentage],
    //     [this.totalAlgoStaked.value, 1000],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:814
    // tokenRewardAvail -= stakerTokenReward
    frame_dig 32
    dig 1
    -
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:788
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 11
    intc_2 // 64
    box_extract
    pushint 48 // 48
    // contracts/stakingPool.algo.ts:815
    // cmpStaker.rewardTokenBalance += stakerTokenReward
    extract_uint64
    dig 2
    +
    itob
    frame_dig 3
    swap
    replace2 48
    // contracts/stakingPool.algo.ts:816
    // tokenRewardPaidOut += stakerTokenReward
    frame_dig 34
    uncover 3
    +
    frame_bury 35
    frame_bury 4
    frame_bury 33

epochBalanceUpdate_after_if_else@49:
    frame_dig 33
    frame_dig 35
    frame_dig 4
    // contracts/stakingPool.algo.ts:820
    // [cmpStaker.balance, origAlgoReward, timePercentage],
    dup
    pushint 32 // 32
    extract_uint64
    dup
    itob
    bytec 27 // 0x0003
    swap
    concat
    frame_dig 7
    itob
    concat
    frame_dig 28
    itob
    concat
    // contracts/stakingPool.algo.ts:821
    // [this.totalAlgoStaked.value, 1000],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:821
    // [this.totalAlgoStaked.value, 1000],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 2
    concat
    // contracts/stakingPool.algo.ts:819-822
    // const stakerReward = wideRatio(
    //     [cmpStaker.balance, origAlgoReward, timePercentage],
    //     [this.totalAlgoStaked.value, 1000],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:825
    // algoRewardAvail -= stakerReward
    frame_dig 8
    dig 1
    -
    // contracts/stakingPool.algo.ts:828
    // cmpStaker.balance += stakerReward
    uncover 2
    dig 2
    +
    itob
    uncover 3
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:829
    // cmpStaker.totalRewarded += stakerReward
    dup
    pushint 40 // 40
    extract_uint64
    dig 3
    +
    itob
    replace2 40
    // contracts/stakingPool.algo.ts:830
    // increasedStake += stakerReward
    frame_dig 17
    uncover 3
    +
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:832
    // this.stakers.value[i] = clone(cmpStaker)
    frame_dig 11
    uncover 3
    box_replace
    frame_bury 18
    frame_bury 9
    frame_bury 35
    frame_bury 33
    frame_dig 24
    frame_bury 25

epochBalanceUpdate_after_if_else@50:
    frame_dig 18
    frame_bury 17
    frame_dig 9
    frame_bury 8
    frame_dig 35
    frame_bury 34
    frame_dig 33
    frame_bury 32
    frame_dig 25
    frame_bury 24
    b epochBalanceUpdate_after_if_else@51

epochBalanceUpdate_after_while@53:
    // contracts/stakingPool.algo.ts:840
    // const newPoolTotalStake: uint64 = this.totalAlgoStaked.value - partialStakersTotalStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:840
    // const newPoolTotalStake: uint64 = this.totalAlgoStaked.value - partialStakersTotalStake
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig 24
    -
    dup
    frame_bury 23
    frame_dig 34
    frame_bury 35
    frame_dig 17
    frame_bury 18
    // contracts/stakingPool.algo.ts:844
    // if (newPoolTotalStake > 0) {
    bz epochBalanceUpdate_after_if_else@67
    // contracts/stakingPool.algo.ts:846
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    frame_bury 20

epochBalanceUpdate_while_top@55:
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:846
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    frame_dig 20
    intc 4 // 200
    <
    bz epochBalanceUpdate_after_while@66
    // contracts/stakingPool.algo.ts:847
    // ensureBudget(200)
    intc 4 // 200
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:848
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 20
    intc_2 // 64
    *
    dup
    frame_bury 12
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:848
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    frame_bury 5
    // contracts/stakingPool.algo.ts:848-849
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account.native !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    extract 0 32
    // contracts/stakingPool.algo.ts:849
    // if (cmpStaker.account.native !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    global ZeroAddress
    !=
    frame_dig 17
    frame_bury 18
    frame_dig 34
    frame_bury 35
    bz epochBalanceUpdate_after_if_else@65
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:848-849
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account.native !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    frame_dig 12
    intc_2 // 64
    box_extract
    pushint 56 // 56
    // contracts/stakingPool.algo.ts:849
    // if (cmpStaker.account.native !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    extract_uint64
    dup
    frame_bury 38
    frame_dig 45
    <
    frame_dig 17
    frame_bury 18
    frame_dig 34
    frame_bury 35
    bz epochBalanceUpdate_after_if_else@65
    // contracts/stakingPool.algo.ts:850
    // const timeInPool: uint64 = thisEpochBegin - cmpStaker.entryRound
    frame_dig 45
    frame_dig 38
    -
    // contracts/stakingPool.algo.ts:852
    // if (timeInPool >= epochRoundLength) {
    frame_dig 44
    >=
    frame_dig 17
    frame_bury 18
    frame_dig 34
    frame_bury 35
    bz epochBalanceUpdate_after_if_else@64
    frame_dig 34
    frame_bury 35
    frame_dig 5
    frame_bury 6
    // contracts/stakingPool.algo.ts:857
    // if (tokenRewardAvail > 0) {
    frame_dig 32
    bz epochBalanceUpdate_after_if_else@61
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:848
    // const cmpStaker = clone(this.stakers.value[i])
    frame_dig 12
    dup
    cover 2
    intc_2 // 64
    box_extract
    extract 32 8
    // contracts/stakingPool.algo.ts:859
    // [cmpStaker.balance, tokenRewardAvail],
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 32
    itob
    concat
    // contracts/stakingPool.algo.ts:860
    // [newPoolTotalStake],
    frame_dig 23
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:858-861
    // const stakerTokenReward = wideRatio(
    //     [cmpStaker.balance, tokenRewardAvail],
    //     [newPoolTotalStake],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:848
    // const cmpStaker = clone(this.stakers.value[i])
    uncover 2
    intc_2 // 64
    box_extract
    pushint 48 // 48
    // contracts/stakingPool.algo.ts:863
    // cmpStaker.rewardTokenBalance += stakerTokenReward
    extract_uint64
    dig 1
    +
    itob
    frame_dig 5
    swap
    replace2 48
    // contracts/stakingPool.algo.ts:864
    // tokenRewardPaidOut += stakerTokenReward
    frame_dig 34
    uncover 2
    +
    frame_bury 35
    frame_bury 6

epochBalanceUpdate_after_if_else@61:
    frame_dig 35
    frame_bury 34
    frame_dig 6
    dup
    frame_bury 5
    frame_dig 17
    frame_bury 18
    frame_bury 6
    // contracts/stakingPool.algo.ts:866
    // if (algoRewardAvail > 0) {
    frame_dig 8
    bz epochBalanceUpdate_after_if_else@63
    // contracts/stakingPool.algo.ts:868
    // [cmpStaker.balance, algoRewardAvail],
    frame_dig 5
    dup
    pushint 32 // 32
    extract_uint64
    dup
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 8
    itob
    concat
    // contracts/stakingPool.algo.ts:869
    // [newPoolTotalStake],
    frame_dig 23
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:867-870
    // const stakerReward = wideRatio(
    //     [cmpStaker.balance, algoRewardAvail],
    //     [newPoolTotalStake],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:873
    // cmpStaker.balance += stakerReward
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:874
    // cmpStaker.totalRewarded += stakerReward
    dup
    pushint 40 // 40
    extract_uint64
    dig 2
    +
    itob
    replace2 40
    // contracts/stakingPool.algo.ts:875
    // increasedStake += stakerReward
    frame_dig 17
    uncover 2
    +
    frame_bury 18
    frame_bury 6

epochBalanceUpdate_after_if_else@63:
    frame_dig 18
    frame_dig 6
    // contracts/stakingPool.algo.ts:100
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:879
    // this.stakers.value[i] = clone(cmpStaker)
    frame_dig 12
    uncover 2
    box_replace
    frame_bury 18
    frame_dig 34
    frame_bury 35

epochBalanceUpdate_after_if_else@64:
    b epochBalanceUpdate_after_if_else@65

epochBalanceUpdate_after_if_else@65:
    frame_dig 18
    frame_bury 17
    frame_dig 35
    frame_bury 34
    // contracts/stakingPool.algo.ts:846
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    frame_dig 20
    intc_1 // 1
    +
    frame_bury 20
    b epochBalanceUpdate_while_top@55

epochBalanceUpdate_after_while@66:
    frame_dig 34
    frame_bury 35
    frame_dig 17
    frame_bury 18

epochBalanceUpdate_after_if_else@67:
    b epochBalanceUpdate_after_if_else@68

epochBalanceUpdate_after_if_else@68:
    frame_dig 35
    frame_dig 18
    // contracts/stakingPool.algo.ts:889
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:889
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:889
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:890
    // this.totalAlgoStaked.value += increasedStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:890
    // this.totalAlgoStaked.value += increasedStake
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    +
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:890
    // this.totalAlgoStaked.value += increasedStake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:892
    // this.stakeAccumulator.value.native + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:892
    // this.stakeAccumulator.value.native + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    app_global_get_ex
    assert // check GlobalState exists
    dig 2
    itob
    uncover 2
    itob
    dig 1
    b*
    uncover 2
    b+
    // contracts/stakingPool.algo.ts:891-893
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.native + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:891-893
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.native + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:894
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:894
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    // contracts/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:894
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:900-909
    // abiCall(ValidatorRegistryInterface.prototype.stakeUpdatedViaRewards, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //         increasedStake,
    //         tokenRewardPaidOut,
    //         validatorCommissionPaidOut,
    //         excessToFeeSink,
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:901
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:901
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:903
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:903
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:903
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationID
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:905
    // tokenRewardPaidOut,
    uncover 3
    itob
    // contracts/stakingPool.algo.ts:906
    // validatorCommissionPaidOut,
    frame_dig 36
    itob
    // contracts/stakingPool.algo.ts:907
    // excessToFeeSink,
    frame_dig 15
    itob
    // contracts/stakingPool.algo.ts:900-909
    // abiCall(ValidatorRegistryInterface.prototype.stakeUpdatedViaRewards, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //         increasedStake,
    //         tokenRewardPaidOut,
    //         validatorCommissionPaidOut,
    //         excessToFeeSink,
    //     ],
    // })
    pushbytes 0x418fcefc // method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub

epochBalanceUpdate_else_body@27:
    // contracts/stakingPool.algo.ts:710
    // } else if (validatorConfig.percentToValidator.native !== 0) {
    frame_dig 43
    pushint 177 // 177
    extract_uint32
    dup
    frame_bury 29
    frame_dig 7
    frame_bury 8
    bz epochBalanceUpdate_after_if_else@38
    // contracts/stakingPool.algo.ts:714
    // [algoRewardAvail, validatorConfig.percentToValidator.native],
    frame_dig 7
    dup
    itob
    bytec 8 // 0x0002
    swap
    concat
    frame_dig 29
    itob
    concat
    // contracts/stakingPool.algo.ts:715
    // [1_000_000],
    bytec 18 // 0x000100000000000f4240
    // contracts/stakingPool.algo.ts:713-716
    // validatorCommissionPaidOut = wideRatio(
    //     [algoRewardAvail, validatorConfig.percentToValidator.native],
    //     [1_000_000],
    // )
    callsub wideRatio
    popn 2
    dup
    frame_bury 36
    // contracts/stakingPool.algo.ts:719
    // algoRewardAvail -= validatorCommissionPaidOut
    swap
    dig 1
    -
    frame_bury 7
    // contracts/stakingPool.algo.ts:726
    // if (validatorCommissionPaidOut > 0) {
    bz epochBalanceUpdate_after_if_else@37
    // contracts/stakingPool.algo.ts:729
    // let managerTopOff: uint64 = 0
    intc_0 // 0
    dup
    frame_bury 21
    // contracts/stakingPool.algo.ts:731
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    frame_dig 43
    dup
    extract 44 32
    dup
    cover 2
    frame_bury 0
    extract 181 32
    dup
    frame_bury 1
    !=
    swap
    frame_bury 22
    // contracts/stakingPool.algo.ts:731-732
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    // validatorConfig.manager.native.balance - validatorConfig.manager.native.minBalance < 2_100_000
    bz epochBalanceUpdate_after_if_else@33
    // contracts/stakingPool.algo.ts:732
    // validatorConfig.manager.native.balance - validatorConfig.manager.native.minBalance < 2_100_000
    frame_dig 0
    dup
    acct_params_get AcctBalance
    assert // account funded
    swap
    acct_params_get AcctMinBalance
    assert // account funded
    -
    intc 7 // 2100000
    <
    frame_dig 21
    frame_bury 22
    // contracts/stakingPool.algo.ts:731-732
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    // validatorConfig.manager.native.balance - validatorConfig.manager.native.minBalance < 2_100_000
    bz epochBalanceUpdate_after_if_else@33
    // contracts/stakingPool.algo.ts:734
    // managerTopOff = validatorCommissionPaidOut < 2_100_000 ? validatorCommissionPaidOut : 2_100_000
    frame_dig 36
    dup
    intc 7 // 2100000
    <
    intc 7 // 2100000
    cover 2
    select
    // contracts/stakingPool.algo.ts:735-739
    // itxn.payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager.native,
    //     note: 'validator reward to manager for funding epoch updates',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:738
    // note: 'validator reward to manager for funding epoch updates',
    pushbytes "validator reward to manager for funding epoch updates"
    itxn_field Note
    frame_dig 0
    itxn_field Receiver
    dup
    itxn_field Amount
    // contracts/stakingPool.algo.ts:735-739
    // itxn.payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager.native,
    //     note: 'validator reward to manager for funding epoch updates',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    frame_bury 22

epochBalanceUpdate_after_if_else@33:
    // contracts/stakingPool.algo.ts:741
    // if (validatorCommissionPaidOut - managerTopOff > 0) {
    frame_dig 36
    frame_dig 22
    -
    dup
    frame_bury 30
    bz epochBalanceUpdate_after_if_else@37
    // contracts/stakingPool.algo.ts:742-746
    // itxn.payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress.native,
    //     note: 'validator reward',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:745
    // note: 'validator reward',
    pushbytes "validator reward"
    itxn_field Note
    frame_dig 1
    itxn_field Receiver
    frame_dig 30
    itxn_field Amount
    // contracts/stakingPool.algo.ts:742-746
    // itxn.payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress.native,
    //     note: 'validator reward',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

epochBalanceUpdate_after_if_else@37:
    frame_dig 7
    frame_bury 8

epochBalanceUpdate_after_if_else@38:
    frame_dig 8
    frame_bury 7
    b epochBalanceUpdate_after_if_else@39

epochBalanceUpdate_else_body@8:
    // contracts/stakingPool.algo.ts:603-612
    // tokenPayoutRatio = abiCall(StakingPool.prototype.proxiedSetTokenPayoutRatio, {
    //     appId: Application(poolOneAppID),
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //     ],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:607
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:607
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:608
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:608
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:609
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:606-610
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:603-612
    // tokenPayoutRatio = abiCall(StakingPool.prototype.proxiedSetTokenPayoutRatio, {
    //     appId: Application(poolOneAppID),
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //     ],
    // }).returnValue
    bytec 20 // method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 47
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    frame_bury 42
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    b epochBalanceUpdate_after_if_else@10


// contracts/stakingPool.algo.ts::StakingPool.goOnline(feePayment: uint64, votePK: bytes, selectionPK: bytes, stateProofPK: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64) -> void:
goOnline:
    // contracts/stakingPool.algo.ts:925-933
    // goOnline(
    //     feePayment: gtxn.PaymentTxn,
    //     votePK: bytes<32>,
    //     selectionPK: bytes<32>,
    //     stateProofPK: bytes<64>,
    //     voteFirst: uint64,
    //     voteLast: uint64,
    //     voteKeyDilution: uint64,
    // ): void {
    proto 7 0
    // contracts/stakingPool.algo.ts:934
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:1026
    // if (!op.AcctParams.acctIncentiveEligible(Global.currentApplicationAddress)[0]) {
    global CurrentApplicationAddress
    acct_params_get AcctIncentiveEligible
    pop
    bnz goOnline_after_if_else@4
    // contracts/stakingPool.algo.ts:1027
    // return Global.payoutsGoOnlineFee
    global PayoutsGoOnlineFee

goOnline_after_inlined_contracts/stakingPool.algo.ts::StakingPool.getGoOnlineFee@5:
    // contracts/stakingPool.algo.ts:936
    // assertMatch(feePayment, { receiver: Global.currentApplicationAddress, amount: extraFee })
    frame_dig -7
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    frame_dig -7
    gtxns Amount
    dig 2
    ==
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:937-945
    // itxn.keyRegistration({
    //     voteKey: votePK,
    //     selectionKey: selectionPK,
    //     stateProofKey: stateProofPK,
    //     voteFirst: voteFirst,
    //     voteLast: voteLast,
    //     voteKeyDilution: voteKeyDilution,
    //     fee: extraFee,
    // }).submit()
    itxn_begin
    frame_dig -1
    itxn_field VoteKeyDilution
    frame_dig -2
    itxn_field VoteLast
    frame_dig -3
    itxn_field VoteFirst
    frame_dig -4
    itxn_field StateProofPK
    frame_dig -5
    itxn_field SelectionPK
    frame_dig -6
    itxn_field VotePK
    pushint 2 // 2
    itxn_field TypeEnum
    itxn_field Fee
    itxn_submit
    retsub

goOnline_after_if_else@4:
    // contracts/stakingPool.algo.ts:1029
    // return 0
    intc_0 // 0
    // contracts/stakingPool.algo.ts:935
    // const extraFee = this.getGoOnlineFee()
    b goOnline_after_inlined_contracts/stakingPool.algo.ts::StakingPool.getGoOnlineFee@5


// contracts/stakingPool.algo.ts::StakingPool.goOffline() -> void:
goOffline:
    // contracts/stakingPool.algo.ts:956
    // if (Txn.sender !== Application(this.creatingValidatorContractAppId.value).address) {
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:956
    // if (Txn.sender !== Application(this.creatingValidatorContractAppId.value).address) {
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    !=
    bz goOffline_after_if_else@2
    // contracts/stakingPool.algo.ts:957
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator

goOffline_after_if_else@2:
    // contracts/stakingPool.algo.ts:960
    // itxn.keyRegistration({}).submit()
    itxn_begin
    pushint 2 // 2
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// contracts/stakingPool.algo.ts::StakingPool.linkToNFD(nfdAppId: uint64, nfdName: bytes) -> void:
linkToNFD:
    // contracts/stakingPool.algo.ts:966
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    proto 2 0
    // contracts/stakingPool.algo.ts:967
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:969-978
    // itxn.applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //         Bytes('verify_nfd_addr'),
    //         Bytes(nfdName),
    //         op.itob(nfdAppId),
    //         encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:970
    // appId: Application(nfdRegistryAppId),
    intc 10 // TMPL_NFD_REGISTRY_APP_ID
    // contracts/stakingPool.algo.ts:974
    // op.itob(nfdAppId),
    frame_dig -2
    itob
    // contracts/stakingPool.algo.ts:975
    // encodeArc4(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    frame_dig -2
    itxn_field Applications
    // contracts/stakingPool.algo.ts:972
    // Bytes('verify_nfd_addr'),
    pushbytes "verify_nfd_addr"
    itxn_field ApplicationArgs
    frame_dig -1
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // contracts/stakingPool.algo.ts:969-978
    // itxn.applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //         Bytes('verify_nfd_addr'),
    //         Bytes(nfdName),
    //         op.itob(nfdAppId),
    //         encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    // }).submit()
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    retsub


// contracts/stakingPool.algo.ts::StakingPool.proxiedSetTokenPayoutRatio(poolKey: bytes) -> bytes:
proxiedSetTokenPayoutRatio:
    // contracts/stakingPool.algo.ts:987
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    proto 1 1
    // contracts/stakingPool.algo.ts:988
    // assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:988
    // assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
    app_global_get_ex
    assert // check GlobalState exists
    frame_dig -1
    extract 0 8
    frame_dig -1
    intc_0 // 0
    extract_uint64
    dig 2
    ==
    assert // caller must be part of same validator set!
    // contracts/stakingPool.algo.ts:989
    // assert(this.poolId.value === 1, 'callee must be pool 1')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec 4 // "poolId"
    // contracts/stakingPool.algo.ts:989
    // assert(this.poolId.value === 1, 'callee must be pool 1')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // callee must be pool 1
    // contracts/stakingPool.algo.ts:990
    // assert(poolKey.poolId !== 1, 'caller must NOT be pool 1')
    frame_dig -1
    extract 8 8
    frame_dig -1
    pushint 8 // 8
    extract_uint64
    intc_1 // 1
    !=
    assert // caller must NOT be pool 1
    // contracts/stakingPool.algo.ts:992-995
    // const callerPoolAppID = abiCall(ValidatorRegistryInterface.prototype.getPoolAppId, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [poolKey.id, poolKey.poolId],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:993
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:993
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:992-995
    // const callerPoolAppID = abiCall(ValidatorRegistryInterface.prototype.getPoolAppId, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [poolKey.id, poolKey.poolId],
    // }).returnValue
    bytec 25 // method "getPoolAppId(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // contracts/stakingPool.algo.ts:996
    // assert(callerPoolAppID === poolKey.poolAppId)
    frame_dig -1
    intc_3 // 16
    extract_uint64
    swap
    dig 1
    ==
    assert
    // contracts/stakingPool.algo.ts:997
    // assert(Txn.sender === Application(poolKey.poolAppId).address)
    txn Sender
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    assert
    // contracts/stakingPool.algo.ts:999-1002
    // return abiCall(ValidatorRegistryInterface.prototype.setTokenPayoutRatio, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:1001
    // args: [this.validatorId.value],
    swap
    itob
    // contracts/stakingPool.algo.ts:999-1002
    // return abiCall(ValidatorRegistryInterface.prototype.setTokenPayoutRatio, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 26 // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    retsub


// contracts/stakingPool.algo.ts::StakingPool.isOwnerOrManagerCaller() -> uint64:
isOwnerOrManagerCaller:
    // contracts/stakingPool.algo.ts:1005
    // private isOwnerOrManagerCaller(): boolean {
    proto 0 1
    // contracts/stakingPool.algo.ts:1006-1009
    // const OwnerAndManager = abiCall(ValidatorRegistryInterface.prototype.getValidatorOwnerAndManager, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:1007
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:74
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:1007
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:1008
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:77
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_3 // "validatorId"
    // contracts/stakingPool.algo.ts:1008
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:1006-1009
    // const OwnerAndManager = abiCall(ValidatorRegistryInterface.prototype.getValidatorOwnerAndManager, {
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    pushbytes 0x2fa22c4b // method "getValidatorOwnerAndManager(uint64)(address,address)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec_2 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:1010
    // return Txn.sender === OwnerAndManager[0].native || Txn.sender === OwnerAndManager[1].native
    txn Sender
    swap
    extract 4 32
    ==
    bnz isOwnerOrManagerCaller_bool_true@3
    txn Sender
    frame_dig 0
    extract 36 32
    ==
    bz isOwnerOrManagerCaller_bool_false@4

isOwnerOrManagerCaller_bool_true@3:
    intc_1 // 1

isOwnerOrManagerCaller_bool_merge@5:
    // contracts/stakingPool.algo.ts:1010
    // return Txn.sender === OwnerAndManager[0].native || Txn.sender === OwnerAndManager[1].native
    swap
    retsub

isOwnerOrManagerCaller_bool_false@4:
    intc_0 // 0
    b isOwnerOrManagerCaller_bool_merge@5


// contracts/stakingPool.algo.ts::StakingPool.checkIfBinClosed() -> void:
checkIfBinClosed:
    // contracts/stakingPool.algo.ts:1039
    // private checkIfBinClosed() {
    proto 0 0
    intc_0 // 0
    // contracts/stakingPool.algo.ts:1040
    // const currentBinSize = this.roundsPerDay.value
    dupn 5
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1040
    // const currentBinSize = this.roundsPerDay.value
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:1041
    // if (Global.round >= this.binRoundStart.value + currentBinSize) {
    global Round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:1041
    // if (Global.round >= this.binRoundStart.value + currentBinSize) {
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    >=
    bz checkIfBinClosed_after_if_else@9
    // contracts/stakingPool.algo.ts:1042
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:1043
    // const approxRoundsPerYear = BigUint(currentBinSize * 365)
    frame_dig 5
    dup
    pushint 365 // 365
    *
    itob
    frame_bury 1
    // contracts/stakingPool.algo.ts:1044
    // const avgStake = BigUint(this.stakeAccumulator.value.native / BigUint(currentBinSize))
    intc_0 // 0
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:1044
    // const avgStake = BigUint(this.stakeAccumulator.value.native / BigUint(currentBinSize))
    app_global_get_ex
    assert // check GlobalState exists
    swap
    itob
    dup
    frame_bury 4
    b/
    dup
    frame_bury 3
    // contracts/stakingPool.algo.ts:1045
    // if (avgStake !== 0n) {
    pushbytes 0x
    b!=
    bz checkIfBinClosed_after_if_else@8
    // contracts/stakingPool.algo.ts:1051
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    intc_0 // 0
    // contracts/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:1051
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    app_global_get_ex
    assert // check GlobalState exists
    itob
    pushbytes 0x0f4240
    b*
    frame_dig 3
    dup
    cover 2
    b/
    // contracts/stakingPool.algo.ts:1052
    // (approxRoundsPerYear / BigUint(currentBinSize))) /
    frame_dig 1
    frame_dig 4
    b/
    // contracts/stakingPool.algo.ts:1051-1052
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    //     (approxRoundsPerYear / BigUint(currentBinSize))) /
    b*
    // contracts/stakingPool.algo.ts:1053
    // 100n,
    bytec 14 // 0x64
    // contracts/stakingPool.algo.ts:1051-1053
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    //     (approxRoundsPerYear / BigUint(currentBinSize))) /
    //     100n,
    b/
    frame_bury 2
    // contracts/stakingPool.algo.ts:1056
    // let alpha = BigUint(10) // .1
    pushbytes 0x0a
    frame_bury 0
    // contracts/stakingPool.algo.ts:1058
    // if (avgStake > 300000000000n) {
    pushbytes 0x45d964b800
    b>
    bz checkIfBinClosed_after_if_else@4
    // contracts/stakingPool.algo.ts:1059
    // alpha = BigUint(90) // .9
    pushbytes 0x5a
    frame_bury 0

checkIfBinClosed_after_if_else@4:
    // contracts/stakingPool.algo.ts:1063
    // if (this.weightedMovingAverage.value.native === 0n) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1063
    // if (this.weightedMovingAverage.value.native === 0n) {
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes 0x
    b==
    bz checkIfBinClosed_else_body@6
    // contracts/stakingPool.algo.ts:1064
    // this.weightedMovingAverage.value = new Uint128(apr)
    frame_dig 2
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1064
    // this.weightedMovingAverage.value = new Uint128(apr)
    swap
    app_global_put

checkIfBinClosed_after_if_else@8:
    // contracts/stakingPool.algo.ts:1074
    // this.setRoundsPerDay()
    callsub setRoundsPerDay
    // contracts/stakingPool.algo.ts:1076
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:1076
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    app_global_get_ex
    assert // check GlobalState exists
    itob
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1076
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    app_global_get_ex
    assert // check GlobalState exists
    itob
    b*
    // contracts/stakingPool.algo.ts:1075-1077
    // this.stakeAccumulator.value = new Uint128(
    //     BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:111
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:1075-1077
    // this.stakeAccumulator.value = new Uint128(
    //     BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:115
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:1078
    // this.rewardAccumulator.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:1079
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    global Round
    dup
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1079
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    app_global_get_ex
    assert // check GlobalState exists
    %
    -
    // contracts/stakingPool.algo.ts:106
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:1079
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    swap
    app_global_put

checkIfBinClosed_after_if_else@9:
    retsub

checkIfBinClosed_else_body@6:
    // contracts/stakingPool.algo.ts:1067
    // (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    intc_0 // 0
    // contracts/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1067
    // (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    app_global_get_ex
    assert // check GlobalState exists
    bytec 14 // 0x64
    frame_dig 0
    dup
    cover 3
    b-
    b*
    bytec 14 // 0x64
    b/
    // contracts/stakingPool.algo.ts:1068
    // (apr * alpha) / BigUint(100),
    frame_dig 2
    uncover 2
    b*
    bytec 14 // 0x64
    b/
    // contracts/stakingPool.algo.ts:1067-1068
    // (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    //     (apr * alpha) / BigUint(100),
    b+
    // contracts/stakingPool.algo.ts:1066-1069
    // this.weightedMovingAverage.value = new Uint128(
    //     (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    //         (apr * alpha) / BigUint(100),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:118
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1066-1069
    // this.weightedMovingAverage.value = new Uint128(
    //     (this.weightedMovingAverage.value.native * (BigUint(100) - alpha)) / BigUint(100) +
    //         (apr * alpha) / BigUint(100),
    // )
    swap
    app_global_put
    b checkIfBinClosed_after_if_else@8


// contracts/stakingPool.algo.ts::StakingPool.setRoundsPerDay() -> void:
setRoundsPerDay:
    // contracts/stakingPool.algo.ts:1083
    // private setRoundsPerDay() {
    proto 0 0
    pushbytes ""
    // contracts/stakingPool.algo.ts:1088
    // if (Txn.firstValid < 12) {
    txn FirstValid
    pushint 12 // 12
    <
    bz setRoundsPerDay_after_if_else@2
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1090
    // this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
    intc 9 // 30857
    app_global_put
    // contracts/stakingPool.algo.ts:1091
    // return
    retsub

setRoundsPerDay_after_if_else@2:
    // contracts/stakingPool.algo.ts:1095
    // op.Block.blkTimestamp(Txn.firstValid - 1) - op.Block.blkTimestamp(Txn.firstValid - 11)
    txn FirstValid
    intc_1 // 1
    -
    block BlkTimestamp
    txn FirstValid
    pushint 11 // 11
    -
    block BlkTimestamp
    -
    dup
    frame_bury 0
    // contracts/stakingPool.algo.ts:1096
    // if (avgBlockTimeTenths === 0) {
    bnz setRoundsPerDay_after_if_else@4
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1098
    // this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
    intc 9 // 30857
    app_global_put
    // contracts/stakingPool.algo.ts:1099
    // return
    retsub

setRoundsPerDay_after_if_else@4:
    // contracts/stakingPool.algo.ts:1104
    // this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
    pushint 864000 // 864000
    frame_dig 0
    /
    // contracts/stakingPool.algo.ts:104
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1104
    // this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
    swap
    app_global_put
    retsub
