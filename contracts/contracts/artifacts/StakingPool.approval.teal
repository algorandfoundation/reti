#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 64 16 200 157 300 2100000 1000000 30857 TMPL_NFD_REGISTRY_APP_ID
    bytecblock "stakers" "creatorApp" "validatorId" "poolId" 0x151f7c75 "staked" "roundsPerDay" "stakeAccumulator" 0x0002 "binRoundStart" "numStakers" "rewardAccumulator" "ewma" 0x75aff61d 0x64 "minEntryStake" "lastPayout" "epochNumber" 0x000100000000000f4240 0x0001 0x0c2245e1 0x068101 0x00000000000000000000000000000001 0x00000000000000000000000000000000 0xa2dc51b5 0x572767d1 0x4df8d86e 0x0003
    // contracts/stakingPool.algo.ts:61
    // export class StakingPool extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@17
    pushbytess 0x3172ca9d 0x47cfcc04 0xf9c70cbd 0x421b5abe 0xf5892d56 0x5cfbb057 0x63f3f28b 0x86a3725c 0xefc2608d 0x9cee2e40 0x51ef3b21 0xa24e2717 // method "gas()void", method "initStorage(pay)void", method "addStake(pay,address)uint64", method "removeStake(address,uint64)void", method "claimTokens()void", method "getStakerInfo(address)(address,uint64,uint64,uint64,uint64)", method "payTokenReward(address,uint64,uint64)void", method "updateAlgodVer(string)void", method "epochBalanceUpdate()void", method "goOnline(pay,byte[32],byte[32],byte[64],uint64,uint64,uint64)void", method "goOffline()void", method "linkToNFD(uint64,string)void"
    bytec 20 // method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
    txna ApplicationArgs 0
    match main_gas_route@3 initStorage addStake removeStake claimTokens getStakerInfo payTokenReward updateAlgodVer epochBalanceUpdate goOnline goOffline linkToNFD proxiedSetTokenPayoutRatio
    err

main_gas_route@3:
    // contracts/stakingPool.algo.ts:155
    // gas(): void {}
    intc_1 // 1
    return

main_create_NoOp@17:
    // contracts/stakingPool.algo.ts:61
    // export class StakingPool extends Contract {
    pushbytes 0x59e90aa6 // method "createApplication(uint64,uint64,uint64,uint64)void"
    txna ApplicationArgs 0
    match createApplication
    err


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10 // 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@6
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 21 // 0x068101
    itxn_field ApprovalProgram
    bytec 21 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@5:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_after_while@6:
    retsub


// contracts/utils.algo.ts::wideRatio(numeratorFactors: bytes, denominatorFactors: bytes) -> uint64, bytes, bytes:
wideRatio:
    // contracts/utils.algo.ts:4
    // export function wideRatio(numeratorFactors: uint64[], denominatorFactors: uint64[]): uint64 {
    proto 2 3
    intc_0 // 0
    pushbytes ""
    dup
    // contracts/utils.algo.ts:5
    // let numerator = new Uint128(1n)
    bytec 22 // 0x00000000000000000000000000000001
    // contracts/utils.algo.ts:6
    // for (const factor of numeratorFactors) {
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_0 // 0

wideRatio_for_header@1:
    // contracts/utils.algo.ts:6
    // for (const factor of numeratorFactors) {
    frame_dig 5
    frame_dig 4
    <
    bz wideRatio_after_for@4
    frame_dig -2
    extract 2 0
    frame_dig 5
    dup
    cover 2
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/utils.algo.ts:7
    // numerator = new Uint128(BigUint(factor) * numerator.asBigUint())
    frame_dig 3
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    frame_bury 3
    intc_1 // 1
    +
    frame_bury 5
    b wideRatio_for_header@1

wideRatio_after_for@4:
    // contracts/utils.algo.ts:10
    // let denominator = new Uint128(1n)
    bytec 22 // 0x00000000000000000000000000000001
    frame_bury 0
    // contracts/utils.algo.ts:11
    // for (const factor of denominatorFactors) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 1
    intc_0 // 0
    frame_bury 2

wideRatio_for_header@5:
    // contracts/utils.algo.ts:11
    // for (const factor of denominatorFactors) {
    frame_dig 2
    frame_dig 1
    <
    bz wideRatio_after_for@8
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 2
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/utils.algo.ts:12
    // denominator = new Uint128(BigUint(factor) * denominator.asBigUint())
    frame_dig 0
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 2
    b wideRatio_for_header@5

wideRatio_after_for@8:
    // contracts/utils.algo.ts:15
    // const ratio: biguint = numerator.asBigUint() / denominator.asBigUint()
    frame_dig 3
    frame_dig 0
    b/
    // contracts/utils.algo.ts:16
    // return new Uint64(ratio).asUint64()
    dup
    len
    pushint 8 // 8
    <=
    assert // overflow
    pushint 8 // 8
    bzero
    b|
    btoi
    frame_dig -2
    frame_dig -1
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub


// contracts/stakingPool.algo.ts::StakingPool.createApplication[routing]() -> void:
createApplication:
    // contracts/stakingPool.algo.ts:121-126
    // createApplication(
    //     creatingContractId: Application,
    //     validatorId: uint64,
    //     poolId: uint64,
    //     minEntryStake: uint64,
    // ): void {
    txna ApplicationArgs 1
    btoi
    dup
    txna ApplicationArgs 2
    btoi
    swap
    txna ApplicationArgs 3
    btoi
    swap
    txna ApplicationArgs 4
    btoi
    swap
    // contracts/stakingPool.algo.ts:127
    // if (creatingContractId === Application(0)) {
    bnz createApplication_else_body@3
    // contracts/stakingPool.algo.ts:129
    // assert(validatorId === 0)
    dig 2
    !
    assert
    // contracts/stakingPool.algo.ts:130
    // assert(poolId === 0)
    dig 1
    !
    assert

createApplication_after_if_else@4:
    // contracts/stakingPool.algo.ts:135
    // assert(minEntryStake >= MIN_ALGO_STAKE_PER_POOL, 'staking pool must have minimum entry of 1 algo')
    dupn 2
    intc 8 // 1000000
    >=
    assert // staking pool must have minimum entry of 1 algo
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:136
    // this.creatingValidatorContractAppId.value = creatingContractId
    dig 5
    app_global_put
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:137
    // this.validatorId.value = validatorId
    dig 4
    app_global_put
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:138
    // this.poolId.value = poolId
    dig 3
    app_global_put
    // contracts/stakingPool.algo.ts:75
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:139
    // this.numStakers.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:140
    // this.totalAlgoStaked.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:80
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:141
    // this.minEntryStake.value = minEntryStake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:83
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:142
    // this.lastPayout.value = Global.round // set to init block to establish baseline
    global Round
    app_global_put
    // contracts/stakingPool.algo.ts:86
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:143
    // this.epochNumber.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:145
    // this.setRoundsPerDay()
    callsub setRoundsPerDay
    // contracts/stakingPool.algo.ts:146
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    global Round
    dup
    intc_0 // 0
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:146
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    app_global_get_ex
    assert // check GlobalState exists
    %
    -
    // contracts/stakingPool.algo.ts:98
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:146
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:147
    // this.stakeAccumulator.value = new Uint128(0)
    bytec 23 // 0x00000000000000000000000000000000
    app_global_put
    // contracts/stakingPool.algo.ts:107
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:148
    // this.rewardAccumulator.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:110
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:149
    // this.weightedMovingAverage.value = new Uint128(0)
    bytec 23 // 0x00000000000000000000000000000000
    app_global_put
    // contracts/stakingPool.algo.ts:121-126
    // createApplication(
    //     creatingContractId: Application,
    //     validatorId: uint64,
    //     poolId: uint64,
    //     minEntryStake: uint64,
    // ): void {
    intc_1 // 1
    return

createApplication_else_body@3:
    // contracts/stakingPool.algo.ts:132
    // assert(validatorId !== 0)
    dig 2
    assert
    // contracts/stakingPool.algo.ts:133
    // assert(poolId !== 0)
    dig 1
    assert
    b createApplication_after_if_else@4


// contracts/stakingPool.algo.ts::StakingPool.initStorage[routing]() -> void:
initStorage:
    // contracts/stakingPool.algo.ts:171
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:172
    // assert(!this.stakers.exists, 'staking pool already initialized')
    box_len
    bury 1
    !
    assert // staking pool already initialized
    // contracts/stakingPool.algo.ts:175-178
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:176
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:176
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:177
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:177
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:175-178
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc 5 // 157
    // contracts/stakingPool.algo.ts:180
    // const isTokenEligible = validatorConfig.rewardTokenId !== 0
    extract_uint64
    dup
    // contracts/stakingPool.algo.ts:181
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    bz initStorage_bool_false@5
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:181
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz initStorage_bool_false@5
    intc_1 // 1

initStorage_bool_merge@6:
    // contracts/stakingPool.algo.ts:181
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    pushint 100000 // 100000
    *
    // contracts/stakingPool.algo.ts:183-185
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // extraMBR +
    // this.costForBoxStorage(7 /* 'stakers' name */ + sizeOf<StakedInfo>() * MAX_STAKERS_PER_POOL)
    pushint 5225300 // 5225300
    +
    // contracts/stakingPool.algo.ts:188
    // assertMatch(mbrPayment, { receiver: Global.currentApplicationAddress, amount: PoolInitMbr })
    dig 2
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    swap
    gtxns Amount
    uncover 2
    ==
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:189
    // this.stakers.create()
    pushint 12800 // 12800
    box_create
    pop
    // contracts/stakingPool.algo.ts:191
    // if (isTokenEligible && this.poolId.value === 1) {
    dup
    bz initStorage_after_if_else@10
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:191
    // if (isTokenEligible && this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz initStorage_after_if_else@10
    // contracts/stakingPool.algo.ts:193-197
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:195
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/stakingPool.algo.ts:196
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dup
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:193-197
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

initStorage_after_if_else@10:
    // contracts/stakingPool.algo.ts:171
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    intc_1 // 1
    return

initStorage_bool_false@5:
    intc_0 // 0
    b initStorage_bool_merge@6


// contracts/stakingPool.algo.ts::StakingPool.addStake[routing]() -> void:
addStake:
    intc_0 // 0
    dup
    pushbytes ""
    // contracts/stakingPool.algo.ts:211
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Account): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    cover 2
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:212
    // assert(this.stakers.exists, 'staking pool must be initialized first')
    box_len
    bury 1
    assert // staking pool must be initialized first
    // contracts/stakingPool.algo.ts:216
    // Txn.sender === this.creatingValidatorContractAppId.value.address,
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:216
    // Txn.sender === this.creatingValidatorContractAppId.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/stakingPool.algo.ts:215-218
    // assert(
    //     Txn.sender === this.creatingValidatorContractAppId.value.address,
    //     'stake can only be added via the validator contract',
    // )
    assert // stake can only be added via the validator contract
    // contracts/stakingPool.algo.ts:219
    // assert(staker !== Global.zeroAddress)
    global ZeroAddress
    !=
    assert
    // contracts/stakingPool.algo.ts:222
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:226-230
    // assertMatch(stakedAmountPayment, {
    //     sender: this.creatingValidatorContractAppId.value.address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    dup
    gtxns Sender
    // contracts/stakingPool.algo.ts:227
    // sender: this.creatingValidatorContractAppId.value.address,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:227
    // sender: this.creatingValidatorContractAppId.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // contracts/stakingPool.algo.ts:226-230
    // assertMatch(stakedAmountPayment, {
    //     sender: this.creatingValidatorContractAppId.value.address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    ==
    dig 1
    gtxns Receiver
    // contracts/stakingPool.algo.ts:228
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/stakingPool.algo.ts:226-230
    // assertMatch(stakedAmountPayment, {
    //     sender: this.creatingValidatorContractAppId.value.address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    ==
    &&
    swap
    gtxns Amount
    dup
    uncover 2
    intc_1 // 1
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:235
    // const entryRound: uint64 = Global.round + ALGORAND_STAKING_BLOCK_DELAY
    global Round
    pushint 320 // 320
    +
    swap
    // contracts/stakingPool.algo.ts:236
    // let firstEmpty: uint64 = 0
    intc_0 // 0
    swap
    // contracts/stakingPool.algo.ts:238
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    intc_0 // 0
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:238
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    +
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:238
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:240
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:98
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:240
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:240
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:242
    // this.stakeAccumulator.value.asBigUint() + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:242
    // this.stakeAccumulator.value.asBigUint() + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    itob
    dup
    cover 3
    uncover 2
    itob
    b*
    b+
    // contracts/stakingPool.algo.ts:241-243
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.asBigUint() + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:241-243
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.asBigUint() + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:246
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

addStake_while_top@2:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:246
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dup
    intc 4 // 200
    <
    bz addStake_after_while@9
    // contracts/stakingPool.algo.ts:247
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:248
    // const cmpStaker = clone(this.stakers.value[i])
    dup
    intc_2 // 64
    *
    dup
    bury 8
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:248
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 9
    // contracts/stakingPool.algo.ts:248-249
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    dup
    bury 10
    // contracts/stakingPool.algo.ts:249
    // if (cmpStaker.account === staker) {
    dig 6
    ==
    bz addStake_after_if_else@5
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:251
    // cmpStaker.balance += stakedAmountPayment.amount
    dig 7
    dup
    cover 2
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    dig 6
    +
    itob
    dig 9
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:252
    // cmpStaker.entryRound = entryRound
    dig 5
    itob
    replace2 56
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:255
    // this.stakers.value[i] = clone(cmpStaker)
    cover 2
    box_replace

addStake_after_inlined_contracts/stakingPool.algo.ts::StakingPool.addStake@12:
    // contracts/stakingPool.algo.ts:211
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Account): uint64 {
    dig 3
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

addStake_after_if_else@5:
    // contracts/stakingPool.algo.ts:259
    // if (firstEmpty === 0 && cmpStaker.account === Global.zeroAddress) {
    dig 2
    bnz addStake_after_if_else@8
    dig 8
    global ZeroAddress
    ==
    bz addStake_after_if_else@8
    // contracts/stakingPool.algo.ts:260
    // firstEmpty = i + 1
    dup
    intc_1 // 1
    +
    bury 3

addStake_after_if_else@8:
    // contracts/stakingPool.algo.ts:246
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b addStake_while_top@2

addStake_after_while@9:
    // contracts/stakingPool.algo.ts:264
    // if (firstEmpty === 0) {
    dig 2
    dup
    !
    !
    assert // Staking pool full
    // contracts/stakingPool.algo.ts:271
    // assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:271
    // assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    <=
    assert // must stake at least the minimum for this pool
    // contracts/stakingPool.algo.ts:273
    // assert(this.stakers.value[firstEmpty - 1].account === Global.zeroAddress)
    intc_1 // 1
    -
    intc_2 // 64
    *
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:273
    // assert(this.stakers.value[firstEmpty - 1].account === Global.zeroAddress)
    dig 1
    intc_2 // 64
    box_extract
    extract 0 32
    global ZeroAddress
    ==
    assert
    // contracts/stakingPool.algo.ts:274-280
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    dig 6
    dig 3
    concat
    // contracts/stakingPool.algo.ts:277
    // totalRewarded: 0,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:274-280
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    dig 5
    itob
    concat
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:274-280
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    cover 2
    box_replace
    // contracts/stakingPool.algo.ts:281
    // this.numStakers.value += 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:75
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:281
    // this.numStakers.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // contracts/stakingPool.algo.ts:75
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:281
    // this.numStakers.value += 1
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:211
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Account): uint64 {
    b addStake_after_inlined_contracts/stakingPool.algo.ts::StakingPool.addStake@12


// contracts/stakingPool.algo.ts::StakingPool.removeStake[routing]() -> void:
removeStake:
    intc_0 // 0
    pushbytes ""
    dupn 5
    // contracts/stakingPool.algo.ts:296
    // removeStake(staker: Account, amountToUnstake: uint64): void {
    txna ApplicationArgs 1
    dup
    txna ApplicationArgs 2
    btoi
    swap
    // contracts/stakingPool.algo.ts:299
    // if (staker !== Txn.sender) {
    txn Sender
    !=
    bz removeStake_after_if_else@3
    // contracts/stakingPool.algo.ts:301
    // this.isOwnerOrManagerCaller(),
    callsub isOwnerOrManagerCaller
    // contracts/stakingPool.algo.ts:300-303
    // assert(
    //     this.isOwnerOrManagerCaller(),
    //     'If staker is not sender in removeStake call, then sender MUST be owner or manager of validator',
    // )
    assert // If staker is not sender in removeStake call, then sender MUST be owner or manager of validator

removeStake_after_if_else@3:
    // contracts/stakingPool.algo.ts:306
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:308
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    bury 5

removeStake_while_top@4:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:308
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dig 4
    dup
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:309
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:310
    // const cmpStaker = clone(this.stakers.value[i])
    intc_2 // 64
    *
    dup
    bury 7
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:310
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 10
    // contracts/stakingPool.algo.ts:310-311
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    // contracts/stakingPool.algo.ts:311
    // if (cmpStaker.account === staker) {
    dig 2
    ==
    bz removeStake_after_if_else@26
    // contracts/stakingPool.algo.ts:312
    // if (amountToUnstake === 0) {
    dup
    bnz removeStake_after_if_else@8
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:314
    // amountToUnstake = cmpStaker.balance
    dig 6
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    bury 1

removeStake_after_if_else@8:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:316
    // if (cmpStaker.balance < amountToUnstake) {
    dig 6
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    dup
    dig 2
    dup
    cover 3
    <
    !
    assert // Insufficient balance
    // contracts/stakingPool.algo.ts:319
    // cmpStaker.balance -= amountToUnstake
    dig 1
    -
    itob
    dig 10
    swap
    replace2 32
    dup
    bury 11
    // contracts/stakingPool.algo.ts:320
    // this.totalAlgoStaked.value -= amountToUnstake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:320
    // this.totalAlgoStaked.value -= amountToUnstake
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    -
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:320
    // this.totalAlgoStaked.value -= amountToUnstake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:322
    // let amountRewardTokenRemoved: uint64 = 0
    intc_0 // 0
    bury 9
    // contracts/stakingPool.algo.ts:323
    // if (cmpStaker.rewardTokenBalance > 0) {
    pushint 48 // 48
    extract_uint64
    dup
    bury 8
    bz removeStake_after_if_else@17
    // contracts/stakingPool.algo.ts:325
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:325
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz removeStake_else_body@15
    // contracts/stakingPool.algo.ts:326-329
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:327
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:327
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:328
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:328
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:326-329
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:334-338
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    itxn_begin
    intc 5 // 157
    // contracts/stakingPool.algo.ts:335
    // xferAsset: validatorConfig.rewardTokenId,
    extract_uint64
    dig 7
    itxn_field AssetAmount
    dig 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:334-338
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:340
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    dig 9
    swap
    replace2 48
    bury 9

removeStake_after_if_else@16:
    dig 6
    bury 8

removeStake_after_if_else@17:
    // contracts/stakingPool.algo.ts:352
    // cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    dig 8
    pushint 32 // 32
    extract_uint64
    dup
    bury 4
    bz removeStake_bool_true@19
    intc_0 // 0
    // contracts/stakingPool.algo.ts:80
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:352
    // cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    app_global_get_ex
    assert // check GlobalState exists
    dig 3
    <=
    bz removeStake_bool_false@20

removeStake_bool_true@19:
    intc_1 // 1

removeStake_bool_merge@21:
    // contracts/stakingPool.algo.ts:351-354
    // assert(
    //     cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    //     'cannot reduce balance below minimum allowed stake unless all is removed',
    // )
    assert // cannot reduce balance below minimum allowed stake unless all is removed
    // contracts/stakingPool.algo.ts:359-363
    // itxn.payment({
    //     amount: amountToUnstake,
    //     receiver: staker,
    //     note: 'unstaked',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:362
    // note: 'unstaked',
    pushbytes "unstaked"
    itxn_field Note
    dig 1
    itxn_field Receiver
    dup
    itxn_field Amount
    // contracts/stakingPool.algo.ts:359-363
    // itxn.payment({
    //     amount: amountToUnstake,
    //     receiver: staker,
    //     note: 'unstaked',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:364
    // let stakerRemoved = false
    intc_0 // 0
    bury 4
    // contracts/stakingPool.algo.ts:365
    // if (cmpStaker.balance === 0) {
    dig 2
    bnz removeStake_after_if_else@24
    // contracts/stakingPool.algo.ts:367
    // this.numStakers.value -= 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:75
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:367
    // this.numStakers.value -= 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    -
    // contracts/stakingPool.algo.ts:75
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:367
    // this.numStakers.value -= 1
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:368
    // cmpStaker.account = Global.zeroAddress
    dig 8
    global ZeroAddress
    replace2 0
    // contracts/stakingPool.algo.ts:369
    // cmpStaker.totalRewarded = 0
    intc_0 // 0
    itob
    swap
    dig 1
    replace2 40
    // contracts/stakingPool.algo.ts:370
    // cmpStaker.rewardTokenBalance = 0
    swap
    replace2 48
    bury 9
    // contracts/stakingPool.algo.ts:371
    // stakerRemoved = true
    intc_1 // 1
    bury 4

removeStake_after_if_else@24:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:374
    // this.stakers.value[i] = clone(cmpStaker)
    dig 6
    dig 10
    box_replace
    // contracts/stakingPool.algo.ts:376
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:98
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:376
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:376
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:377
    // const subtractAmount = BigUint(amountToUnstake * roundsLeftInBin)
    dig 1
    dup
    uncover 2
    *
    itob
    // contracts/stakingPool.algo.ts:378
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.asBigUint() - subtractAmount)
    intc_0 // 0
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:378
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.asBigUint() - subtractAmount)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    b-
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:378
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.asBigUint() - subtractAmount)
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:383-396
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         amountToUnstake,
    //         amountRewardTokenRemoved,
    //         stakerRemoved,
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:384
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:384
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:387
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:387
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:388
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:388
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:389
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:386-390
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:392
    // amountToUnstake,
    uncover 2
    itob
    // contracts/stakingPool.algo.ts:393
    // amountRewardTokenRemoved,
    dig 10
    itob
    // contracts/stakingPool.algo.ts:394
    // stakerRemoved,
    pushbytes 0x00
    intc_0 // 0
    dig 9
    setbit
    // contracts/stakingPool.algo.ts:383-396
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         amountToUnstake,
    //         amountRewardTokenRemoved,
    //         stakerRemoved,
    //     ],
    // })
    bytec 24 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:296
    // removeStake(staker: Account, amountToUnstake: uint64): void {
    intc_1 // 1
    return

removeStake_bool_false@20:
    intc_0 // 0
    b removeStake_bool_merge@21

removeStake_else_body@15:
    // contracts/stakingPool.algo.ts:346
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    dig 9
    swap
    replace2 48
    bury 9
    b removeStake_after_if_else@16

removeStake_after_if_else@26:
    // contracts/stakingPool.algo.ts:308
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dig 4
    intc_1 // 1
    +
    bury 5
    b removeStake_while_top@4


// contracts/stakingPool.algo.ts::StakingPool.claimTokens[routing]() -> void:
claimTokens:
    intc_0 // 0
    dup
    pushbytes ""
    dup
    // contracts/stakingPool.algo.ts:412
    // const staker = Txn.sender
    txn Sender
    // contracts/stakingPool.algo.ts:414
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

claimTokens_while_top@2:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:414
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dupn 2
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:415
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:416
    // const cmpStaker = clone(this.stakers.value[i])
    intc_2 // 64
    *
    dup
    bury 4
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:416
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 6
    // contracts/stakingPool.algo.ts:416-417
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    // contracts/stakingPool.algo.ts:417
    // if (cmpStaker.account === staker) {
    dig 2
    ==
    bz claimTokens_after_if_else@13
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:418
    // if (cmpStaker.rewardTokenBalance === 0) {
    dig 3
    intc_2 // 64
    box_extract
    dup
    extract 48 8
    bury 7
    pushint 48 // 48
    extract_uint64
    dup
    bury 5
    bz claimTokens_after_inlined_contracts/stakingPool.algo.ts::StakingPool.claimTokens@15
    // contracts/stakingPool.algo.ts:423
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:423
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz claimTokens_else_body@10
    // contracts/stakingPool.algo.ts:424-427
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:425
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:425
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:426
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:426
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:424-427
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:431-435
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    itxn_begin
    intc 5 // 157
    // contracts/stakingPool.algo.ts:432
    // xferAsset: validatorConfig.rewardTokenId,
    extract_uint64
    dig 4
    itxn_field AssetAmount
    dig 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:431-435
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:437
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    dig 5
    swap
    replace2 48
    bury 5

claimTokens_after_if_else@11:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:447
    // this.stakers.value[i] = clone(cmpStaker)
    dig 3
    dig 6
    box_replace
    // contracts/stakingPool.algo.ts:452-465
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:453
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:453
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:456
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:456
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:457
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:457
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:458
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:455-459
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:461
    // 0, // no algo removed
    intc_0 // 0
    itob
    // contracts/stakingPool.algo.ts:452-465
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    bytec 24 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    // contracts/stakingPool.algo.ts:463
    // false, // staker isn't being removed.
    pushbytes 0x00
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // contracts/stakingPool.algo.ts:452-465
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

claimTokens_after_inlined_contracts/stakingPool.algo.ts::StakingPool.claimTokens@15:
    // contracts/stakingPool.algo.ts:408
    // claimTokens(): void {
    intc_1 // 1
    return

claimTokens_else_body@10:
    // contracts/stakingPool.algo.ts:443
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    dig 5
    swap
    replace2 48
    bury 5
    b claimTokens_after_if_else@11

claimTokens_after_if_else@13:
    // contracts/stakingPool.algo.ts:414
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b claimTokens_while_top@2


// contracts/stakingPool.algo.ts::StakingPool.getStakerInfo[routing]() -> void:
getStakerInfo:
    pushbytes ""
    // contracts/stakingPool.algo.ts:479-480
    // @readonly
    // getStakerInfo(staker: Account): StakedInfo {
    txna ApplicationArgs 1
    // contracts/stakingPool.algo.ts:481
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

getStakerInfo_while_top@2:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:481
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dupn 2
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:482
    // ensureBudget(200)
    intc 4 // 200
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:483
    // if (this.stakers.value[i].account === staker) {
    intc_2 // 64
    *
    dup
    bury 4
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:483
    // if (this.stakers.value[i].account === staker) {
    swap
    intc_2 // 64
    box_extract
    extract 0 32
    dig 2
    ==
    bz getStakerInfo_after_if_else@5
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:484
    // return this.stakers.value[i]
    dig 3
    intc_2 // 64
    box_extract
    // contracts/stakingPool.algo.ts:479-480
    // @readonly
    // getStakerInfo(staker: Account): StakedInfo {
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getStakerInfo_after_if_else@5:
    // contracts/stakingPool.algo.ts:481
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b getStakerInfo_while_top@2


// contracts/stakingPool.algo.ts::StakingPool.payTokenReward[routing]() -> void:
payTokenReward:
    // contracts/stakingPool.algo.ts:500
    // payTokenReward(staker: Account, rewardToken: uint64, amountToSend: uint64): void {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // contracts/stakingPool.algo.ts:503
    // Txn.sender === this.creatingValidatorContractAppId.value.address,
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:503
    // Txn.sender === this.creatingValidatorContractAppId.value.address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/stakingPool.algo.ts:502-505
    // assert(
    //     Txn.sender === this.creatingValidatorContractAppId.value.address,
    //     'this can only be called via the validator contract',
    // )
    assert // this can only be called via the validator contract
    // contracts/stakingPool.algo.ts:506
    // assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:506
    // assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // must be pool 1 in order to be called to pay out token rewards
    // contracts/stakingPool.algo.ts:507
    // assert(rewardToken !== 0, 'can only claim token rewards from validator that has them')
    dig 1
    assert // can only claim token rewards from validator that has them
    // contracts/stakingPool.algo.ts:510-514
    // itxn.assetTransfer({
    //     xferAsset: rewardToken,
    //     assetReceiver: staker,
    //     assetAmount: amountToSend,
    // }).submit()
    itxn_begin
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:500
    // payTokenReward(staker: Account, rewardToken: uint64, amountToSend: uint64): void {
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.updateAlgodVer[routing]() -> void:
updateAlgodVer:
    // contracts/stakingPool.algo.ts:526
    // updateAlgodVer(algodVer: string): void {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/stakingPool.algo.ts:527
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:89
    // algodVer = GlobalState<bytes>({ key: 'algodVer' })
    pushbytes "algodVer"
    // contracts/stakingPool.algo.ts:528
    // this.algodVer.value = Bytes(algodVer)
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:526
    // updateAlgodVer(algodVer: string): void {
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.epochBalanceUpdate[routing]() -> void:
epochBalanceUpdate:
    intc_0 // 0
    dupn 4
    pushbytes ""
    dupn 28
    intc_0 // 0
    // contracts/stakingPool.algo.ts:541-544
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:542
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:542
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:543
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:543
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:541-544
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:550
    // const epochRoundLength = validatorConfig.epochRoundLength.asUint64()
    dup
    pushint 173 // 173
    extract_uint32
    dup
    cover 2
    // contracts/stakingPool.algo.ts:551
    // const curRound = Global.round
    global Round
    // contracts/stakingPool.algo.ts:552
    // const thisEpochBegin: uint64 = curRound - (curRound % epochRoundLength)
    dup
    dig 2
    %
    dig 1
    swap
    -
    dup
    cover 2
    cover 4
    // contracts/stakingPool.algo.ts:555
    // const lastPayoutEpoch: uint64 = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
    intc_0 // 0
    // contracts/stakingPool.algo.ts:83
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:555
    // const lastPayoutEpoch: uint64 = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
    app_global_get_ex
    assert // check GlobalState exists
    dup
    uncover 4
    %
    -
    // contracts/stakingPool.algo.ts:557
    // assert(lastPayoutEpoch !== thisEpochBegin, "can't call epochBalanceUpdate in same epoch as prior call")
    uncover 2
    !=
    assert // can't call epochBalanceUpdate in same epoch as prior call
    // contracts/stakingPool.algo.ts:559
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:83
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:562
    // this.lastPayout.value = curRound
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:563
    // this.epochNumber.value += 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:86
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:563
    // this.epochNumber.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // contracts/stakingPool.algo.ts:86
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:563
    // this.epochNumber.value += 1
    swap
    app_global_put
    intc 5 // 157
    // contracts/stakingPool.algo.ts:568
    // const isTokenEligible = validatorConfig.rewardTokenId !== 0
    extract_uint64
    dup
    // contracts/stakingPool.algo.ts:569
    // let poolOneAppID = Global.currentApplicationId.id
    global CurrentApplicationID
    swap
    // contracts/stakingPool.algo.ts:570
    // let poolOneAddress = Global.currentApplicationAddress
    global CurrentApplicationAddress
    swap
    // contracts/stakingPool.algo.ts:575
    // if (isTokenEligible) {
    bz epochBalanceUpdate_after_if_else@12
    // contracts/stakingPool.algo.ts:576
    // if (this.poolId.value !== 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:576
    // if (this.poolId.value !== 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    !=
    bz epochBalanceUpdate_after_if_else@6
    // contracts/stakingPool.algo.ts:578-581
    // poolOneAppID = abiCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value, 1],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:579
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:579
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:580
    // args: [this.validatorId.value, 1],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:580
    // args: [this.validatorId.value, 1],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    intc_1 // 1
    itob
    // contracts/stakingPool.algo.ts:578-581
    // poolOneAppID = abiCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value, 1],
    // }).returnValue
    bytec 25 // method "getPoolAppId(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    dup
    bury 3
    // contracts/stakingPool.algo.ts:583
    // poolOneAddress = Application(poolOneAppID).address
    app_params_get AppAddress
    swap
    bury 2
    assert // application exists

epochBalanceUpdate_after_if_else@6:
    // contracts/stakingPool.algo.ts:588
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:588
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz epochBalanceUpdate_else_body@9
    // contracts/stakingPool.algo.ts:589-592
    // tokenPayoutRatio = abiCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:590
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:590
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:591
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:591
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:589-592
    // tokenPayoutRatio = abiCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 26 // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    bury 8
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix

epochBalanceUpdate_after_if_else@12:
    // contracts/stakingPool.algo.ts:610-613
    // const validatorState = abiCall<typeof ValidatorRegistry.prototype.getValidatorState>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:611
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:611
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:612
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:612
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:610-613
    // const validatorState = abiCall<typeof ValidatorRegistry.prototype.getValidatorState>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:614
    // const rewardTokenHeldBack = validatorState.rewardTokenHeldBack
    dup
    pushint 22 // 22
    extract_uint64
    bury 22
    // contracts/stakingPool.algo.ts:621
    // Global.currentApplicationAddress.balance -
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // contracts/stakingPool.algo.ts:622
    // this.totalAlgoStaked.value -
    intc_0 // 0
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:622
    // this.totalAlgoStaked.value -
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:621-622
    // Global.currentApplicationAddress.balance -
    // this.totalAlgoStaked.value -
    -
    // contracts/stakingPool.algo.ts:623
    // Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contracts/stakingPool.algo.ts:621-623
    // Global.currentApplicationAddress.balance -
    // this.totalAlgoStaked.value -
    // Global.currentApplicationAddress.minBalance
    -
    bury 37
    // contracts/stakingPool.algo.ts:624
    // let isPoolSaturated = false
    intc_0 // 0
    bury 27
    // contracts/stakingPool.algo.ts:1025
    // return op.onlineStake()
    online_stake
    // contracts/stakingPool.algo.ts:1012
    // return wideRatio([online, MAX_VALIDATOR_SOFT_PCT_OF_ONLINE_1DECIMAL], [1000])
    itob
    bytec 8 // 0x0002
    swap
    concat
    pushint 100 // 100
    itob
    concat
    pushint 1000 // 1000
    itob
    bury 41
    pushbytes 0x000100000000000003e8
    callsub wideRatio
    popn 2
    dup
    bury 36
    // contracts/stakingPool.algo.ts:633
    // if (validatorState.totalAlgoStaked > algoSaturationAmt) {
    swap
    pushint 14 // 14
    extract_uint64
    dup
    bury 12
    <
    bz epochBalanceUpdate_after_if_else@15
    // contracts/stakingPool.algo.ts:634
    // isPoolSaturated = true
    intc_1 // 1
    bury 26

epochBalanceUpdate_after_if_else@15:
    // contracts/stakingPool.algo.ts:640
    // let tokenRewardAvail: uint64 = 0
    intc_0 // 0
    bury 16
    // contracts/stakingPool.algo.ts:641
    // let tokenRewardPaidOut: uint64 = 0
    intc_0 // 0
    bury 14
    // contracts/stakingPool.algo.ts:642
    // let validatorCommissionPaidOut: uint64 = 0
    intc_0 // 0
    bury 13
    // contracts/stakingPool.algo.ts:643
    // let excessToFeeSink: uint64 = 0
    intc_0 // 0
    bury 29
    // contracts/stakingPool.algo.ts:644
    // if (isTokenEligible) {
    dig 2
    bz epochBalanceUpdate_after_if_else@19
    // contracts/stakingPool.algo.ts:646
    // op.AssetHolding.assetBalance(poolOneAddress, validatorConfig.rewardTokenId)[0] -
    dup
    dig 3
    asset_holding_get AssetBalance
    pop
    // contracts/stakingPool.algo.ts:646-647
    // op.AssetHolding.assetBalance(poolOneAddress, validatorConfig.rewardTokenId)[0] -
    // op.btoi(Bytes(rewardTokenHeldBack))
    dig 21
    -
    // contracts/stakingPool.algo.ts:651
    // if (tokenRewardBal >= validatorConfig.rewardPerPayout) {
    dig 6
    pushint 165 // 165
    extract_uint64
    dup
    bury 10
    >=
    bz epochBalanceUpdate_after_if_else@19
    // contracts/stakingPool.algo.ts:657
    // const ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:657
    // const ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    -
    dig 7
    extract 0 192
    swap
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/stakingPool.algo.ts:660
    // tokenRewardAvail = wideRatio([validatorConfig.rewardPerPayout, ourPoolPctOfWhole], [1_000_000])
    dig 8
    itob
    bytec 8 // 0x0002
    swap
    concat
    swap
    concat
    bytec 18 // 0x000100000000000f4240
    callsub wideRatio
    popn 2
    bury 16

epochBalanceUpdate_after_if_else@19:
    // contracts/stakingPool.algo.ts:663
    // if (tokenRewardAvail === 0) {
    dig 15
    bnz epochBalanceUpdate_after_if_else@23
    // contracts/stakingPool.algo.ts:668
    // if (algoRewardAvail < 1_000_000) {
    dig 35
    intc 8 // 1000000
    <
    bz epochBalanceUpdate_after_if_else@23
    // contracts/stakingPool.algo.ts:669
    // log('!token&&!noalgo to pay')
    pushbytes "!token&&!noalgo to pay"
    log

epochBalanceUpdate_after_inlined_contracts/stakingPool.algo.ts::StakingPool.epochBalanceUpdate@71:
    // contracts/stakingPool.algo.ts:539
    // epochBalanceUpdate(): void {
    intc_1 // 1
    return

epochBalanceUpdate_after_if_else@23:
    // contracts/stakingPool.algo.ts:674
    // if (isPoolSaturated) {
    dig 25
    bz epochBalanceUpdate_else_body@28
    // contracts/stakingPool.algo.ts:681
    // [algoRewardAvail, validatorConfig.percentToValidator.asUint64()],
    dig 5
    pushint 177 // 177
    extract_uint32
    dig 36
    dup
    cover 2
    itob
    bytec 8 // 0x0002
    swap
    concat
    swap
    itob
    dig 1
    swap
    concat
    // contracts/stakingPool.algo.ts:682
    // [1_000_000],
    bytec 18 // 0x000100000000000f4240
    // contracts/stakingPool.algo.ts:680-683
    // const normalValidatorCommission = wideRatio(
    //     [algoRewardAvail, validatorConfig.percentToValidator.asUint64()],
    //     [1_000_000],
    // )
    callsub wideRatio
    popn 2
    swap
    // contracts/stakingPool.algo.ts:686
    // [algoRewardAvail, algoSaturationAmt],
    dig 36
    itob
    concat
    // contracts/stakingPool.algo.ts:687
    // [op.btoi(Bytes(validatorState.totalAlgoStaked))],
    dig 12
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:685-688
    // let diminishedReward = wideRatio(
    //     [algoRewardAvail, algoSaturationAmt],
    //     [op.btoi(Bytes(validatorState.totalAlgoStaked))],
    // )
    callsub wideRatio
    popn 2
    dup
    bury 34
    // contracts/stakingPool.algo.ts:690
    // if (diminishedReward > algoRewardAvail - normalValidatorCommission) {
    cover 2
    -
    dup
    bury 32
    >
    bz epochBalanceUpdate_after_if_else@26
    dig 29
    bury 31

epochBalanceUpdate_after_if_else@26:
    // contracts/stakingPool.algo.ts:694
    // excessToFeeSink = algoRewardAvail - diminishedReward
    dig 35
    dig 31
    dup
    cover 2
    -
    dup
    bury 31
    // contracts/stakingPool.algo.ts:695-699
    // itxn.payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:697
    // receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    txn FirstValid
    intc_1 // 1
    -
    block BlkFeeSink
    // contracts/stakingPool.algo.ts:698
    // note: 'pool saturated, excess to fee sink',
    pushbytes "pool saturated, excess to fee sink"
    itxn_field Note
    itxn_field Receiver
    itxn_field Amount
    // contracts/stakingPool.algo.ts:695-699
    // itxn.payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    bury 36

epochBalanceUpdate_after_if_else@40:
    // contracts/stakingPool.algo.ts:749
    // let increasedStake: uint64 = 0
    intc_0 // 0
    bury 27
    // contracts/stakingPool.algo.ts:773
    // if (algoRewardAvail !== 0 || tokenRewardAvail !== 0) {
    dig 35
    bnz epochBalanceUpdate_if_body@42
    dig 15
    bz epochBalanceUpdate_after_if_else@69

epochBalanceUpdate_if_body@42:
    // contracts/stakingPool.algo.ts:774
    // let partialStakersTotalStake: uint64 = 0
    intc_0 // 0
    bury 22
    // contracts/stakingPool.algo.ts:778
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    bury 28
    dig 35
    bury 35
    dig 15
    bury 15

epochBalanceUpdate_while_top@43:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:778
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dig 27
    intc 4 // 200
    <
    bz epochBalanceUpdate_after_while@54
    // contracts/stakingPool.algo.ts:779
    // ensureBudget(400)
    pushint 400 // 400
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:780
    // const cmpStaker = clone(this.stakers.value[i])
    dig 27
    intc_2 // 64
    *
    dup
    bury 34
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:780
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 39
    // contracts/stakingPool.algo.ts:780-781
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account !== Global.zeroAddress) {
    extract 0 32
    // contracts/stakingPool.algo.ts:781
    // if (cmpStaker.account !== Global.zeroAddress) {
    global ZeroAddress
    !=
    bz epochBalanceUpdate_after_if_else@53
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:782
    // if (cmpStaker.entryRound >= thisEpochBegin) {
    dig 33
    intc_2 // 64
    box_extract
    pushint 56 // 56
    extract_uint64
    dup
    bury 13
    dig 4
    >=
    bz epochBalanceUpdate_else_body@47
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:785
    // partialStakersTotalStake += cmpStaker.balance
    dig 33
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    dig 22
    +
    bury 22

epochBalanceUpdate_after_if_else@53:
    // contracts/stakingPool.algo.ts:778
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dig 27
    intc_1 // 1
    +
    bury 28
    b epochBalanceUpdate_while_top@43

epochBalanceUpdate_else_body@47:
    // contracts/stakingPool.algo.ts:789
    // const timeInPool: uint64 = thisEpochBegin - cmpStaker.entryRound
    dig 3
    dig 12
    -
    dup
    bury 21
    // contracts/stakingPool.algo.ts:793
    // if (timeInPool < epochRoundLength) {
    dig 5
    <
    bz epochBalanceUpdate_after_if_else@53
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:794
    // partialStakersTotalStake += cmpStaker.balance
    dig 33
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    dup
    bury 12
    dig 22
    +
    bury 22
    // contracts/stakingPool.algo.ts:795
    // timePercentage = (timeInPool * 1000) / epochRoundLength
    dig 19
    pushint 1000 // 1000
    *
    dig 5
    /
    bury 19
    // contracts/stakingPool.algo.ts:797
    // if (tokenRewardAvail > 0) {
    dig 14
    bz epochBalanceUpdate_after_if_else@50
    // contracts/stakingPool.algo.ts:800
    // [cmpStaker.balance, origTokenReward, timePercentage],
    dig 10
    itob
    bytec 27 // 0x0003
    swap
    concat
    dig 16
    itob
    concat
    dig 19
    itob
    concat
    // contracts/stakingPool.algo.ts:801
    // [this.totalAlgoStaked.value, 1000],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:801
    // [this.totalAlgoStaked.value, 1000],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    bytec 8 // 0x0002
    swap
    concat
    dig 40
    concat
    // contracts/stakingPool.algo.ts:799-802
    // const stakerTokenReward = wideRatio(
    //     [cmpStaker.balance, origTokenReward, timePercentage],
    //     [this.totalAlgoStaked.value, 1000],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:806
    // tokenRewardAvail -= stakerTokenReward
    dig 15
    dig 1
    -
    bury 16
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:807
    // cmpStaker.rewardTokenBalance += stakerTokenReward
    dig 34
    intc_2 // 64
    box_extract
    pushint 48 // 48
    extract_uint64
    dig 1
    +
    itob
    dig 39
    swap
    replace2 48
    bury 39
    // contracts/stakingPool.algo.ts:808
    // tokenRewardPaidOut += stakerTokenReward
    dig 14
    +
    bury 14

epochBalanceUpdate_after_if_else@50:
    // contracts/stakingPool.algo.ts:812
    // [cmpStaker.balance, origAlgoReward, timePercentage],
    dig 37
    dup
    pushint 32 // 32
    extract_uint64
    dup
    itob
    bytec 27 // 0x0003
    swap
    concat
    dig 38
    itob
    concat
    dig 21
    itob
    concat
    // contracts/stakingPool.algo.ts:813
    // [this.totalAlgoStaked.value, 1000],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:813
    // [this.totalAlgoStaked.value, 1000],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    bytec 8 // 0x0002
    swap
    concat
    dig 42
    concat
    // contracts/stakingPool.algo.ts:811-814
    // const stakerReward = wideRatio(
    //     [cmpStaker.balance, origAlgoReward, timePercentage],
    //     [this.totalAlgoStaked.value, 1000],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:817
    // algoRewardAvail -= stakerReward
    dig 37
    dig 1
    -
    bury 38
    // contracts/stakingPool.algo.ts:820
    // cmpStaker.balance += stakerReward
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:821
    // cmpStaker.totalRewarded += stakerReward
    dup
    pushint 40 // 40
    extract_uint64
    dig 2
    +
    itob
    replace2 40
    // contracts/stakingPool.algo.ts:822
    // increasedStake += stakerReward
    dig 28
    uncover 2
    +
    bury 28
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:824
    // this.stakers.value[i] = clone(cmpStaker)
    dig 34
    uncover 2
    box_replace
    b epochBalanceUpdate_after_if_else@53

epochBalanceUpdate_after_while@54:
    // contracts/stakingPool.algo.ts:832
    // const newPoolTotalStake: uint64 = this.totalAlgoStaked.value - partialStakersTotalStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:832
    // const newPoolTotalStake: uint64 = this.totalAlgoStaked.value - partialStakersTotalStake
    app_global_get_ex
    assert // check GlobalState exists
    dig 22
    -
    dup
    bury 24
    // contracts/stakingPool.algo.ts:836
    // if (newPoolTotalStake > 0) {
    bz epochBalanceUpdate_after_if_else@69
    // contracts/stakingPool.algo.ts:838
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    bury 25

epochBalanceUpdate_while_top@56:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:838
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dig 24
    intc 4 // 200
    <
    bz epochBalanceUpdate_after_if_else@69
    // contracts/stakingPool.algo.ts:839
    // ensureBudget(200)
    intc 4 // 200
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:840
    // const cmpStaker = clone(this.stakers.value[i])
    dig 24
    intc_2 // 64
    *
    dup
    bury 33
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:840
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 38
    // contracts/stakingPool.algo.ts:840-841
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    extract 0 32
    // contracts/stakingPool.algo.ts:841
    // if (cmpStaker.account !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    global ZeroAddress
    !=
    bz epochBalanceUpdate_after_if_else@66
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:840-841
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    dig 32
    intc_2 // 64
    box_extract
    pushint 56 // 56
    // contracts/stakingPool.algo.ts:841
    // if (cmpStaker.account !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    extract_uint64
    dup
    bury 10
    dig 4
    <
    bz epochBalanceUpdate_after_if_else@66
    // contracts/stakingPool.algo.ts:842
    // const timeInPool: uint64 = thisEpochBegin - cmpStaker.entryRound
    dig 3
    dig 9
    -
    // contracts/stakingPool.algo.ts:844
    // if (timeInPool >= epochRoundLength) {
    dig 5
    >=
    bz epochBalanceUpdate_after_if_else@66
    // contracts/stakingPool.algo.ts:849
    // if (tokenRewardAvail > 0) {
    dig 14
    bz epochBalanceUpdate_after_if_else@62
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:851
    // [cmpStaker.balance, tokenRewardAvail],
    dig 32
    dup
    cover 2
    intc_2 // 64
    box_extract
    extract 32 8
    bytec 8 // 0x0002
    swap
    concat
    dig 16
    itob
    concat
    // contracts/stakingPool.algo.ts:852
    // [newPoolTotalStake],
    dig 24
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:850-853
    // const stakerTokenReward = wideRatio(
    //     [cmpStaker.balance, tokenRewardAvail],
    //     [newPoolTotalStake],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:855
    // cmpStaker.rewardTokenBalance += stakerTokenReward
    uncover 2
    intc_2 // 64
    box_extract
    pushint 48 // 48
    extract_uint64
    dig 1
    +
    itob
    dig 38
    swap
    replace2 48
    bury 38
    // contracts/stakingPool.algo.ts:856
    // tokenRewardPaidOut += stakerTokenReward
    dig 14
    +
    bury 14

epochBalanceUpdate_after_if_else@62:
    // contracts/stakingPool.algo.ts:858
    // if (algoRewardAvail > 0) {
    dig 34
    bz epochBalanceUpdate_after_if_else@64
    // contracts/stakingPool.algo.ts:860
    // [cmpStaker.balance, algoRewardAvail],
    dig 36
    dup
    pushint 32 // 32
    extract_uint64
    dup
    itob
    bytec 8 // 0x0002
    swap
    concat
    dig 37
    itob
    concat
    // contracts/stakingPool.algo.ts:861
    // [newPoolTotalStake],
    dig 25
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:859-862
    // const stakerReward = wideRatio(
    //     [cmpStaker.balance, algoRewardAvail],
    //     [newPoolTotalStake],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:865
    // cmpStaker.balance += stakerReward
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:866
    // cmpStaker.totalRewarded += stakerReward
    dup
    pushint 40 // 40
    extract_uint64
    dig 2
    +
    itob
    replace2 40
    bury 38
    // contracts/stakingPool.algo.ts:867
    // increasedStake += stakerReward
    dig 27
    +
    bury 27

epochBalanceUpdate_after_if_else@64:
    // contracts/stakingPool.algo.ts:92
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:871
    // this.stakers.value[i] = clone(cmpStaker)
    dig 32
    dig 38
    box_replace

epochBalanceUpdate_after_if_else@66:
    // contracts/stakingPool.algo.ts:838
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dig 24
    intc_1 // 1
    +
    bury 25
    b epochBalanceUpdate_while_top@56

epochBalanceUpdate_after_if_else@69:
    // contracts/stakingPool.algo.ts:881
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:98
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:881
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:881
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:882
    // this.totalAlgoStaked.value += increasedStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:882
    // this.totalAlgoStaked.value += increasedStake
    app_global_get_ex
    assert // check GlobalState exists
    dig 28
    dup
    cover 2
    +
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:882
    // this.totalAlgoStaked.value += increasedStake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:884
    // this.stakeAccumulator.value.asBigUint() + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:884
    // this.stakeAccumulator.value.asBigUint() + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    itob
    uncover 3
    itob
    dig 1
    b*
    uncover 2
    b+
    // contracts/stakingPool.algo.ts:883-885
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.asBigUint() + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:883-885
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.asBigUint() + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:886
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:107
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:886
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    // contracts/stakingPool.algo.ts:107
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:886
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:892-901
    // abiCall<typeof ValidatorRegistry.prototype.stakeUpdatedViaRewards>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //         increasedStake,
    //         tokenRewardPaidOut,
    //         validatorCommissionPaidOut,
    //         excessToFeeSink,
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:893
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:893
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:895
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:895
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:895
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationID
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:897
    // tokenRewardPaidOut,
    dig 16
    itob
    // contracts/stakingPool.algo.ts:898
    // validatorCommissionPaidOut,
    dig 16
    itob
    // contracts/stakingPool.algo.ts:899
    // excessToFeeSink,
    dig 33
    itob
    // contracts/stakingPool.algo.ts:892-901
    // abiCall<typeof ValidatorRegistry.prototype.stakeUpdatedViaRewards>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //         increasedStake,
    //         tokenRewardPaidOut,
    //         validatorCommissionPaidOut,
    //         excessToFeeSink,
    //     ],
    // })
    pushbytes 0x418fcefc // method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:539
    // epochBalanceUpdate(): void {
    b epochBalanceUpdate_after_inlined_contracts/stakingPool.algo.ts::StakingPool.epochBalanceUpdate@71

epochBalanceUpdate_else_body@28:
    // contracts/stakingPool.algo.ts:702
    // } else if (validatorConfig.percentToValidator.asUint64() !== 0) {
    dig 5
    pushint 177 // 177
    extract_uint32
    dup
    bury 19
    bz epochBalanceUpdate_after_if_else@40
    // contracts/stakingPool.algo.ts:706
    // [algoRewardAvail, validatorConfig.percentToValidator.asUint64()],
    dig 35
    dup
    itob
    bytec 8 // 0x0002
    swap
    concat
    dig 19
    itob
    concat
    // contracts/stakingPool.algo.ts:707
    // [1_000_000],
    bytec 18 // 0x000100000000000f4240
    // contracts/stakingPool.algo.ts:705-708
    // validatorCommissionPaidOut = wideRatio(
    //     [algoRewardAvail, validatorConfig.percentToValidator.asUint64()],
    //     [1_000_000],
    // )
    callsub wideRatio
    popn 2
    dup
    bury 15
    // contracts/stakingPool.algo.ts:711
    // algoRewardAvail -= validatorCommissionPaidOut
    swap
    dig 1
    -
    bury 37
    // contracts/stakingPool.algo.ts:718
    // if (validatorCommissionPaidOut > 0) {
    bz epochBalanceUpdate_after_if_else@40
    // contracts/stakingPool.algo.ts:721
    // let managerTopOff: uint64 = 0
    intc_0 // 0
    bury 24
    // contracts/stakingPool.algo.ts:723
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    dig 5
    dup
    extract 44 32
    dup
    cover 2
    bury 43
    extract 181 32
    dup
    bury 42
    !=
    // contracts/stakingPool.algo.ts:723-724
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    // validatorConfig.manager.balance - validatorConfig.manager.minBalance < 2_100_000
    bz epochBalanceUpdate_after_if_else@34
    // contracts/stakingPool.algo.ts:724
    // validatorConfig.manager.balance - validatorConfig.manager.minBalance < 2_100_000
    dig 40
    dup
    acct_params_get AcctBalance
    assert // account funded
    swap
    acct_params_get AcctMinBalance
    assert // account funded
    -
    intc 7 // 2100000
    <
    // contracts/stakingPool.algo.ts:723-724
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    // validatorConfig.manager.balance - validatorConfig.manager.minBalance < 2_100_000
    bz epochBalanceUpdate_after_if_else@34
    // contracts/stakingPool.algo.ts:726
    // managerTopOff = validatorCommissionPaidOut < 2_100_000 ? validatorCommissionPaidOut : 2_100_000
    dig 12
    dup
    intc 7 // 2100000
    <
    intc 7 // 2100000
    cover 2
    select
    dup
    bury 25
    // contracts/stakingPool.algo.ts:727-731
    // itxn.payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager,
    //     note: 'validator reward to manager for funding epoch updates',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:730
    // note: 'validator reward to manager for funding epoch updates',
    pushbytes "validator reward to manager for funding epoch updates"
    itxn_field Note
    dig 41
    itxn_field Receiver
    itxn_field Amount
    // contracts/stakingPool.algo.ts:727-731
    // itxn.payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager,
    //     note: 'validator reward to manager for funding epoch updates',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

epochBalanceUpdate_after_if_else@34:
    // contracts/stakingPool.algo.ts:733
    // if (validatorCommissionPaidOut - managerTopOff > 0) {
    dig 12
    dig 24
    -
    dup
    bury 18
    bz epochBalanceUpdate_after_if_else@40
    // contracts/stakingPool.algo.ts:734-738
    // itxn.payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress,
    //     note: 'validator reward',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:737
    // note: 'validator reward',
    pushbytes "validator reward"
    itxn_field Note
    dig 39
    itxn_field Receiver
    dig 16
    itxn_field Amount
    // contracts/stakingPool.algo.ts:734-738
    // itxn.payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress,
    //     note: 'validator reward',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b epochBalanceUpdate_after_if_else@40

epochBalanceUpdate_else_body@9:
    // contracts/stakingPool.algo.ts:595-604
    // tokenPayoutRatio = abiCall<typeof StakingPool.prototype.proxiedSetTokenPayoutRatio>({
    //     appId: Application(poolOneAppID),
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //     ],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:599
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:599
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:600
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:600
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:601
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:598-602
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:595-604
    // tokenPayoutRatio = abiCall<typeof StakingPool.prototype.proxiedSetTokenPayoutRatio>({
    //     appId: Application(poolOneAppID),
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //     ],
    // }).returnValue
    bytec 20 // method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    bury 8
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    b epochBalanceUpdate_after_if_else@12


// contracts/stakingPool.algo.ts::StakingPool.goOnline[routing]() -> void:
goOnline:
    // contracts/stakingPool.algo.ts:917-925
    // goOnline(
    //     feePayment: gtxn.PaymentTxn,
    //     votePK: bytes<32>,
    //     selectionPK: bytes<32>,
    //     stateProofPK: bytes<64>,
    //     voteFirst: uint64,
    //     voteLast: uint64,
    //     voteKeyDilution: uint64,
    // ): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // contracts/stakingPool.algo.ts:926
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:1018
    // if (!op.AcctParams.acctIncentiveEligible(Global.currentApplicationAddress)[0]) {
    global CurrentApplicationAddress
    acct_params_get AcctIncentiveEligible
    pop
    bnz goOnline_after_if_else@3
    // contracts/stakingPool.algo.ts:1019
    // return Global.payoutsGoOnlineFee
    global PayoutsGoOnlineFee

goOnline_after_inlined_contracts/stakingPool.algo.ts::StakingPool.getGoOnlineFee@4:
    // contracts/stakingPool.algo.ts:928
    // assertMatch(feePayment, { receiver: Global.currentApplicationAddress, amount: extraFee })
    dig 7
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    swap
    gtxns Amount
    dig 2
    ==
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:929-937
    // itxn.keyRegistration({
    //     voteKey: votePK,
    //     selectionKey: selectionPK,
    //     stateProofKey: stateProofPK,
    //     voteFirst: voteFirst,
    //     voteLast: voteLast,
    //     voteKeyDilution: voteKeyDilution,
    //     fee: extraFee,
    // }).submit()
    itxn_begin
    dig 1
    itxn_field VoteKeyDilution
    dig 2
    itxn_field VoteLast
    dig 3
    itxn_field VoteFirst
    dig 4
    itxn_field StateProofPK
    dig 5
    itxn_field SelectionPK
    dig 6
    itxn_field VotePK
    pushint 2 // 2
    itxn_field TypeEnum
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:917-925
    // goOnline(
    //     feePayment: gtxn.PaymentTxn,
    //     votePK: bytes<32>,
    //     selectionPK: bytes<32>,
    //     stateProofPK: bytes<64>,
    //     voteFirst: uint64,
    //     voteLast: uint64,
    //     voteKeyDilution: uint64,
    // ): void {
    intc_1 // 1
    return

goOnline_after_if_else@3:
    // contracts/stakingPool.algo.ts:1021
    // return 0
    intc_0 // 0
    // contracts/stakingPool.algo.ts:927
    // const extraFee = this.getGoOnlineFee()
    b goOnline_after_inlined_contracts/stakingPool.algo.ts::StakingPool.getGoOnlineFee@4


// contracts/stakingPool.algo.ts::StakingPool.goOffline[routing]() -> void:
goOffline:
    // contracts/stakingPool.algo.ts:948
    // if (Txn.sender !== this.creatingValidatorContractAppId.value.address) {
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:948
    // if (Txn.sender !== this.creatingValidatorContractAppId.value.address) {
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    !=
    bz goOffline_after_if_else@3
    // contracts/stakingPool.algo.ts:949
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator

goOffline_after_if_else@3:
    // contracts/stakingPool.algo.ts:952
    // itxn.keyRegistration({}).submit()
    itxn_begin
    pushint 2 // 2
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:945
    // goOffline(): void {
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.linkToNFD[routing]() -> void:
linkToNFD:
    // contracts/stakingPool.algo.ts:958
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // contracts/stakingPool.algo.ts:959
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:961-970
    // itxn.applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //         Bytes('verify_nfd_addr'),
    //         Bytes(nfdName),
    //         op.itob(nfdAppId),
    //         encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:962
    // appId: Application(nfdRegistryAppId),
    intc 10 // TMPL_NFD_REGISTRY_APP_ID
    swap
    // contracts/stakingPool.algo.ts:966
    // op.itob(nfdAppId),
    dig 2
    itob
    // contracts/stakingPool.algo.ts:967
    // encodeArc4(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    uncover 4
    itxn_field Applications
    // contracts/stakingPool.algo.ts:964
    // Bytes('verify_nfd_addr'),
    pushbytes "verify_nfd_addr"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // contracts/stakingPool.algo.ts:961-970
    // itxn.applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //         Bytes('verify_nfd_addr'),
    //         Bytes(nfdName),
    //         op.itob(nfdAppId),
    //         encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    // }).submit()
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:958
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.proxiedSetTokenPayoutRatio[routing]() -> void:
proxiedSetTokenPayoutRatio:
    // contracts/stakingPool.algo.ts:979
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    txna ApplicationArgs 1
    // contracts/stakingPool.algo.ts:980
    // assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:980
    // assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    extract 0 8
    dig 2
    intc_0 // 0
    extract_uint64
    dig 2
    ==
    assert // caller must be part of same validator set!
    // contracts/stakingPool.algo.ts:981
    // assert(this.poolId.value === 1, 'callee must be pool 1')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:72
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:981
    // assert(this.poolId.value === 1, 'callee must be pool 1')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // callee must be pool 1
    // contracts/stakingPool.algo.ts:982
    // assert(poolKey.poolId !== 1, 'caller must NOT be pool 1')
    dig 2
    extract 8 8
    dig 3
    pushint 8 // 8
    extract_uint64
    intc_1 // 1
    !=
    assert // caller must NOT be pool 1
    // contracts/stakingPool.algo.ts:984-987
    // const callerPoolAppID = abiCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [poolKey.id, poolKey.poolId],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:985
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:985
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:984-987
    // const callerPoolAppID = abiCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [poolKey.id, poolKey.poolId],
    // }).returnValue
    bytec 25 // method "getPoolAppId(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // contracts/stakingPool.algo.ts:988
    // assert(callerPoolAppID === poolKey.poolAppId)
    uncover 3
    intc_3 // 16
    extract_uint64
    swap
    dig 1
    ==
    assert
    // contracts/stakingPool.algo.ts:989
    // assert(Txn.sender === Application(poolKey.poolAppId).address)
    txn Sender
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    assert
    // contracts/stakingPool.algo.ts:991-994
    // return abiCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:993
    // args: [this.validatorId.value],
    swap
    itob
    // contracts/stakingPool.algo.ts:991-994
    // return abiCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 26 // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:979
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.isOwnerOrManagerCaller() -> uint64:
isOwnerOrManagerCaller:
    // contracts/stakingPool.algo.ts:997
    // private isOwnerOrManagerCaller(): boolean {
    proto 0 1
    // contracts/stakingPool.algo.ts:998-1001
    // const OwnerAndManager = abiCall<typeof ValidatorRegistry.prototype.getValidatorOwnerAndManager>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:999
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:66
    // creatingValidatorContractAppId = GlobalState<Application>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:999
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:1000
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:69
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:1000
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:998-1001
    // const OwnerAndManager = abiCall<typeof ValidatorRegistry.prototype.getValidatorOwnerAndManager>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    pushbytes 0x2fa22c4b // method "getValidatorOwnerAndManager(uint64)(address,address)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:1002
    // return Txn.sender === OwnerAndManager[0] || Txn.sender === OwnerAndManager[1]
    txn Sender
    swap
    extract 4 32
    ==
    bnz isOwnerOrManagerCaller_bool_true@3
    txn Sender
    frame_dig 0
    extract 36 32
    ==
    bz isOwnerOrManagerCaller_bool_false@4

isOwnerOrManagerCaller_bool_true@3:
    intc_1 // 1

isOwnerOrManagerCaller_bool_merge@5:
    // contracts/stakingPool.algo.ts:1002
    // return Txn.sender === OwnerAndManager[0] || Txn.sender === OwnerAndManager[1]
    swap
    retsub

isOwnerOrManagerCaller_bool_false@4:
    intc_0 // 0
    b isOwnerOrManagerCaller_bool_merge@5


// contracts/stakingPool.algo.ts::StakingPool.checkIfBinClosed() -> void:
checkIfBinClosed:
    // contracts/stakingPool.algo.ts:1031
    // private checkIfBinClosed() {
    proto 0 0
    intc_0 // 0
    // contracts/stakingPool.algo.ts:1032
    // const currentBinSize = this.roundsPerDay.value
    dupn 5
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1032
    // const currentBinSize = this.roundsPerDay.value
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:1033
    // if (Global.round >= this.binRoundStart.value + currentBinSize) {
    global Round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:98
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:1033
    // if (Global.round >= this.binRoundStart.value + currentBinSize) {
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    >=
    bz checkIfBinClosed_after_if_else@9
    // contracts/stakingPool.algo.ts:1034
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:1035
    // const approxRoundsPerYear = BigUint(currentBinSize * 365)
    frame_dig 5
    dup
    pushint 365 // 365
    *
    itob
    frame_bury 1
    // contracts/stakingPool.algo.ts:1036
    // const avgStake = BigUint(this.stakeAccumulator.value.asBigUint() / BigUint(currentBinSize))
    intc_0 // 0
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:1036
    // const avgStake = BigUint(this.stakeAccumulator.value.asBigUint() / BigUint(currentBinSize))
    app_global_get_ex
    assert // check GlobalState exists
    swap
    itob
    dup
    frame_bury 4
    b/
    dup
    frame_bury 3
    // contracts/stakingPool.algo.ts:1037
    // if (avgStake !== 0n) {
    pushbytes 0x
    b!=
    bz checkIfBinClosed_after_if_else@8
    // contracts/stakingPool.algo.ts:1043
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    intc_0 // 0
    // contracts/stakingPool.algo.ts:107
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:1043
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    app_global_get_ex
    assert // check GlobalState exists
    itob
    pushbytes 0x0f4240
    b*
    frame_dig 3
    dup
    cover 2
    b/
    // contracts/stakingPool.algo.ts:1044
    // (approxRoundsPerYear / BigUint(currentBinSize))) /
    frame_dig 1
    frame_dig 4
    b/
    // contracts/stakingPool.algo.ts:1043-1044
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    //     (approxRoundsPerYear / BigUint(currentBinSize))) /
    b*
    // contracts/stakingPool.algo.ts:1045
    // 100n,
    bytec 14 // 0x64
    // contracts/stakingPool.algo.ts:1043-1045
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    //     (approxRoundsPerYear / BigUint(currentBinSize))) /
    //     100n,
    b/
    frame_bury 2
    // contracts/stakingPool.algo.ts:1048
    // let alpha = BigUint(10) // .1
    pushbytes 0x0a
    frame_bury 0
    // contracts/stakingPool.algo.ts:1050
    // if (avgStake > 300000000000n) {
    pushbytes 0x45d964b800
    b>
    bz checkIfBinClosed_after_if_else@4
    // contracts/stakingPool.algo.ts:1051
    // alpha = BigUint(90) // .9
    pushbytes 0x5a
    frame_bury 0

checkIfBinClosed_after_if_else@4:
    // contracts/stakingPool.algo.ts:1055
    // if (this.weightedMovingAverage.value.asBigUint() === 0n) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:110
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1055
    // if (this.weightedMovingAverage.value.asBigUint() === 0n) {
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes 0x
    b==
    bz checkIfBinClosed_else_body@6
    // contracts/stakingPool.algo.ts:1056
    // this.weightedMovingAverage.value = new Uint128(apr)
    frame_dig 2
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:110
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1056
    // this.weightedMovingAverage.value = new Uint128(apr)
    swap
    app_global_put

checkIfBinClosed_after_if_else@8:
    // contracts/stakingPool.algo.ts:1066
    // this.setRoundsPerDay()
    callsub setRoundsPerDay
    // contracts/stakingPool.algo.ts:1068
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:78
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:1068
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    app_global_get_ex
    assert // check GlobalState exists
    itob
    intc_0 // 0
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1068
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    app_global_get_ex
    assert // check GlobalState exists
    itob
    b*
    // contracts/stakingPool.algo.ts:1067-1069
    // this.stakeAccumulator.value = new Uint128(
    //     BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:103
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:1067-1069
    // this.stakeAccumulator.value = new Uint128(
    //     BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:107
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:1070
    // this.rewardAccumulator.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:1071
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    global Round
    dup
    intc_0 // 0
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1071
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    app_global_get_ex
    assert // check GlobalState exists
    %
    -
    // contracts/stakingPool.algo.ts:98
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:1071
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    swap
    app_global_put

checkIfBinClosed_after_if_else@9:
    retsub

checkIfBinClosed_else_body@6:
    // contracts/stakingPool.algo.ts:1059
    // (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    intc_0 // 0
    // contracts/stakingPool.algo.ts:110
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1059
    // (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    app_global_get_ex
    assert // check GlobalState exists
    bytec 14 // 0x64
    frame_dig 0
    dup
    cover 3
    b-
    b*
    bytec 14 // 0x64
    b/
    // contracts/stakingPool.algo.ts:1060
    // (apr * alpha) / BigUint(100),
    frame_dig 2
    uncover 2
    b*
    bytec 14 // 0x64
    b/
    // contracts/stakingPool.algo.ts:1059-1060
    // (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    //     (apr * alpha) / BigUint(100),
    b+
    // contracts/stakingPool.algo.ts:1058-1061
    // this.weightedMovingAverage.value = new Uint128(
    //     (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    //         (apr * alpha) / BigUint(100),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:110
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1058-1061
    // this.weightedMovingAverage.value = new Uint128(
    //     (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    //         (apr * alpha) / BigUint(100),
    // )
    swap
    app_global_put
    b checkIfBinClosed_after_if_else@8


// contracts/stakingPool.algo.ts::StakingPool.setRoundsPerDay() -> void:
setRoundsPerDay:
    // contracts/stakingPool.algo.ts:1075
    // private setRoundsPerDay() {
    proto 0 0
    pushbytes ""
    // contracts/stakingPool.algo.ts:1080
    // if (Txn.firstValid < 12) {
    txn FirstValid
    pushint 12 // 12
    <
    bz setRoundsPerDay_after_if_else@2
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1082
    // this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
    intc 9 // 30857
    app_global_put
    // contracts/stakingPool.algo.ts:1083
    // return
    retsub

setRoundsPerDay_after_if_else@2:
    // contracts/stakingPool.algo.ts:1087
    // op.Block.blkTimestamp(Txn.firstValid - 1) - op.Block.blkTimestamp(Txn.firstValid - 11)
    txn FirstValid
    intc_1 // 1
    -
    block BlkTimestamp
    txn FirstValid
    pushint 11 // 11
    -
    block BlkTimestamp
    -
    dup
    frame_bury 0
    // contracts/stakingPool.algo.ts:1088
    // if (avgBlockTimeTenths === 0) {
    bnz setRoundsPerDay_after_if_else@4
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1090
    // this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
    intc 9 // 30857
    app_global_put
    // contracts/stakingPool.algo.ts:1091
    // return
    retsub

setRoundsPerDay_after_if_else@4:
    // contracts/stakingPool.algo.ts:1096
    // this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
    pushint 864000 // 864000
    frame_dig 0
    /
    // contracts/stakingPool.algo.ts:96
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1096
    // this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
    swap
    app_global_put
    retsub
