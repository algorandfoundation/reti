#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 64 16 200 157 300 2100000 1000000 30857 TMPL_NFD_REGISTRY_APP_ID
    bytecblock "stakers" "creatorApp" "validatorId" "poolId" 0x151f7c75 "staked" "roundsPerDay" "stakeAccumulator" 0x0002 "binRoundStart" "numStakers" "rewardAccumulator" "ewma" 0x75aff61d 0x64 "minEntryStake" "lastPayout" "epochNumber" 0x000100000000000f4240 0x0001 0x0c2245e1 0x068101 0x00000000000000000000000000000001 0x00000000000000000000000000000000 0xa2dc51b5 0x572767d1 0x4df8d86e 0x0003
    // contracts/stakingPool.algo.ts:61-62
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@17
    pushbytess 0x3172ca9d 0x47cfcc04 0xf9c70cbd 0x421b5abe 0xf5892d56 0x5cfbb057 0x63f3f28b 0x86a3725c 0xefc2608d 0x9cee2e40 0x51ef3b21 0xa24e2717 // method "gas()void", method "initStorage(pay)void", method "addStake(pay,address)uint64", method "removeStake(address,uint64)void", method "claimTokens()void", method "getStakerInfo(address)(address,uint64,uint64,uint64,uint64)", method "payTokenReward(address,uint64,uint64)void", method "updateAlgodVer(string)void", method "epochBalanceUpdate()void", method "goOnline(pay,byte[32],byte[32],byte[64],uint64,uint64,uint64)void", method "goOffline()void", method "linkToNFD(uint64,string)void"
    bytec 20 // method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
    txna ApplicationArgs 0
    match main_gas_route@3 initStorage addStake removeStake claimTokens getStakerInfo payTokenReward updateAlgodVer epochBalanceUpdate goOnline goOffline linkToNFD proxiedSetTokenPayoutRatio
    err

main_gas_route@3:
    // contracts/stakingPool.algo.ts:156
    // gas(): void {}
    intc_1 // 1
    return

main_create_NoOp@17:
    // contracts/stakingPool.algo.ts:61-62
    // @contract({ avmVersion: 11 })
    // export class StakingPool extends Contract {
    pushbytes 0x59e90aa6 // method "createApplication(uint64,uint64,uint64,uint64)void"
    txna ApplicationArgs 0
    match createApplication
    err


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10 // 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@6
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 21 // 0x068101
    itxn_field ApprovalProgram
    bytec 21 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@5:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_after_while@6:
    retsub


// contracts/utils.algo.ts::wideRatio(numeratorFactors: bytes, denominatorFactors: bytes) -> uint64, bytes, bytes:
wideRatio:
    // contracts/utils.algo.ts:4
    // export function wideRatio(numeratorFactors: uint64[], denominatorFactors: uint64[]): uint64 {
    proto 2 3
    intc_0 // 0
    pushbytes ""
    dup
    // contracts/utils.algo.ts:5
    // let numerator = new Uint128(1n)
    bytec 22 // 0x00000000000000000000000000000001
    // contracts/utils.algo.ts:6
    // for (const factor of numeratorFactors) {
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_0 // 0

wideRatio_for_header@1:
    // contracts/utils.algo.ts:6
    // for (const factor of numeratorFactors) {
    frame_dig 5
    frame_dig 4
    <
    bz wideRatio_after_for@4
    frame_dig -2
    extract 2 0
    frame_dig 5
    dup
    cover 2
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/utils.algo.ts:7
    // numerator = new Uint128(BigUint(factor) * numerator.asBigUint())
    frame_dig 3
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    frame_bury 3
    intc_1 // 1
    +
    frame_bury 5
    b wideRatio_for_header@1

wideRatio_after_for@4:
    // contracts/utils.algo.ts:10
    // let denominator = new Uint128(1n)
    bytec 22 // 0x00000000000000000000000000000001
    frame_bury 0
    // contracts/utils.algo.ts:11
    // for (const factor of denominatorFactors) {
    frame_dig -1
    intc_0 // 0
    extract_uint16
    frame_bury 1
    intc_0 // 0
    frame_bury 2

wideRatio_for_header@5:
    // contracts/utils.algo.ts:11
    // for (const factor of denominatorFactors) {
    frame_dig 2
    frame_dig 1
    <
    bz wideRatio_after_for@8
    frame_dig -1
    extract 2 0
    frame_dig 2
    dup
    cover 2
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/utils.algo.ts:12
    // denominator = new Uint128(BigUint(factor) * denominator.asBigUint())
    frame_dig 0
    b*
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 2
    b wideRatio_for_header@5

wideRatio_after_for@8:
    // contracts/utils.algo.ts:15
    // const ratio: biguint = numerator.asBigUint() / denominator.asBigUint()
    frame_dig 3
    frame_dig 0
    b/
    // contracts/utils.algo.ts:16
    // return new Uint64(ratio).asUint64()
    dup
    len
    pushint 8 // 8
    <=
    assert // overflow
    pushint 8 // 8
    bzero
    b|
    btoi
    frame_dig -2
    frame_dig -1
    frame_bury 2
    frame_bury 1
    frame_bury 0
    retsub


// contracts/stakingPool.algo.ts::StakingPool.createApplication[routing]() -> void:
createApplication:
    // contracts/stakingPool.algo.ts:122-127
    // createApplication(
    //     creatingContractId: Application,
    //     validatorId: uint64,
    //     poolId: uint64,
    //     minEntryStake: uint64,
    // ): void {
    txna ApplicationArgs 1
    btoi
    dup
    txna ApplicationArgs 2
    btoi
    swap
    txna ApplicationArgs 3
    btoi
    swap
    txna ApplicationArgs 4
    btoi
    swap
    // contracts/stakingPool.algo.ts:128
    // if (creatingContractId === Application(0)) {
    bnz createApplication_else_body@3
    // contracts/stakingPool.algo.ts:130
    // assert(validatorId === 0)
    dig 2
    !
    assert
    // contracts/stakingPool.algo.ts:131
    // assert(poolId === 0)
    dig 1
    !
    assert

createApplication_after_if_else@4:
    // contracts/stakingPool.algo.ts:136
    // assert(minEntryStake >= MIN_ALGO_STAKE_PER_POOL, 'staking pool must have minimum entry of 1 algo')
    dupn 2
    intc 8 // 1000000
    >=
    assert // staking pool must have minimum entry of 1 algo
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:137
    // this.creatingValidatorContractAppId.value = creatingContractId.id
    dig 5
    app_global_put
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:138
    // this.validatorId.value = validatorId
    dig 4
    app_global_put
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:139
    // this.poolId.value = poolId
    dig 3
    app_global_put
    // contracts/stakingPool.algo.ts:76
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:140
    // this.numStakers.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:141
    // this.totalAlgoStaked.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:81
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:142
    // this.minEntryStake.value = minEntryStake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:84
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:143
    // this.lastPayout.value = Global.round // set to init block to establish baseline
    global Round
    app_global_put
    // contracts/stakingPool.algo.ts:87
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:144
    // this.epochNumber.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:146
    // this.setRoundsPerDay()
    callsub setRoundsPerDay
    // contracts/stakingPool.algo.ts:147
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    global Round
    dup
    intc_0 // 0
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:147
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    app_global_get_ex
    assert // check GlobalState exists
    %
    -
    // contracts/stakingPool.algo.ts:99
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:147
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value) // place at start of bin
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:148
    // this.stakeAccumulator.value = new Uint128(0)
    bytec 23 // 0x00000000000000000000000000000000
    app_global_put
    // contracts/stakingPool.algo.ts:108
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:149
    // this.rewardAccumulator.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:111
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:150
    // this.weightedMovingAverage.value = new Uint128(0)
    bytec 23 // 0x00000000000000000000000000000000
    app_global_put
    // contracts/stakingPool.algo.ts:122-127
    // createApplication(
    //     creatingContractId: Application,
    //     validatorId: uint64,
    //     poolId: uint64,
    //     minEntryStake: uint64,
    // ): void {
    intc_1 // 1
    return

createApplication_else_body@3:
    // contracts/stakingPool.algo.ts:133
    // assert(validatorId !== 0)
    dig 2
    assert
    // contracts/stakingPool.algo.ts:134
    // assert(poolId !== 0)
    dig 1
    assert
    b createApplication_after_if_else@4


// contracts/stakingPool.algo.ts::StakingPool.initStorage[routing]() -> void:
initStorage:
    // contracts/stakingPool.algo.ts:172
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:173
    // assert(!this.stakers.exists, 'staking pool already initialized')
    box_len
    bury 1
    !
    assert // staking pool already initialized
    // contracts/stakingPool.algo.ts:176-179
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:177
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:177
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:178
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:178
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:176-179
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    intc 5 // 157
    // contracts/stakingPool.algo.ts:181
    // const isTokenEligible = validatorConfig.rewardTokenId !== 0
    extract_uint64
    dup
    // contracts/stakingPool.algo.ts:182
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    bz initStorage_bool_false@5
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:182
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz initStorage_bool_false@5
    intc_1 // 1

initStorage_bool_merge@6:
    // contracts/stakingPool.algo.ts:182
    // const extraMBR: uint64 = isTokenEligible && this.poolId.value === 1 ? ASSET_HOLDING_FEE : 0
    pushint 100000 // 100000
    *
    // contracts/stakingPool.algo.ts:184-186
    // ALGORAND_ACCOUNT_MIN_BALANCE +
    // extraMBR +
    // this.costForBoxStorage(7 /* 'stakers' name */ + sizeOf<StakedInfo>() * MAX_STAKERS_PER_POOL)
    pushint 5225300 // 5225300
    +
    // contracts/stakingPool.algo.ts:189
    // assertMatch(mbrPayment, { receiver: Global.currentApplicationAddress, amount: PoolInitMbr })
    dig 2
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    swap
    gtxns Amount
    uncover 2
    ==
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:190
    // this.stakers.create()
    pushint 12800 // 12800
    box_create
    pop
    // contracts/stakingPool.algo.ts:192
    // if (isTokenEligible && this.poolId.value === 1) {
    dup
    bz initStorage_after_if_else@10
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:192
    // if (isTokenEligible && this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz initStorage_after_if_else@10
    // contracts/stakingPool.algo.ts:194-198
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:196
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/stakingPool.algo.ts:197
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    dup
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:194-198
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: Global.currentApplicationAddress,
    //     assetAmount: 0,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

initStorage_after_if_else@10:
    // contracts/stakingPool.algo.ts:172
    // initStorage(mbrPayment: gtxn.PaymentTxn): void {
    intc_1 // 1
    return

initStorage_bool_false@5:
    intc_0 // 0
    b initStorage_bool_merge@6


// contracts/stakingPool.algo.ts::StakingPool.addStake[routing]() -> void:
addStake:
    intc_0 // 0
    dup
    pushbytes ""
    // contracts/stakingPool.algo.ts:212
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Account): uint64 {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    dup
    cover 2
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:213
    // assert(this.stakers.exists, 'staking pool must be initialized first')
    box_len
    bury 1
    assert // staking pool must be initialized first
    // contracts/stakingPool.algo.ts:217
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:217
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/stakingPool.algo.ts:216-219
    // assert(
    //     Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    //     'stake can only be added via the validator contract',
    // )
    assert // stake can only be added via the validator contract
    // contracts/stakingPool.algo.ts:220
    // assert(staker !== Global.zeroAddress)
    global ZeroAddress
    !=
    assert
    // contracts/stakingPool.algo.ts:223
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:227-231
    // assertMatch(stakedAmountPayment, {
    //     sender: Application(this.creatingValidatorContractAppId.value).address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    dup
    gtxns Sender
    // contracts/stakingPool.algo.ts:228
    // sender: Application(this.creatingValidatorContractAppId.value).address,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:228
    // sender: Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    // contracts/stakingPool.algo.ts:227-231
    // assertMatch(stakedAmountPayment, {
    //     sender: Application(this.creatingValidatorContractAppId.value).address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    ==
    dig 1
    gtxns Receiver
    // contracts/stakingPool.algo.ts:229
    // receiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // contracts/stakingPool.algo.ts:227-231
    // assertMatch(stakedAmountPayment, {
    //     sender: Application(this.creatingValidatorContractAppId.value).address,
    //     receiver: Global.currentApplicationAddress,
    //     amount: stakedAmountPayment.amount,
    // })
    ==
    &&
    swap
    gtxns Amount
    dup
    uncover 2
    intc_1 // 1
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:236
    // const entryRound: uint64 = Global.round + ALGORAND_STAKING_BLOCK_DELAY
    global Round
    pushint 320 // 320
    +
    swap
    // contracts/stakingPool.algo.ts:237
    // let firstEmpty: uint64 = 0
    intc_0 // 0
    swap
    // contracts/stakingPool.algo.ts:239
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    intc_0 // 0
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:239
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    +
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:239
    // this.totalAlgoStaked.value += stakedAmountPayment.amount
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:241
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:99
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:241
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:241
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:243
    // this.stakeAccumulator.value.asBigUint() + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:243
    // this.stakeAccumulator.value.asBigUint() + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    itob
    dup
    cover 3
    uncover 2
    itob
    b*
    b+
    // contracts/stakingPool.algo.ts:242-244
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.asBigUint() + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:242-244
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.asBigUint() + BigUint(stakedAmountPayment.amount) * BigUint(roundsLeftInBin),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:247
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

addStake_while_top@2:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:247
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dup
    intc 4 // 200
    <
    bz addStake_after_while@9
    // contracts/stakingPool.algo.ts:248
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:249
    // const cmpStaker = clone(this.stakers.value[i])
    dup
    intc_2 // 64
    *
    dup
    bury 8
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:249
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 9
    // contracts/stakingPool.algo.ts:249-250
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    dup
    bury 10
    // contracts/stakingPool.algo.ts:250
    // if (cmpStaker.account === staker) {
    dig 6
    ==
    bz addStake_after_if_else@5
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:252
    // cmpStaker.balance += stakedAmountPayment.amount
    dig 7
    dup
    cover 2
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    dig 6
    +
    itob
    dig 9
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:253
    // cmpStaker.entryRound = entryRound
    dig 5
    itob
    replace2 56
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:256
    // this.stakers.value[i] = clone(cmpStaker)
    cover 2
    box_replace

addStake_after_inlined_contracts/stakingPool.algo.ts::StakingPool.addStake@12:
    // contracts/stakingPool.algo.ts:212
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Account): uint64 {
    dig 3
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

addStake_after_if_else@5:
    // contracts/stakingPool.algo.ts:260
    // if (firstEmpty === 0 && cmpStaker.account === Global.zeroAddress) {
    dig 2
    bnz addStake_after_if_else@8
    dig 8
    global ZeroAddress
    ==
    bz addStake_after_if_else@8
    // contracts/stakingPool.algo.ts:261
    // firstEmpty = i + 1
    dup
    intc_1 // 1
    +
    bury 3

addStake_after_if_else@8:
    // contracts/stakingPool.algo.ts:247
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b addStake_while_top@2

addStake_after_while@9:
    // contracts/stakingPool.algo.ts:265
    // if (firstEmpty === 0) {
    dig 2
    dup
    !
    !
    assert // Staking pool full
    // contracts/stakingPool.algo.ts:272
    // assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:81
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:272
    // assert(stakedAmountPayment.amount >= this.minEntryStake.value, 'must stake at least the minimum for this pool')
    app_global_get_ex
    assert // check GlobalState exists
    dig 6
    <=
    assert // must stake at least the minimum for this pool
    // contracts/stakingPool.algo.ts:274
    // assert(this.stakers.value[firstEmpty - 1].account === Global.zeroAddress)
    intc_1 // 1
    -
    intc_2 // 64
    *
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:274
    // assert(this.stakers.value[firstEmpty - 1].account === Global.zeroAddress)
    dig 1
    intc_2 // 64
    box_extract
    extract 0 32
    global ZeroAddress
    ==
    assert
    // contracts/stakingPool.algo.ts:275-281
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    dig 6
    dig 3
    concat
    // contracts/stakingPool.algo.ts:278
    // totalRewarded: 0,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:275-281
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    itob
    swap
    dig 1
    concat
    swap
    concat
    dig 5
    itob
    concat
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:275-281
    // this.stakers.value[firstEmpty - 1] = {
    //     account: staker,
    //     balance: stakedAmountPayment.amount,
    //     totalRewarded: 0,
    //     rewardTokenBalance: 0,
    //     entryRound: entryRound,
    // }
    cover 2
    box_replace
    // contracts/stakingPool.algo.ts:282
    // this.numStakers.value += 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:76
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:282
    // this.numStakers.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // contracts/stakingPool.algo.ts:76
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:282
    // this.numStakers.value += 1
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:212
    // addStake(stakedAmountPayment: gtxn.PaymentTxn, staker: Account): uint64 {
    b addStake_after_inlined_contracts/stakingPool.algo.ts::StakingPool.addStake@12


// contracts/stakingPool.algo.ts::StakingPool.removeStake[routing]() -> void:
removeStake:
    intc_0 // 0
    pushbytes ""
    dupn 5
    // contracts/stakingPool.algo.ts:297
    // removeStake(staker: Account, amountToUnstake: uint64): void {
    txna ApplicationArgs 1
    dup
    txna ApplicationArgs 2
    btoi
    swap
    // contracts/stakingPool.algo.ts:300
    // if (staker !== Txn.sender) {
    txn Sender
    !=
    bz removeStake_after_if_else@3
    // contracts/stakingPool.algo.ts:302
    // this.isOwnerOrManagerCaller(),
    callsub isOwnerOrManagerCaller
    // contracts/stakingPool.algo.ts:301-304
    // assert(
    //     this.isOwnerOrManagerCaller(),
    //     'If staker is not sender in removeStake call, then sender MUST be owner or manager of validator',
    // )
    assert // If staker is not sender in removeStake call, then sender MUST be owner or manager of validator

removeStake_after_if_else@3:
    // contracts/stakingPool.algo.ts:307
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:309
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    bury 5

removeStake_while_top@4:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:309
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dig 4
    dup
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:310
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:311
    // const cmpStaker = clone(this.stakers.value[i])
    intc_2 // 64
    *
    dup
    bury 7
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:311
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 10
    // contracts/stakingPool.algo.ts:311-312
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    // contracts/stakingPool.algo.ts:312
    // if (cmpStaker.account === staker) {
    dig 2
    ==
    bz removeStake_after_if_else@26
    // contracts/stakingPool.algo.ts:313
    // if (amountToUnstake === 0) {
    dup
    bnz removeStake_after_if_else@8
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:315
    // amountToUnstake = cmpStaker.balance
    dig 6
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    bury 1

removeStake_after_if_else@8:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:317
    // if (cmpStaker.balance < amountToUnstake) {
    dig 6
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    dup
    dig 2
    dup
    cover 3
    <
    !
    assert // Insufficient balance
    // contracts/stakingPool.algo.ts:320
    // cmpStaker.balance -= amountToUnstake
    dig 1
    -
    itob
    dig 10
    swap
    replace2 32
    dup
    bury 11
    // contracts/stakingPool.algo.ts:321
    // this.totalAlgoStaked.value -= amountToUnstake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:321
    // this.totalAlgoStaked.value -= amountToUnstake
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    -
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:321
    // this.totalAlgoStaked.value -= amountToUnstake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:323
    // let amountRewardTokenRemoved: uint64 = 0
    intc_0 // 0
    bury 9
    // contracts/stakingPool.algo.ts:324
    // if (cmpStaker.rewardTokenBalance > 0) {
    pushint 48 // 48
    extract_uint64
    dup
    bury 8
    bz removeStake_after_if_else@17
    // contracts/stakingPool.algo.ts:326
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:326
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz removeStake_else_body@15
    // contracts/stakingPool.algo.ts:327-330
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:328
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:328
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:329
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:329
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:327-330
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:335-339
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    itxn_begin
    intc 5 // 157
    // contracts/stakingPool.algo.ts:336
    // xferAsset: validatorConfig.rewardTokenId,
    extract_uint64
    dig 7
    itxn_field AssetAmount
    dig 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:335-339
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:341
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    dig 9
    swap
    replace2 48
    bury 9

removeStake_after_if_else@16:
    dig 6
    bury 8

removeStake_after_if_else@17:
    // contracts/stakingPool.algo.ts:353
    // cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    dig 8
    pushint 32 // 32
    extract_uint64
    dup
    bury 4
    bz removeStake_bool_true@19
    intc_0 // 0
    // contracts/stakingPool.algo.ts:81
    // minEntryStake = GlobalState<uint64>({ key: 'minEntryStake' })
    bytec 15 // "minEntryStake"
    // contracts/stakingPool.algo.ts:353
    // cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    app_global_get_ex
    assert // check GlobalState exists
    dig 3
    <=
    bz removeStake_bool_false@20

removeStake_bool_true@19:
    intc_1 // 1

removeStake_bool_merge@21:
    // contracts/stakingPool.algo.ts:352-355
    // assert(
    //     cmpStaker.balance === 0 || cmpStaker.balance >= this.minEntryStake.value,
    //     'cannot reduce balance below minimum allowed stake unless all is removed',
    // )
    assert // cannot reduce balance below minimum allowed stake unless all is removed
    // contracts/stakingPool.algo.ts:360-364
    // itxn.payment({
    //     amount: amountToUnstake,
    //     receiver: staker,
    //     note: 'unstaked',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:363
    // note: 'unstaked',
    pushbytes "unstaked"
    itxn_field Note
    dig 1
    itxn_field Receiver
    dup
    itxn_field Amount
    // contracts/stakingPool.algo.ts:360-364
    // itxn.payment({
    //     amount: amountToUnstake,
    //     receiver: staker,
    //     note: 'unstaked',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:365
    // let stakerRemoved = false
    intc_0 // 0
    bury 4
    // contracts/stakingPool.algo.ts:366
    // if (cmpStaker.balance === 0) {
    dig 2
    bnz removeStake_after_if_else@24
    // contracts/stakingPool.algo.ts:368
    // this.numStakers.value -= 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:76
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:368
    // this.numStakers.value -= 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    -
    // contracts/stakingPool.algo.ts:76
    // numStakers = GlobalState<uint64>({ key: 'numStakers' })
    bytec 10 // "numStakers"
    // contracts/stakingPool.algo.ts:368
    // this.numStakers.value -= 1
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:369
    // cmpStaker.account = Global.zeroAddress
    dig 8
    global ZeroAddress
    replace2 0
    // contracts/stakingPool.algo.ts:370
    // cmpStaker.totalRewarded = 0
    intc_0 // 0
    itob
    swap
    dig 1
    replace2 40
    // contracts/stakingPool.algo.ts:371
    // cmpStaker.rewardTokenBalance = 0
    swap
    replace2 48
    bury 9
    // contracts/stakingPool.algo.ts:372
    // stakerRemoved = true
    intc_1 // 1
    bury 4

removeStake_after_if_else@24:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:375
    // this.stakers.value[i] = clone(cmpStaker)
    dig 6
    dig 10
    box_replace
    // contracts/stakingPool.algo.ts:377
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:99
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:377
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:377
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:378
    // const subtractAmount = BigUint(amountToUnstake * roundsLeftInBin)
    dig 1
    dup
    uncover 2
    *
    itob
    // contracts/stakingPool.algo.ts:379
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.asBigUint() - subtractAmount)
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:379
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.asBigUint() - subtractAmount)
    app_global_get_ex
    assert // check GlobalState exists
    swap
    b-
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:379
    // this.stakeAccumulator.value = new Uint128(this.stakeAccumulator.value.asBigUint() - subtractAmount)
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:384-397
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         amountToUnstake,
    //         amountRewardTokenRemoved,
    //         stakerRemoved,
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:385
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:385
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:388
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:388
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:389
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:389
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:390
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:387-391
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:393
    // amountToUnstake,
    uncover 2
    itob
    // contracts/stakingPool.algo.ts:394
    // amountRewardTokenRemoved,
    dig 10
    itob
    // contracts/stakingPool.algo.ts:395
    // stakerRemoved,
    pushbytes 0x00
    intc_0 // 0
    dig 9
    setbit
    // contracts/stakingPool.algo.ts:384-397
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         amountToUnstake,
    //         amountRewardTokenRemoved,
    //         stakerRemoved,
    //     ],
    // })
    bytec 24 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    dig 5
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:297
    // removeStake(staker: Account, amountToUnstake: uint64): void {
    intc_1 // 1
    return

removeStake_bool_false@20:
    intc_0 // 0
    b removeStake_bool_merge@21

removeStake_else_body@15:
    // contracts/stakingPool.algo.ts:347
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    dig 9
    swap
    replace2 48
    bury 9
    b removeStake_after_if_else@16

removeStake_after_if_else@26:
    // contracts/stakingPool.algo.ts:309
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dig 4
    intc_1 // 1
    +
    bury 5
    b removeStake_while_top@4


// contracts/stakingPool.algo.ts::StakingPool.claimTokens[routing]() -> void:
claimTokens:
    intc_0 // 0
    dup
    pushbytes ""
    dup
    // contracts/stakingPool.algo.ts:413
    // const staker = Txn.sender
    txn Sender
    // contracts/stakingPool.algo.ts:415
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

claimTokens_while_top@2:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:415
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dupn 2
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:416
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:417
    // const cmpStaker = clone(this.stakers.value[i])
    intc_2 // 64
    *
    dup
    bury 4
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:417
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 6
    // contracts/stakingPool.algo.ts:417-418
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account === staker) {
    extract 0 32
    // contracts/stakingPool.algo.ts:418
    // if (cmpStaker.account === staker) {
    dig 2
    ==
    bz claimTokens_after_if_else@13
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:419
    // if (cmpStaker.rewardTokenBalance === 0) {
    dig 3
    intc_2 // 64
    box_extract
    dup
    extract 48 8
    bury 7
    pushint 48 // 48
    extract_uint64
    dup
    bury 5
    bz claimTokens_after_inlined_contracts/stakingPool.algo.ts::StakingPool.claimTokens@15
    // contracts/stakingPool.algo.ts:424
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:424
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz claimTokens_else_body@10
    // contracts/stakingPool.algo.ts:425-428
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:426
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:426
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:427
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:427
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:425-428
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:432-436
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    itxn_begin
    intc 5 // 157
    // contracts/stakingPool.algo.ts:433
    // xferAsset: validatorConfig.rewardTokenId,
    extract_uint64
    dig 4
    itxn_field AssetAmount
    dig 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contracts/stakingPool.algo.ts:432-436
    // itxn.assetTransfer({
    //     xferAsset: validatorConfig.rewardTokenId,
    //     assetReceiver: staker,
    //     assetAmount: cmpStaker.rewardTokenBalance,
    // }).submit()
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:438
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    dig 5
    swap
    replace2 48
    bury 5

claimTokens_after_if_else@11:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:448
    // this.stakers.value[i] = clone(cmpStaker)
    dig 3
    dig 6
    box_replace
    // contracts/stakingPool.algo.ts:453-466
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:454
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:454
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:457
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:457
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:458
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:458
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:459
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:456-460
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:462
    // 0, // no algo removed
    intc_0 // 0
    itob
    // contracts/stakingPool.algo.ts:453-466
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    bytec 24 // method "stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dig 3
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 6
    itxn_field ApplicationArgs
    // contracts/stakingPool.algo.ts:464
    // false, // staker isn't being removed.
    pushbytes 0x00
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // contracts/stakingPool.algo.ts:453-466
    // abiCall<typeof ValidatorRegistry.prototype.stakeRemoved>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //         staker,
    //         0, // no algo removed
    //         amountRewardTokenRemoved,
    //         false, // staker isn't being removed.
    //     ],
    // })
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

claimTokens_after_inlined_contracts/stakingPool.algo.ts::StakingPool.claimTokens@15:
    // contracts/stakingPool.algo.ts:409
    // claimTokens(): void {
    intc_1 // 1
    return

claimTokens_else_body@10:
    // contracts/stakingPool.algo.ts:444
    // cmpStaker.rewardTokenBalance = 0
    intc_0 // 0
    itob
    dig 5
    swap
    replace2 48
    bury 5
    b claimTokens_after_if_else@11

claimTokens_after_if_else@13:
    // contracts/stakingPool.algo.ts:415
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b claimTokens_while_top@2


// contracts/stakingPool.algo.ts::StakingPool.getStakerInfo[routing]() -> void:
getStakerInfo:
    pushbytes ""
    // contracts/stakingPool.algo.ts:480
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    // contracts/stakingPool.algo.ts:482
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0

getStakerInfo_while_top@2:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:482
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dupn 2
    intc 4 // 200
    <
    assert // account not found
    // contracts/stakingPool.algo.ts:483
    // ensureBudget(200)
    intc 4 // 200
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:484
    // if (this.stakers.value[i].account === staker) {
    intc_2 // 64
    *
    dup
    bury 4
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:484
    // if (this.stakers.value[i].account === staker) {
    swap
    intc_2 // 64
    box_extract
    extract 0 32
    dig 2
    ==
    bz getStakerInfo_after_if_else@5
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:485
    // return this.stakers.value[i]
    dig 3
    intc_2 // 64
    box_extract
    // contracts/stakingPool.algo.ts:480
    // @abimethod({ readonly: true })
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getStakerInfo_after_if_else@5:
    // contracts/stakingPool.algo.ts:482
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dup
    intc_1 // 1
    +
    bury 1
    b getStakerInfo_while_top@2


// contracts/stakingPool.algo.ts::StakingPool.payTokenReward[routing]() -> void:
payTokenReward:
    // contracts/stakingPool.algo.ts:501
    // payTokenReward(staker: Account, rewardToken: uint64, amountToSend: uint64): void {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // contracts/stakingPool.algo.ts:504
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:504
    // Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    ==
    // contracts/stakingPool.algo.ts:503-506
    // assert(
    //     Txn.sender === Application(this.creatingValidatorContractAppId.value).address,
    //     'this can only be called via the validator contract',
    // )
    assert // this can only be called via the validator contract
    // contracts/stakingPool.algo.ts:507
    // assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:507
    // assert(this.poolId.value === 1, 'must be pool 1 in order to be called to pay out token rewards')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // must be pool 1 in order to be called to pay out token rewards
    // contracts/stakingPool.algo.ts:508
    // assert(rewardToken !== 0, 'can only claim token rewards from validator that has them')
    dig 1
    assert // can only claim token rewards from validator that has them
    // contracts/stakingPool.algo.ts:511-515
    // itxn.assetTransfer({
    //     xferAsset: rewardToken,
    //     assetReceiver: staker,
    //     assetAmount: amountToSend,
    // }).submit()
    itxn_begin
    itxn_field AssetAmount
    itxn_field XferAsset
    itxn_field AssetReceiver
    pushint 4 // 4
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:501
    // payTokenReward(staker: Account, rewardToken: uint64, amountToSend: uint64): void {
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.updateAlgodVer[routing]() -> void:
updateAlgodVer:
    // contracts/stakingPool.algo.ts:527
    // updateAlgodVer(algodVer: string): void {
    txna ApplicationArgs 1
    extract 2 0
    // contracts/stakingPool.algo.ts:528
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:90
    // algodVer = GlobalState<bytes>({ key: 'algodVer' })
    pushbytes "algodVer"
    // contracts/stakingPool.algo.ts:529
    // this.algodVer.value = Bytes(algodVer)
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:527
    // updateAlgodVer(algodVer: string): void {
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.epochBalanceUpdate[routing]() -> void:
epochBalanceUpdate:
    intc_0 // 0
    dupn 4
    pushbytes ""
    dupn 28
    intc_0 // 0
    // contracts/stakingPool.algo.ts:542-545
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:543
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:543
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:544
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:544
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:542-545
    // const validatorConfig = abiCall<typeof ValidatorRegistry.prototype.getValidatorConfig>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 13 // method "getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:551
    // const epochRoundLength = validatorConfig.epochRoundLength.asUint64()
    dup
    pushint 173 // 173
    extract_uint32
    dup
    cover 2
    // contracts/stakingPool.algo.ts:552
    // const curRound = Global.round
    global Round
    // contracts/stakingPool.algo.ts:553
    // const thisEpochBegin: uint64 = curRound - (curRound % epochRoundLength)
    dup
    dig 2
    %
    dig 1
    swap
    -
    dup
    cover 2
    cover 4
    // contracts/stakingPool.algo.ts:556
    // const lastPayoutEpoch: uint64 = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
    intc_0 // 0
    // contracts/stakingPool.algo.ts:84
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:556
    // const lastPayoutEpoch: uint64 = this.lastPayout.value - (this.lastPayout.value % epochRoundLength)
    app_global_get_ex
    assert // check GlobalState exists
    dup
    uncover 4
    %
    -
    // contracts/stakingPool.algo.ts:558
    // assert(lastPayoutEpoch !== thisEpochBegin, "can't call epochBalanceUpdate in same epoch as prior call")
    uncover 2
    !=
    assert // can't call epochBalanceUpdate in same epoch as prior call
    // contracts/stakingPool.algo.ts:560
    // this.checkIfBinClosed()
    callsub checkIfBinClosed
    // contracts/stakingPool.algo.ts:84
    // lastPayout = GlobalState<uint64>({ key: 'lastPayout' })
    bytec 16 // "lastPayout"
    // contracts/stakingPool.algo.ts:563
    // this.lastPayout.value = curRound
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:564
    // this.epochNumber.value += 1
    intc_0 // 0
    // contracts/stakingPool.algo.ts:87
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:564
    // this.epochNumber.value += 1
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // contracts/stakingPool.algo.ts:87
    // epochNumber = GlobalState<uint64>({ key: 'epochNumber' })
    bytec 17 // "epochNumber"
    // contracts/stakingPool.algo.ts:564
    // this.epochNumber.value += 1
    swap
    app_global_put
    intc 5 // 157
    // contracts/stakingPool.algo.ts:569
    // const isTokenEligible = validatorConfig.rewardTokenId !== 0
    extract_uint64
    dup
    // contracts/stakingPool.algo.ts:570
    // let poolOneAppID = Global.currentApplicationId.id
    global CurrentApplicationID
    swap
    // contracts/stakingPool.algo.ts:571
    // let poolOneAddress = Global.currentApplicationAddress
    global CurrentApplicationAddress
    swap
    // contracts/stakingPool.algo.ts:576
    // if (isTokenEligible) {
    bz epochBalanceUpdate_after_if_else@12
    // contracts/stakingPool.algo.ts:577
    // if (this.poolId.value !== 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:577
    // if (this.poolId.value !== 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    !=
    bz epochBalanceUpdate_after_if_else@6
    // contracts/stakingPool.algo.ts:579-582
    // poolOneAppID = abiCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value, 1],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:580
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:580
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:581
    // args: [this.validatorId.value, 1],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:581
    // args: [this.validatorId.value, 1],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    intc_1 // 1
    itob
    // contracts/stakingPool.algo.ts:579-582
    // poolOneAppID = abiCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value, 1],
    // }).returnValue
    bytec 25 // method "getPoolAppId(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    dup
    bury 3
    // contracts/stakingPool.algo.ts:584
    // poolOneAddress = Application(poolOneAppID).address
    app_params_get AppAddress
    swap
    bury 2
    assert // application exists

epochBalanceUpdate_after_if_else@6:
    // contracts/stakingPool.algo.ts:589
    // if (this.poolId.value === 1) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:589
    // if (this.poolId.value === 1) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz epochBalanceUpdate_else_body@9
    // contracts/stakingPool.algo.ts:590-593
    // tokenPayoutRatio = abiCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:591
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:591
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:592
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:592
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:590-593
    // tokenPayoutRatio = abiCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 26 // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    bury 8
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix

epochBalanceUpdate_after_if_else@12:
    // contracts/stakingPool.algo.ts:611-614
    // const validatorState = abiCall<typeof ValidatorRegistry.prototype.getValidatorState>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:612
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:612
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:613
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:613
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:611-614
    // const validatorState = abiCall<typeof ValidatorRegistry.prototype.getValidatorState>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    pushbytes 0x1f2f0109 // method "getValidatorState(uint64)(uint16,uint64,uint64,uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:615
    // const rewardTokenHeldBack = validatorState.rewardTokenHeldBack
    dup
    pushint 22 // 22
    extract_uint64
    bury 22
    // contracts/stakingPool.algo.ts:622
    // Global.currentApplicationAddress.balance -
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    // contracts/stakingPool.algo.ts:623
    // this.totalAlgoStaked.value -
    intc_0 // 0
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:623
    // this.totalAlgoStaked.value -
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:622-623
    // Global.currentApplicationAddress.balance -
    // this.totalAlgoStaked.value -
    -
    // contracts/stakingPool.algo.ts:624
    // Global.currentApplicationAddress.minBalance
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // contracts/stakingPool.algo.ts:622-624
    // Global.currentApplicationAddress.balance -
    // this.totalAlgoStaked.value -
    // Global.currentApplicationAddress.minBalance
    -
    bury 37
    // contracts/stakingPool.algo.ts:625
    // let isPoolSaturated = false
    intc_0 // 0
    bury 27
    // contracts/stakingPool.algo.ts:1026
    // return op.onlineStake()
    online_stake
    // contracts/stakingPool.algo.ts:1013
    // return wideRatio([online, MAX_VALIDATOR_SOFT_PCT_OF_ONLINE_1DECIMAL], [1000])
    itob
    bytec 8 // 0x0002
    swap
    concat
    pushint 100 // 100
    itob
    concat
    pushint 1000 // 1000
    itob
    bury 41
    pushbytes 0x000100000000000003e8
    callsub wideRatio
    popn 2
    dup
    bury 36
    // contracts/stakingPool.algo.ts:634
    // if (validatorState.totalAlgoStaked > algoSaturationAmt) {
    swap
    pushint 14 // 14
    extract_uint64
    dup
    bury 12
    <
    bz epochBalanceUpdate_after_if_else@15
    // contracts/stakingPool.algo.ts:635
    // isPoolSaturated = true
    intc_1 // 1
    bury 26

epochBalanceUpdate_after_if_else@15:
    // contracts/stakingPool.algo.ts:641
    // let tokenRewardAvail: uint64 = 0
    intc_0 // 0
    bury 16
    // contracts/stakingPool.algo.ts:642
    // let tokenRewardPaidOut: uint64 = 0
    intc_0 // 0
    bury 14
    // contracts/stakingPool.algo.ts:643
    // let validatorCommissionPaidOut: uint64 = 0
    intc_0 // 0
    bury 13
    // contracts/stakingPool.algo.ts:644
    // let excessToFeeSink: uint64 = 0
    intc_0 // 0
    bury 29
    // contracts/stakingPool.algo.ts:645
    // if (isTokenEligible) {
    dig 2
    bz epochBalanceUpdate_after_if_else@19
    // contracts/stakingPool.algo.ts:647
    // op.AssetHolding.assetBalance(poolOneAddress, validatorConfig.rewardTokenId)[0] -
    dup
    dig 3
    asset_holding_get AssetBalance
    pop
    // contracts/stakingPool.algo.ts:647-648
    // op.AssetHolding.assetBalance(poolOneAddress, validatorConfig.rewardTokenId)[0] -
    // op.btoi(Bytes(rewardTokenHeldBack))
    dig 21
    -
    // contracts/stakingPool.algo.ts:652
    // if (tokenRewardBal >= validatorConfig.rewardPerPayout) {
    dig 6
    pushint 165 // 165
    extract_uint64
    dup
    bury 10
    >=
    bz epochBalanceUpdate_after_if_else@19
    // contracts/stakingPool.algo.ts:658
    // const ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:658
    // const ourPoolPctOfWhole = tokenPayoutRatio.poolPctOfWhole[this.poolId.value - 1]
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    -
    dig 7
    extract 0 192
    swap
    pushint 8 // 8
    *
    pushint 8 // 8
    extract3 // on error: index access is out of bounds
    // contracts/stakingPool.algo.ts:661
    // tokenRewardAvail = wideRatio([validatorConfig.rewardPerPayout, ourPoolPctOfWhole], [1_000_000])
    dig 8
    itob
    bytec 8 // 0x0002
    swap
    concat
    swap
    concat
    bytec 18 // 0x000100000000000f4240
    callsub wideRatio
    popn 2
    bury 16

epochBalanceUpdate_after_if_else@19:
    // contracts/stakingPool.algo.ts:664
    // if (tokenRewardAvail === 0) {
    dig 15
    bnz epochBalanceUpdate_after_if_else@23
    // contracts/stakingPool.algo.ts:669
    // if (algoRewardAvail < 1_000_000) {
    dig 35
    intc 8 // 1000000
    <
    bz epochBalanceUpdate_after_if_else@23
    // contracts/stakingPool.algo.ts:670
    // log('!token&&!noalgo to pay')
    pushbytes "!token&&!noalgo to pay"
    log

epochBalanceUpdate_after_inlined_contracts/stakingPool.algo.ts::StakingPool.epochBalanceUpdate@71:
    // contracts/stakingPool.algo.ts:540
    // epochBalanceUpdate(): void {
    intc_1 // 1
    return

epochBalanceUpdate_after_if_else@23:
    // contracts/stakingPool.algo.ts:675
    // if (isPoolSaturated) {
    dig 25
    bz epochBalanceUpdate_else_body@28
    // contracts/stakingPool.algo.ts:682
    // [algoRewardAvail, validatorConfig.percentToValidator.asUint64()],
    dig 5
    pushint 177 // 177
    extract_uint32
    dig 36
    dup
    cover 2
    itob
    bytec 8 // 0x0002
    swap
    concat
    swap
    itob
    dig 1
    swap
    concat
    // contracts/stakingPool.algo.ts:683
    // [1_000_000],
    bytec 18 // 0x000100000000000f4240
    // contracts/stakingPool.algo.ts:681-684
    // const normalValidatorCommission = wideRatio(
    //     [algoRewardAvail, validatorConfig.percentToValidator.asUint64()],
    //     [1_000_000],
    // )
    callsub wideRatio
    popn 2
    swap
    // contracts/stakingPool.algo.ts:687
    // [algoRewardAvail, algoSaturationAmt],
    dig 36
    itob
    concat
    // contracts/stakingPool.algo.ts:688
    // [op.btoi(Bytes(validatorState.totalAlgoStaked))],
    dig 12
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:686-689
    // let diminishedReward = wideRatio(
    //     [algoRewardAvail, algoSaturationAmt],
    //     [op.btoi(Bytes(validatorState.totalAlgoStaked))],
    // )
    callsub wideRatio
    popn 2
    dup
    bury 34
    // contracts/stakingPool.algo.ts:691
    // if (diminishedReward > algoRewardAvail - normalValidatorCommission) {
    cover 2
    -
    dup
    bury 32
    >
    bz epochBalanceUpdate_after_if_else@26
    dig 29
    bury 31

epochBalanceUpdate_after_if_else@26:
    // contracts/stakingPool.algo.ts:695
    // excessToFeeSink = algoRewardAvail - diminishedReward
    dig 35
    dig 31
    dup
    cover 2
    -
    dup
    bury 31
    // contracts/stakingPool.algo.ts:696-700
    // itxn.payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:698
    // receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    txn FirstValid
    intc_1 // 1
    -
    block BlkFeeSink
    // contracts/stakingPool.algo.ts:699
    // note: 'pool saturated, excess to fee sink',
    pushbytes "pool saturated, excess to fee sink"
    itxn_field Note
    itxn_field Receiver
    itxn_field Amount
    // contracts/stakingPool.algo.ts:696-700
    // itxn.payment({
    //     amount: excessToFeeSink,
    //     receiver: op.Block.blkFeeSink(Txn.firstValid - 1),
    //     note: 'pool saturated, excess to fee sink',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    bury 36

epochBalanceUpdate_after_if_else@40:
    // contracts/stakingPool.algo.ts:750
    // let increasedStake: uint64 = 0
    intc_0 // 0
    bury 27
    // contracts/stakingPool.algo.ts:774
    // if (algoRewardAvail !== 0 || tokenRewardAvail !== 0) {
    dig 35
    bnz epochBalanceUpdate_if_body@42
    dig 15
    bz epochBalanceUpdate_after_if_else@69

epochBalanceUpdate_if_body@42:
    // contracts/stakingPool.algo.ts:775
    // let partialStakersTotalStake: uint64 = 0
    intc_0 // 0
    bury 22
    // contracts/stakingPool.algo.ts:779
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    bury 28
    dig 35
    bury 35
    dig 15
    bury 15

epochBalanceUpdate_while_top@43:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:779
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dig 27
    intc 4 // 200
    <
    bz epochBalanceUpdate_after_while@54
    // contracts/stakingPool.algo.ts:780
    // ensureBudget(400)
    pushint 400 // 400
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:781
    // const cmpStaker = clone(this.stakers.value[i])
    dig 27
    intc_2 // 64
    *
    dup
    bury 34
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:781
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 39
    // contracts/stakingPool.algo.ts:781-782
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account !== Global.zeroAddress) {
    extract 0 32
    // contracts/stakingPool.algo.ts:782
    // if (cmpStaker.account !== Global.zeroAddress) {
    global ZeroAddress
    !=
    bz epochBalanceUpdate_after_if_else@53
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:783
    // if (cmpStaker.entryRound >= thisEpochBegin) {
    dig 33
    intc_2 // 64
    box_extract
    pushint 56 // 56
    extract_uint64
    dup
    bury 13
    dig 4
    >=
    bz epochBalanceUpdate_else_body@47
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:786
    // partialStakersTotalStake += cmpStaker.balance
    dig 33
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    dig 22
    +
    bury 22

epochBalanceUpdate_after_if_else@53:
    // contracts/stakingPool.algo.ts:779
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dig 27
    intc_1 // 1
    +
    bury 28
    b epochBalanceUpdate_while_top@43

epochBalanceUpdate_else_body@47:
    // contracts/stakingPool.algo.ts:790
    // const timeInPool: uint64 = thisEpochBegin - cmpStaker.entryRound
    dig 3
    dig 12
    -
    dup
    bury 21
    // contracts/stakingPool.algo.ts:794
    // if (timeInPool < epochRoundLength) {
    dig 5
    <
    bz epochBalanceUpdate_after_if_else@53
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:795
    // partialStakersTotalStake += cmpStaker.balance
    dig 33
    intc_2 // 64
    box_extract
    pushint 32 // 32
    extract_uint64
    dup
    bury 12
    dig 22
    +
    bury 22
    // contracts/stakingPool.algo.ts:796
    // timePercentage = (timeInPool * 1000) / epochRoundLength
    dig 19
    pushint 1000 // 1000
    *
    dig 5
    /
    bury 19
    // contracts/stakingPool.algo.ts:798
    // if (tokenRewardAvail > 0) {
    dig 14
    bz epochBalanceUpdate_after_if_else@50
    // contracts/stakingPool.algo.ts:801
    // [cmpStaker.balance, origTokenReward, timePercentage],
    dig 10
    itob
    bytec 27 // 0x0003
    swap
    concat
    dig 16
    itob
    concat
    dig 19
    itob
    concat
    // contracts/stakingPool.algo.ts:802
    // [this.totalAlgoStaked.value, 1000],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:802
    // [this.totalAlgoStaked.value, 1000],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    bytec 8 // 0x0002
    swap
    concat
    dig 40
    concat
    // contracts/stakingPool.algo.ts:800-803
    // const stakerTokenReward = wideRatio(
    //     [cmpStaker.balance, origTokenReward, timePercentage],
    //     [this.totalAlgoStaked.value, 1000],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:807
    // tokenRewardAvail -= stakerTokenReward
    dig 15
    dig 1
    -
    bury 16
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:808
    // cmpStaker.rewardTokenBalance += stakerTokenReward
    dig 34
    intc_2 // 64
    box_extract
    pushint 48 // 48
    extract_uint64
    dig 1
    +
    itob
    dig 39
    swap
    replace2 48
    bury 39
    // contracts/stakingPool.algo.ts:809
    // tokenRewardPaidOut += stakerTokenReward
    dig 14
    +
    bury 14

epochBalanceUpdate_after_if_else@50:
    // contracts/stakingPool.algo.ts:813
    // [cmpStaker.balance, origAlgoReward, timePercentage],
    dig 37
    dup
    pushint 32 // 32
    extract_uint64
    dup
    itob
    bytec 27 // 0x0003
    swap
    concat
    dig 38
    itob
    concat
    dig 21
    itob
    concat
    // contracts/stakingPool.algo.ts:814
    // [this.totalAlgoStaked.value, 1000],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:814
    // [this.totalAlgoStaked.value, 1000],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    bytec 8 // 0x0002
    swap
    concat
    dig 42
    concat
    // contracts/stakingPool.algo.ts:812-815
    // const stakerReward = wideRatio(
    //     [cmpStaker.balance, origAlgoReward, timePercentage],
    //     [this.totalAlgoStaked.value, 1000],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:818
    // algoRewardAvail -= stakerReward
    dig 37
    dig 1
    -
    bury 38
    // contracts/stakingPool.algo.ts:821
    // cmpStaker.balance += stakerReward
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:822
    // cmpStaker.totalRewarded += stakerReward
    dup
    pushint 40 // 40
    extract_uint64
    dig 2
    +
    itob
    replace2 40
    // contracts/stakingPool.algo.ts:823
    // increasedStake += stakerReward
    dig 28
    uncover 2
    +
    bury 28
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:825
    // this.stakers.value[i] = clone(cmpStaker)
    dig 34
    uncover 2
    box_replace
    b epochBalanceUpdate_after_if_else@53

epochBalanceUpdate_after_while@54:
    // contracts/stakingPool.algo.ts:833
    // const newPoolTotalStake: uint64 = this.totalAlgoStaked.value - partialStakersTotalStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:833
    // const newPoolTotalStake: uint64 = this.totalAlgoStaked.value - partialStakersTotalStake
    app_global_get_ex
    assert // check GlobalState exists
    dig 22
    -
    dup
    bury 24
    // contracts/stakingPool.algo.ts:837
    // if (newPoolTotalStake > 0) {
    bz epochBalanceUpdate_after_if_else@69
    // contracts/stakingPool.algo.ts:839
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    intc_0 // 0
    bury 25

epochBalanceUpdate_while_top@56:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:839
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    box_len
    bury 1
    assert // Box must have value
    dig 24
    intc 4 // 200
    <
    bz epochBalanceUpdate_after_if_else@69
    // contracts/stakingPool.algo.ts:840
    // ensureBudget(200)
    intc 4 // 200
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:841
    // const cmpStaker = clone(this.stakers.value[i])
    dig 24
    intc_2 // 64
    *
    dup
    bury 33
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:841
    // const cmpStaker = clone(this.stakers.value[i])
    swap
    intc_2 // 64
    box_extract
    dup
    bury 38
    // contracts/stakingPool.algo.ts:841-842
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    extract 0 32
    // contracts/stakingPool.algo.ts:842
    // if (cmpStaker.account !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    global ZeroAddress
    !=
    bz epochBalanceUpdate_after_if_else@66
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:841-842
    // const cmpStaker = clone(this.stakers.value[i])
    // if (cmpStaker.account !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    dig 32
    intc_2 // 64
    box_extract
    pushint 56 // 56
    // contracts/stakingPool.algo.ts:842
    // if (cmpStaker.account !== Global.zeroAddress && cmpStaker.entryRound < thisEpochBegin) {
    extract_uint64
    dup
    bury 10
    dig 4
    <
    bz epochBalanceUpdate_after_if_else@66
    // contracts/stakingPool.algo.ts:843
    // const timeInPool: uint64 = thisEpochBegin - cmpStaker.entryRound
    dig 3
    dig 9
    -
    // contracts/stakingPool.algo.ts:845
    // if (timeInPool >= epochRoundLength) {
    dig 5
    >=
    bz epochBalanceUpdate_after_if_else@66
    // contracts/stakingPool.algo.ts:850
    // if (tokenRewardAvail > 0) {
    dig 14
    bz epochBalanceUpdate_after_if_else@62
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:852
    // [cmpStaker.balance, tokenRewardAvail],
    dig 32
    dup
    cover 2
    intc_2 // 64
    box_extract
    extract 32 8
    bytec 8 // 0x0002
    swap
    concat
    dig 16
    itob
    concat
    // contracts/stakingPool.algo.ts:853
    // [newPoolTotalStake],
    dig 24
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:851-854
    // const stakerTokenReward = wideRatio(
    //     [cmpStaker.balance, tokenRewardAvail],
    //     [newPoolTotalStake],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:856
    // cmpStaker.rewardTokenBalance += stakerTokenReward
    uncover 2
    intc_2 // 64
    box_extract
    pushint 48 // 48
    extract_uint64
    dig 1
    +
    itob
    dig 38
    swap
    replace2 48
    bury 38
    // contracts/stakingPool.algo.ts:857
    // tokenRewardPaidOut += stakerTokenReward
    dig 14
    +
    bury 14

epochBalanceUpdate_after_if_else@62:
    // contracts/stakingPool.algo.ts:859
    // if (algoRewardAvail > 0) {
    dig 34
    bz epochBalanceUpdate_after_if_else@64
    // contracts/stakingPool.algo.ts:861
    // [cmpStaker.balance, algoRewardAvail],
    dig 36
    dup
    pushint 32 // 32
    extract_uint64
    dup
    itob
    bytec 8 // 0x0002
    swap
    concat
    dig 37
    itob
    concat
    // contracts/stakingPool.algo.ts:862
    // [newPoolTotalStake],
    dig 25
    itob
    bytec 19 // 0x0001
    swap
    concat
    // contracts/stakingPool.algo.ts:860-863
    // const stakerReward = wideRatio(
    //     [cmpStaker.balance, algoRewardAvail],
    //     [newPoolTotalStake],
    // )
    callsub wideRatio
    popn 2
    // contracts/stakingPool.algo.ts:866
    // cmpStaker.balance += stakerReward
    swap
    dig 1
    +
    itob
    uncover 2
    swap
    replace2 32
    // contracts/stakingPool.algo.ts:867
    // cmpStaker.totalRewarded += stakerReward
    dup
    pushint 40 // 40
    extract_uint64
    dig 2
    +
    itob
    replace2 40
    bury 38
    // contracts/stakingPool.algo.ts:868
    // increasedStake += stakerReward
    dig 27
    +
    bury 27

epochBalanceUpdate_after_if_else@64:
    // contracts/stakingPool.algo.ts:93
    // stakers = Box<FixedArray<StakedInfo, typeof MAX_STAKERS_PER_POOL>>({ key: 'stakers' })
    bytec_0 // "stakers"
    // contracts/stakingPool.algo.ts:872
    // this.stakers.value[i] = clone(cmpStaker)
    dig 32
    dig 38
    box_replace

epochBalanceUpdate_after_if_else@66:
    // contracts/stakingPool.algo.ts:839
    // for (let i: uint64 = 0; i < this.stakers.value.length; i += 1) {
    dig 24
    intc_1 // 1
    +
    bury 25
    b epochBalanceUpdate_while_top@56

epochBalanceUpdate_after_if_else@69:
    // contracts/stakingPool.algo.ts:882
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:99
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:882
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:882
    // const roundsLeftInBin: uint64 = this.binRoundStart.value + this.roundsPerDay.value - Global.round
    app_global_get_ex
    assert // check GlobalState exists
    +
    global Round
    -
    // contracts/stakingPool.algo.ts:883
    // this.totalAlgoStaked.value += increasedStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:883
    // this.totalAlgoStaked.value += increasedStake
    app_global_get_ex
    assert // check GlobalState exists
    dig 28
    dup
    cover 2
    +
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:883
    // this.totalAlgoStaked.value += increasedStake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:885
    // this.stakeAccumulator.value.asBigUint() + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:885
    // this.stakeAccumulator.value.asBigUint() + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    itob
    uncover 3
    itob
    dig 1
    b*
    uncover 2
    b+
    // contracts/stakingPool.algo.ts:884-886
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.asBigUint() + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:884-886
    // this.stakeAccumulator.value = new Uint128(
    //     this.stakeAccumulator.value.asBigUint() + BigUint(increasedStake) * BigUint(roundsLeftInBin),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:887
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    intc_0 // 0
    // contracts/stakingPool.algo.ts:108
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:887
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    // contracts/stakingPool.algo.ts:108
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:887
    // this.rewardAccumulator.value = this.rewardAccumulator.value + increasedStake
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:893-902
    // abiCall<typeof ValidatorRegistry.prototype.stakeUpdatedViaRewards>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //         increasedStake,
    //         tokenRewardPaidOut,
    //         validatorCommissionPaidOut,
    //         excessToFeeSink,
    //     ],
    // })
    itxn_begin
    // contracts/stakingPool.algo.ts:894
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:894
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:896
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:896
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:896
    // { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    app_global_get_ex
    assert // check GlobalState exists
    global CurrentApplicationID
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:898
    // tokenRewardPaidOut,
    dig 16
    itob
    // contracts/stakingPool.algo.ts:899
    // validatorCommissionPaidOut,
    dig 16
    itob
    // contracts/stakingPool.algo.ts:900
    // excessToFeeSink,
    dig 33
    itob
    // contracts/stakingPool.algo.ts:893-902
    // abiCall<typeof ValidatorRegistry.prototype.stakeUpdatedViaRewards>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [
    //         { id: this.validatorId.value, poolId: this.poolId.value, poolAppId: Global.currentApplicationId.id },
    //         increasedStake,
    //         tokenRewardPaidOut,
    //         validatorCommissionPaidOut,
    //         excessToFeeSink,
    //     ],
    // })
    pushbytes 0x418fcefc // method "stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void"
    itxn_field ApplicationArgs
    uncover 3
    itxn_field ApplicationArgs
    uncover 4
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:540
    // epochBalanceUpdate(): void {
    b epochBalanceUpdate_after_inlined_contracts/stakingPool.algo.ts::StakingPool.epochBalanceUpdate@71

epochBalanceUpdate_else_body@28:
    // contracts/stakingPool.algo.ts:703
    // } else if (validatorConfig.percentToValidator.asUint64() !== 0) {
    dig 5
    pushint 177 // 177
    extract_uint32
    dup
    bury 19
    bz epochBalanceUpdate_after_if_else@40
    // contracts/stakingPool.algo.ts:707
    // [algoRewardAvail, validatorConfig.percentToValidator.asUint64()],
    dig 35
    dup
    itob
    bytec 8 // 0x0002
    swap
    concat
    dig 19
    itob
    concat
    // contracts/stakingPool.algo.ts:708
    // [1_000_000],
    bytec 18 // 0x000100000000000f4240
    // contracts/stakingPool.algo.ts:706-709
    // validatorCommissionPaidOut = wideRatio(
    //     [algoRewardAvail, validatorConfig.percentToValidator.asUint64()],
    //     [1_000_000],
    // )
    callsub wideRatio
    popn 2
    dup
    bury 15
    // contracts/stakingPool.algo.ts:712
    // algoRewardAvail -= validatorCommissionPaidOut
    swap
    dig 1
    -
    bury 37
    // contracts/stakingPool.algo.ts:719
    // if (validatorCommissionPaidOut > 0) {
    bz epochBalanceUpdate_after_if_else@40
    // contracts/stakingPool.algo.ts:722
    // let managerTopOff: uint64 = 0
    intc_0 // 0
    bury 24
    // contracts/stakingPool.algo.ts:724
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    dig 5
    dup
    extract 44 32
    dup
    cover 2
    bury 43
    extract 181 32
    dup
    bury 42
    !=
    // contracts/stakingPool.algo.ts:724-725
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    // validatorConfig.manager.balance - validatorConfig.manager.minBalance < 2_100_000
    bz epochBalanceUpdate_after_if_else@34
    // contracts/stakingPool.algo.ts:725
    // validatorConfig.manager.balance - validatorConfig.manager.minBalance < 2_100_000
    dig 40
    dup
    acct_params_get AcctBalance
    assert // account funded
    swap
    acct_params_get AcctMinBalance
    assert // account funded
    -
    intc 7 // 2100000
    <
    // contracts/stakingPool.algo.ts:724-725
    // validatorConfig.manager !== validatorConfig.validatorCommissionAddress &&
    // validatorConfig.manager.balance - validatorConfig.manager.minBalance < 2_100_000
    bz epochBalanceUpdate_after_if_else@34
    // contracts/stakingPool.algo.ts:727
    // managerTopOff = validatorCommissionPaidOut < 2_100_000 ? validatorCommissionPaidOut : 2_100_000
    dig 12
    dup
    intc 7 // 2100000
    <
    intc 7 // 2100000
    cover 2
    select
    dup
    bury 25
    // contracts/stakingPool.algo.ts:728-732
    // itxn.payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager,
    //     note: 'validator reward to manager for funding epoch updates',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:731
    // note: 'validator reward to manager for funding epoch updates',
    pushbytes "validator reward to manager for funding epoch updates"
    itxn_field Note
    dig 41
    itxn_field Receiver
    itxn_field Amount
    // contracts/stakingPool.algo.ts:728-732
    // itxn.payment({
    //     amount: managerTopOff,
    //     receiver: validatorConfig.manager,
    //     note: 'validator reward to manager for funding epoch updates',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit

epochBalanceUpdate_after_if_else@34:
    // contracts/stakingPool.algo.ts:734
    // if (validatorCommissionPaidOut - managerTopOff > 0) {
    dig 12
    dig 24
    -
    dup
    bury 18
    bz epochBalanceUpdate_after_if_else@40
    // contracts/stakingPool.algo.ts:735-739
    // itxn.payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress,
    //     note: 'validator reward',
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:738
    // note: 'validator reward',
    pushbytes "validator reward"
    itxn_field Note
    dig 39
    itxn_field Receiver
    dig 16
    itxn_field Amount
    // contracts/stakingPool.algo.ts:735-739
    // itxn.payment({
    //     amount: validatorCommissionPaidOut - managerTopOff,
    //     receiver: validatorConfig.validatorCommissionAddress,
    //     note: 'validator reward',
    // }).submit()
    intc_1 // 1
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    b epochBalanceUpdate_after_if_else@40

epochBalanceUpdate_else_body@9:
    // contracts/stakingPool.algo.ts:596-605
    // tokenPayoutRatio = abiCall<typeof StakingPool.prototype.proxiedSetTokenPayoutRatio>({
    //     appId: Application(poolOneAppID),
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //     ],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:600
    // id: this.validatorId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:600
    // id: this.validatorId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:601
    // poolId: this.poolId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:601
    // poolId: this.poolId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:602
    // poolAppId: Global.currentApplicationId.id,
    global CurrentApplicationID
    // contracts/stakingPool.algo.ts:599-603
    // {
    //     id: this.validatorId.value,
    //     poolId: this.poolId.value,
    //     poolAppId: Global.currentApplicationId.id,
    // },
    uncover 2
    itob
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // contracts/stakingPool.algo.ts:596-605
    // tokenPayoutRatio = abiCall<typeof StakingPool.prototype.proxiedSetTokenPayoutRatio>({
    //     appId: Application(poolOneAppID),
    //     args: [
    //         {
    //             id: this.validatorId.value,
    //             poolId: this.poolId.value,
    //             poolAppId: Global.currentApplicationId.id,
    //         },
    //     ],
    // }).returnValue
    bytec 20 // method "proxiedSetTokenPayoutRatio((uint64,uint64,uint64))(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    dig 1
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    bury 8
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    b epochBalanceUpdate_after_if_else@12


// contracts/stakingPool.algo.ts::StakingPool.goOnline[routing]() -> void:
goOnline:
    // contracts/stakingPool.algo.ts:918-926
    // goOnline(
    //     feePayment: gtxn.PaymentTxn,
    //     votePK: bytes<32>,
    //     selectionPK: bytes<32>,
    //     stateProofPK: bytes<64>,
    //     voteFirst: uint64,
    //     voteLast: uint64,
    //     voteKeyDilution: uint64,
    // ): void {
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    // contracts/stakingPool.algo.ts:927
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:1019
    // if (!op.AcctParams.acctIncentiveEligible(Global.currentApplicationAddress)[0]) {
    global CurrentApplicationAddress
    acct_params_get AcctIncentiveEligible
    pop
    bnz goOnline_after_if_else@3
    // contracts/stakingPool.algo.ts:1020
    // return Global.payoutsGoOnlineFee
    global PayoutsGoOnlineFee

goOnline_after_inlined_contracts/stakingPool.algo.ts::StakingPool.getGoOnlineFee@4:
    // contracts/stakingPool.algo.ts:929
    // assertMatch(feePayment, { receiver: Global.currentApplicationAddress, amount: extraFee })
    dig 7
    dup
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    swap
    gtxns Amount
    dig 2
    ==
    &&
    assert // assert target is match for conditions
    // contracts/stakingPool.algo.ts:930-938
    // itxn.keyRegistration({
    //     voteKey: votePK,
    //     selectionKey: selectionPK,
    //     stateProofKey: stateProofPK,
    //     voteFirst: voteFirst,
    //     voteLast: voteLast,
    //     voteKeyDilution: voteKeyDilution,
    //     fee: extraFee,
    // }).submit()
    itxn_begin
    dig 1
    itxn_field VoteKeyDilution
    dig 2
    itxn_field VoteLast
    dig 3
    itxn_field VoteFirst
    dig 4
    itxn_field StateProofPK
    dig 5
    itxn_field SelectionPK
    dig 6
    itxn_field VotePK
    pushint 2 // 2
    itxn_field TypeEnum
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:918-926
    // goOnline(
    //     feePayment: gtxn.PaymentTxn,
    //     votePK: bytes<32>,
    //     selectionPK: bytes<32>,
    //     stateProofPK: bytes<64>,
    //     voteFirst: uint64,
    //     voteLast: uint64,
    //     voteKeyDilution: uint64,
    // ): void {
    intc_1 // 1
    return

goOnline_after_if_else@3:
    // contracts/stakingPool.algo.ts:1022
    // return 0
    intc_0 // 0
    // contracts/stakingPool.algo.ts:928
    // const extraFee = this.getGoOnlineFee()
    b goOnline_after_inlined_contracts/stakingPool.algo.ts::StakingPool.getGoOnlineFee@4


// contracts/stakingPool.algo.ts::StakingPool.goOffline[routing]() -> void:
goOffline:
    // contracts/stakingPool.algo.ts:949
    // if (Txn.sender !== Application(this.creatingValidatorContractAppId.value).address) {
    txn Sender
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:949
    // if (Txn.sender !== Application(this.creatingValidatorContractAppId.value).address) {
    app_global_get_ex
    assert // check GlobalState exists
    app_params_get AppAddress
    assert // application exists
    !=
    bz goOffline_after_if_else@3
    // contracts/stakingPool.algo.ts:950
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator

goOffline_after_if_else@3:
    // contracts/stakingPool.algo.ts:953
    // itxn.keyRegistration({}).submit()
    itxn_begin
    pushint 2 // 2
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:946
    // goOffline(): void {
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.linkToNFD[routing]() -> void:
linkToNFD:
    // contracts/stakingPool.algo.ts:959
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    extract 2 0
    // contracts/stakingPool.algo.ts:960
    // assert(this.isOwnerOrManagerCaller(), 'can only be called by owner or manager of validator')
    callsub isOwnerOrManagerCaller
    assert // can only be called by owner or manager of validator
    // contracts/stakingPool.algo.ts:962-971
    // itxn.applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //         Bytes('verify_nfd_addr'),
    //         Bytes(nfdName),
    //         op.itob(nfdAppId),
    //         encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    // }).submit()
    itxn_begin
    // contracts/stakingPool.algo.ts:963
    // appId: Application(nfdRegistryAppId),
    intc 10 // TMPL_NFD_REGISTRY_APP_ID
    swap
    // contracts/stakingPool.algo.ts:967
    // op.itob(nfdAppId),
    dig 2
    itob
    // contracts/stakingPool.algo.ts:968
    // encodeArc4(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    uncover 4
    itxn_field Applications
    // contracts/stakingPool.algo.ts:965
    // Bytes('verify_nfd_addr'),
    pushbytes "verify_nfd_addr"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // contracts/stakingPool.algo.ts:962-971
    // itxn.applicationCall({
    //     appId: Application(nfdRegistryAppId),
    //     appArgs: [
    //         Bytes('verify_nfd_addr'),
    //         Bytes(nfdName),
    //         op.itob(nfdAppId),
    //         encodeArc4(Global.currentApplicationAddress),
    //     ],
    //     apps: [Application(nfdAppId)],
    // }).submit()
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    // contracts/stakingPool.algo.ts:959
    // linkToNFD(nfdAppId: uint64, nfdName: string): void {
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.proxiedSetTokenPayoutRatio[routing]() -> void:
proxiedSetTokenPayoutRatio:
    // contracts/stakingPool.algo.ts:980
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    txna ApplicationArgs 1
    // contracts/stakingPool.algo.ts:981
    // assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:981
    // assert(this.validatorId.value === poolKey.id, 'caller must be part of same validator set!')
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    extract 0 8
    dig 2
    intc_0 // 0
    extract_uint64
    dig 2
    ==
    assert // caller must be part of same validator set!
    // contracts/stakingPool.algo.ts:982
    // assert(this.poolId.value === 1, 'callee must be pool 1')
    intc_0 // 0
    // contracts/stakingPool.algo.ts:73
    // poolId = GlobalState<uint64>({ key: 'poolId' })
    bytec_3 // "poolId"
    // contracts/stakingPool.algo.ts:982
    // assert(this.poolId.value === 1, 'callee must be pool 1')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // callee must be pool 1
    // contracts/stakingPool.algo.ts:983
    // assert(poolKey.poolId !== 1, 'caller must NOT be pool 1')
    dig 2
    extract 8 8
    dig 3
    pushint 8 // 8
    extract_uint64
    intc_1 // 1
    !=
    assert // caller must NOT be pool 1
    // contracts/stakingPool.algo.ts:985-988
    // const callerPoolAppID = abiCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [poolKey.id, poolKey.poolId],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:986
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:986
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:985-988
    // const callerPoolAppID = abiCall<typeof ValidatorRegistry.prototype.getPoolAppId>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [poolKey.id, poolKey.poolId],
    // }).returnValue
    bytec 25 // method "getPoolAppId(uint64,uint64)uint64"
    itxn_field ApplicationArgs
    uncover 2
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    dup
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    btoi
    // contracts/stakingPool.algo.ts:989
    // assert(callerPoolAppID === poolKey.poolAppId)
    uncover 3
    intc_3 // 16
    extract_uint64
    swap
    dig 1
    ==
    assert
    // contracts/stakingPool.algo.ts:990
    // assert(Txn.sender === Application(poolKey.poolAppId).address)
    txn Sender
    swap
    app_params_get AppAddress
    assert // application exists
    ==
    assert
    // contracts/stakingPool.algo.ts:992-995
    // return abiCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:994
    // args: [this.validatorId.value],
    swap
    itob
    // contracts/stakingPool.algo.ts:992-995
    // return abiCall<typeof ValidatorRegistry.prototype.setTokenPayoutRatio>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    bytec 26 // method "setTokenPayoutRatio(uint64)(uint64[24],uint64)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dup
    extract 4 0
    swap
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:980
    // proxiedSetTokenPayoutRatio(poolKey: ValidatorPoolKey): PoolTokenPayoutRatio {
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// contracts/stakingPool.algo.ts::StakingPool.isOwnerOrManagerCaller() -> uint64:
isOwnerOrManagerCaller:
    // contracts/stakingPool.algo.ts:998
    // private isOwnerOrManagerCaller(): boolean {
    proto 0 1
    // contracts/stakingPool.algo.ts:999-1002
    // const OwnerAndManager = abiCall<typeof ValidatorRegistry.prototype.getValidatorOwnerAndManager>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    itxn_begin
    // contracts/stakingPool.algo.ts:1000
    // appId: this.creatingValidatorContractAppId.value,
    intc_0 // 0
    // contracts/stakingPool.algo.ts:67
    // creatingValidatorContractAppId = GlobalState<uint64>({ key: 'creatorApp' })
    bytec_1 // "creatorApp"
    // contracts/stakingPool.algo.ts:1000
    // appId: this.creatingValidatorContractAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:1001
    // args: [this.validatorId.value],
    intc_0 // 0
    // contracts/stakingPool.algo.ts:70
    // validatorId = GlobalState<uint64>({ key: 'validatorId' })
    bytec_2 // "validatorId"
    // contracts/stakingPool.algo.ts:1001
    // args: [this.validatorId.value],
    app_global_get_ex
    assert // check GlobalState exists
    itob
    // contracts/stakingPool.algo.ts:999-1002
    // const OwnerAndManager = abiCall<typeof ValidatorRegistry.prototype.getValidatorOwnerAndManager>({
    //     appId: this.creatingValidatorContractAppId.value,
    //     args: [this.validatorId.value],
    // }).returnValue
    pushbytes 0x2fa22c4b // method "getValidatorOwnerAndManager(uint64)(address,address)"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    itxn_submit
    itxn LastLog
    dupn 2
    extract 0 4
    bytec 4 // 0x151f7c75
    ==
    assert // Bytes has valid prefix
    // contracts/stakingPool.algo.ts:1003
    // return Txn.sender === OwnerAndManager[0] || Txn.sender === OwnerAndManager[1]
    txn Sender
    swap
    extract 4 32
    ==
    bnz isOwnerOrManagerCaller_bool_true@3
    txn Sender
    frame_dig 0
    extract 36 32
    ==
    bz isOwnerOrManagerCaller_bool_false@4

isOwnerOrManagerCaller_bool_true@3:
    intc_1 // 1

isOwnerOrManagerCaller_bool_merge@5:
    // contracts/stakingPool.algo.ts:1003
    // return Txn.sender === OwnerAndManager[0] || Txn.sender === OwnerAndManager[1]
    swap
    retsub

isOwnerOrManagerCaller_bool_false@4:
    intc_0 // 0
    b isOwnerOrManagerCaller_bool_merge@5


// contracts/stakingPool.algo.ts::StakingPool.checkIfBinClosed() -> void:
checkIfBinClosed:
    // contracts/stakingPool.algo.ts:1032
    // private checkIfBinClosed() {
    proto 0 0
    intc_0 // 0
    // contracts/stakingPool.algo.ts:1033
    // const currentBinSize = this.roundsPerDay.value
    dupn 5
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1033
    // const currentBinSize = this.roundsPerDay.value
    app_global_get_ex
    swap
    dup
    uncover 2
    assert // check GlobalState exists
    // contracts/stakingPool.algo.ts:1034
    // if (Global.round >= this.binRoundStart.value + currentBinSize) {
    global Round
    intc_0 // 0
    // contracts/stakingPool.algo.ts:99
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:1034
    // if (Global.round >= this.binRoundStart.value + currentBinSize) {
    app_global_get_ex
    assert // check GlobalState exists
    uncover 2
    +
    >=
    bz checkIfBinClosed_after_if_else@9
    // contracts/stakingPool.algo.ts:1035
    // ensureBudget(300)
    intc 6 // 300
    intc_0 // 0
    callsub ensure_budget
    // contracts/stakingPool.algo.ts:1036
    // const approxRoundsPerYear = BigUint(currentBinSize * 365)
    frame_dig 5
    dup
    pushint 365 // 365
    *
    itob
    frame_bury 1
    // contracts/stakingPool.algo.ts:1037
    // const avgStake = BigUint(this.stakeAccumulator.value.asBigUint() / BigUint(currentBinSize))
    intc_0 // 0
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:1037
    // const avgStake = BigUint(this.stakeAccumulator.value.asBigUint() / BigUint(currentBinSize))
    app_global_get_ex
    assert // check GlobalState exists
    swap
    itob
    dup
    frame_bury 4
    b/
    dup
    frame_bury 3
    // contracts/stakingPool.algo.ts:1038
    // if (avgStake !== 0n) {
    pushbytes 0x
    b!=
    bz checkIfBinClosed_after_if_else@8
    // contracts/stakingPool.algo.ts:1044
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    intc_0 // 0
    // contracts/stakingPool.algo.ts:108
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:1044
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    app_global_get_ex
    assert // check GlobalState exists
    itob
    pushbytes 0x0f4240
    b*
    frame_dig 3
    dup
    cover 2
    b/
    // contracts/stakingPool.algo.ts:1045
    // (approxRoundsPerYear / BigUint(currentBinSize))) /
    frame_dig 1
    frame_dig 4
    b/
    // contracts/stakingPool.algo.ts:1044-1045
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    //     (approxRoundsPerYear / BigUint(currentBinSize))) /
    b*
    // contracts/stakingPool.algo.ts:1046
    // 100n,
    bytec 14 // 0x64
    // contracts/stakingPool.algo.ts:1044-1046
    // (((BigUint(this.rewardAccumulator.value) * 1000000n) / avgStake) *
    //     (approxRoundsPerYear / BigUint(currentBinSize))) /
    //     100n,
    b/
    frame_bury 2
    // contracts/stakingPool.algo.ts:1049
    // let alpha = BigUint(10) // .1
    pushbytes 0x0a
    frame_bury 0
    // contracts/stakingPool.algo.ts:1051
    // if (avgStake > 300000000000n) {
    pushbytes 0x45d964b800
    b>
    bz checkIfBinClosed_after_if_else@4
    // contracts/stakingPool.algo.ts:1052
    // alpha = BigUint(90) // .9
    pushbytes 0x5a
    frame_bury 0

checkIfBinClosed_after_if_else@4:
    // contracts/stakingPool.algo.ts:1056
    // if (this.weightedMovingAverage.value.asBigUint() === 0n) {
    intc_0 // 0
    // contracts/stakingPool.algo.ts:111
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1056
    // if (this.weightedMovingAverage.value.asBigUint() === 0n) {
    app_global_get_ex
    assert // check GlobalState exists
    pushbytes 0x
    b==
    bz checkIfBinClosed_else_body@6
    // contracts/stakingPool.algo.ts:1057
    // this.weightedMovingAverage.value = new Uint128(apr)
    frame_dig 2
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:111
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1057
    // this.weightedMovingAverage.value = new Uint128(apr)
    swap
    app_global_put

checkIfBinClosed_after_if_else@8:
    // contracts/stakingPool.algo.ts:1067
    // this.setRoundsPerDay()
    callsub setRoundsPerDay
    // contracts/stakingPool.algo.ts:1069
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    intc_0 // 0
    // contracts/stakingPool.algo.ts:79
    // totalAlgoStaked = GlobalState<uint64>({ key: 'staked' })
    bytec 5 // "staked"
    // contracts/stakingPool.algo.ts:1069
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    app_global_get_ex
    assert // check GlobalState exists
    itob
    intc_0 // 0
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1069
    // BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    app_global_get_ex
    assert // check GlobalState exists
    itob
    b*
    // contracts/stakingPool.algo.ts:1068-1070
    // this.stakeAccumulator.value = new Uint128(
    //     BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:104
    // stakeAccumulator = GlobalState<Uint128>({ key: 'stakeAccumulator' })
    bytec 7 // "stakeAccumulator"
    // contracts/stakingPool.algo.ts:1068-1070
    // this.stakeAccumulator.value = new Uint128(
    //     BigUint(this.totalAlgoStaked.value) * BigUint(this.roundsPerDay.value),
    // )
    swap
    app_global_put
    // contracts/stakingPool.algo.ts:108
    // rewardAccumulator = GlobalState<uint64>({ key: 'rewardAccumulator' })
    bytec 11 // "rewardAccumulator"
    // contracts/stakingPool.algo.ts:1071
    // this.rewardAccumulator.value = 0
    intc_0 // 0
    app_global_put
    // contracts/stakingPool.algo.ts:1072
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    global Round
    dup
    intc_0 // 0
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1072
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    app_global_get_ex
    assert // check GlobalState exists
    %
    -
    // contracts/stakingPool.algo.ts:99
    // binRoundStart = GlobalState<uint64>({ key: 'binRoundStart' })
    bytec 9 // "binRoundStart"
    // contracts/stakingPool.algo.ts:1072
    // this.binRoundStart.value = Global.round - (Global.round % this.roundsPerDay.value)
    swap
    app_global_put

checkIfBinClosed_after_if_else@9:
    retsub

checkIfBinClosed_else_body@6:
    // contracts/stakingPool.algo.ts:1060
    // (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    intc_0 // 0
    // contracts/stakingPool.algo.ts:111
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1060
    // (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    app_global_get_ex
    assert // check GlobalState exists
    bytec 14 // 0x64
    frame_dig 0
    dup
    cover 3
    b-
    b*
    bytec 14 // 0x64
    b/
    // contracts/stakingPool.algo.ts:1061
    // (apr * alpha) / BigUint(100),
    frame_dig 2
    uncover 2
    b*
    bytec 14 // 0x64
    b/
    // contracts/stakingPool.algo.ts:1060-1061
    // (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    //     (apr * alpha) / BigUint(100),
    b+
    // contracts/stakingPool.algo.ts:1059-1062
    // this.weightedMovingAverage.value = new Uint128(
    //     (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    //         (apr * alpha) / BigUint(100),
    // )
    dup
    len
    intc_3 // 16
    <=
    assert // overflow
    intc_3 // 16
    bzero
    b|
    // contracts/stakingPool.algo.ts:111
    // weightedMovingAverage = GlobalState<Uint128>({ key: 'ewma' })
    bytec 12 // "ewma"
    // contracts/stakingPool.algo.ts:1059-1062
    // this.weightedMovingAverage.value = new Uint128(
    //     (this.weightedMovingAverage.value.asBigUint() * (BigUint(100) - alpha)) / BigUint(100) +
    //         (apr * alpha) / BigUint(100),
    // )
    swap
    app_global_put
    b checkIfBinClosed_after_if_else@8


// contracts/stakingPool.algo.ts::StakingPool.setRoundsPerDay() -> void:
setRoundsPerDay:
    // contracts/stakingPool.algo.ts:1076
    // private setRoundsPerDay() {
    proto 0 0
    pushbytes ""
    // contracts/stakingPool.algo.ts:1081
    // if (Txn.firstValid < 12) {
    txn FirstValid
    pushint 12 // 12
    <
    bz setRoundsPerDay_after_if_else@2
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1083
    // this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
    intc 9 // 30857
    app_global_put
    // contracts/stakingPool.algo.ts:1084
    // return
    retsub

setRoundsPerDay_after_if_else@2:
    // contracts/stakingPool.algo.ts:1088
    // op.Block.blkTimestamp(Txn.firstValid - 1) - op.Block.blkTimestamp(Txn.firstValid - 11)
    txn FirstValid
    intc_1 // 1
    -
    block BlkTimestamp
    txn FirstValid
    pushint 11 // 11
    -
    block BlkTimestamp
    -
    dup
    frame_bury 0
    // contracts/stakingPool.algo.ts:1089
    // if (avgBlockTimeTenths === 0) {
    bnz setRoundsPerDay_after_if_else@4
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1091
    // this.roundsPerDay.value = APPROX_AVG_ROUNDS_PER_DAY
    intc 9 // 30857
    app_global_put
    // contracts/stakingPool.algo.ts:1092
    // return
    retsub

setRoundsPerDay_after_if_else@4:
    // contracts/stakingPool.algo.ts:1097
    // this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
    pushint 864000 // 864000
    frame_dig 0
    /
    // contracts/stakingPool.algo.ts:97
    // roundsPerDay = GlobalState<uint64>({ key: 'roundsPerDay' })
    bytec 6 // "roundsPerDay"
    // contracts/stakingPool.algo.ts:1097
    // this.roundsPerDay.value = (24 * 60 * 60 * 10) / avgBlockTimeTenths
    swap
    app_global_put
    retsub
