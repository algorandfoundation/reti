/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'

export const APP_SPEC: Arc56Contract = {"name":"ValidatorRegistry","structs":{"Constraints":[{"name":"epochPayoutRoundsMin","type":"uint64"},{"name":"epochPayoutRoundsMax","type":"uint64"},{"name":"minPctToValidatorWFourDecimals","type":"uint64"},{"name":"maxPctToValidatorWFourDecimals","type":"uint64"},{"name":"minEntryStake","type":"uint64"},{"name":"maxAlgoPerPool","type":"uint64"},{"name":"maxAlgoPerValidator","type":"uint64"},{"name":"amtConsideredSaturated","type":"uint64"},{"name":"maxNodes","type":"uint64"},{"name":"maxPoolsPerNode","type":"uint64"},{"name":"maxStakersPerPool","type":"uint64"}],"MbrAmounts":[{"name":"addValidatorMbr","type":"uint64"},{"name":"addPoolMbr","type":"uint64"},{"name":"poolInitMbr","type":"uint64"},{"name":"addStakerMbr","type":"uint64"}],"NodePoolAssignmentConfig":[{"name":"nodes","type":"(uint64[3])[8]"}],"PoolInfo":[{"name":"poolAppId","type":"uint64"},{"name":"totalStakers","type":"uint16"},{"name":"totalAlgoStaked","type":"uint64"}],"PoolTokenPayoutRatio":[{"name":"poolPctOfWhole","type":"uint64[24]"},{"name":"updatedForPayout","type":"uint64"}],"ValidatorConfig":[{"name":"id","type":"uint64"},{"name":"owner","type":"address"},{"name":"manager","type":"address"},{"name":"nfdForInfo","type":"uint64"},{"name":"entryGatingType","type":"uint8"},{"name":"entryGatingAddress","type":"address"},{"name":"entryGatingAssets","type":"uint64[4]"},{"name":"gatingAssetMinBalance","type":"uint64"},{"name":"rewardTokenId","type":"uint64"},{"name":"rewardPerPayout","type":"uint64"},{"name":"epochRoundLength","type":"uint32"},{"name":"percentToValidator","type":"uint32"},{"name":"validatorCommissionAddress","type":"address"},{"name":"minEntryStake","type":"uint64"},{"name":"maxAlgoPerPool","type":"uint64"},{"name":"poolsPerNode","type":"uint8"},{"name":"sunsettingOn","type":"uint64"},{"name":"sunsettingTo","type":"uint64"}],"ValidatorCurState":[{"name":"numPools","type":"uint16"},{"name":"totalStakers","type":"uint64"},{"name":"totalAlgoStaked","type":"uint64"},{"name":"rewardTokenHeldBack","type":"uint64"}],"ValidatorInfo":[{"name":"config","type":"ValidatorConfig"},{"name":"state","type":"ValidatorCurState"},{"name":"pools","type":"(uint64,uint16,uint64)[24]"},{"name":"tokenPayoutRatio","type":"PoolTokenPayoutRatio"},{"name":"nodePoolAssignments","type":"NodePoolAssignmentConfig"}],"ValidatorPoolKey":[{"name":"id","type":"uint64"},{"name":"poolId","type":"uint64"},{"name":"poolAppId","type":"uint64"}]},"methods":[{"name":"createApplication","args":[],"returns":{"type":"void"},"actions":{"create":["NoOp"],"call":[]},"readonly":false,"events":[],"recommendations":{}},{"name":"initStakingContract","args":[{"type":"uint64","name":"approvalProgramSize"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"loadStakingContractData","args":[{"type":"uint64","name":"offset"},{"type":"byte[]","name":"data"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"finalizeStakingContract","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"events":[],"recommendations":{}},{"name":"gas","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"gas is a dummy no-op call that can be used to pool-up resource references and opcode cost","events":[],"recommendations":{}},{"name":"getMbrAmounts","args":[],"returns":{"type":"(uint64,uint64,uint64,uint64)","struct":"MbrAmounts"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Returns the MBR amounts needed for various actions:\n[\n addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract\n addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator\n poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself\n addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)\n]","events":[],"recommendations":{}},{"name":"getProtocolConstraints","args":[],"returns":{"type":"(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)","struct":"Constraints"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.","events":[],"recommendations":{}},{"name":"getNumValidators","args":[],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Returns the current number of validators","events":[],"recommendations":{}},{"name":"getValidatorConfig","args":[{"type":"uint64","name":"validatorId"}],"returns":{"type":"(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)","struct":"ValidatorConfig"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getValidatorState","args":[{"type":"uint64","name":"validatorId"}],"returns":{"type":"(uint16,uint64,uint64,uint64)","struct":"ValidatorCurState"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getValidatorOwnerAndManager","args":[{"type":"uint64","name":"validatorId"}],"returns":{"type":"(address,address)"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getPools","args":[{"type":"uint64","name":"validatorId","desc":""}],"returns":{"type":"(uint64,uint16,uint64)[]","desc":"- array of pools\nNot callable from other contracts because >1K return but can be called w/ simulate which bumps log returns"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Return list of all pools for this validator.","events":[],"recommendations":{}},{"name":"getPoolAppId","args":[{"type":"uint64","name":"validatorId"},{"type":"uint64","name":"poolId"}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or\nwant to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1\n(which contains reward tokens if being used) so that the amount available can be determined.","events":[],"recommendations":{}},{"name":"getPoolInfo","args":[{"type":"(uint64,uint64,uint64)","struct":"ValidatorPoolKey","name":"poolKey"}],"returns":{"type":"(uint64,uint16,uint64)","struct":"PoolInfo"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getCurMaxStakePerPool","args":[{"type":"uint64","name":"validatorId","desc":"- The id of the validator."}],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Calculate the maximum stake per pool for a given validator.\nNormally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so\nas pools are added the max allowed per pool can reduce.","events":[],"recommendations":{}},{"name":"doesStakerNeedToPayMBR","args":[{"type":"address","name":"staker","desc":""}],"returns":{"type":"bool"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount","events":[],"recommendations":{}},{"name":"getStakedPoolsForAccount","args":[{"type":"address","name":"staker","desc":"- The account to retrieve staked pools for."}],"returns":{"type":"(uint64,uint64,uint64)[]","desc":"- The array of staked pools for the account."},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Retrieves the staked pools for an account.","events":[],"recommendations":{}},{"name":"getTokenPayoutRatio","args":[{"type":"uint64","name":"validatorId","desc":"- The id of the validator."}],"returns":{"type":"(uint64[24],uint64)","struct":"PoolTokenPayoutRatio","desc":"- The token payout ratio for the validator."},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token\npayouts across pools can be based on a stable snaphost of stake.","events":[],"recommendations":{}},{"name":"getNodePoolAssignments","args":[{"type":"uint64","name":"validatorId"}],"returns":{"type":"((uint64[3])[8])","struct":"NodePoolAssignmentConfig"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"getNFDRegistryID","args":[],"returns":{"type":"uint64"},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"events":[],"recommendations":{}},{"name":"addValidator","args":[{"type":"pay","name":"mbrPayment","desc":"payment from caller which covers mbr increase of new validator storage"},{"type":"string","name":"nfdName","desc":"(Optional) Name of nfd (used as double-check against id specified in config)"},{"type":"(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)","struct":"ValidatorConfig","name":"config","desc":"ValidatorConfig struct"}],"returns":{"type":"uint64","desc":"validator id"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Adds a new validator\nRequires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.","events":[{"name":"retiOP_addedValidator","args":[{"type":"uint64","name":"id"},{"type":"address","name":"owner"},{"type":"address","name":"manager"}]}],"recommendations":{}},{"name":"changeValidatorManager","args":[{"type":"uint64","name":"validatorId","desc":"- The id of the validator to change the manager for."},{"type":"address","name":"manager","desc":"- The new manager address."}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Changes the Validator manager for a specific Validator id.\n[ ONLY OWNER CAN CHANGE ]","events":[],"recommendations":{}},{"name":"changeValidatorSunsetInfo","args":[{"type":"uint64","name":"validatorId","desc":"- The id of the validator to update."},{"type":"uint64","name":"sunsettingOn","desc":"- The new sunset timestamp."},{"type":"uint64","name":"sunsettingTo","desc":"- The new sunset to validator id."}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Updates the sunset information for a given validator.\n[ ONLY OWNER CAN CHANGE ]","events":[],"recommendations":{}},{"name":"changeValidatorNFD","args":[{"type":"uint64","name":"validatorId","desc":"- The id of the validator to update."},{"type":"uint64","name":"nfdAppID","desc":"- The application id of the NFD to assign to the validator."},{"type":"string","name":"nfdName","desc":"- The name of the NFD (which must match)"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Changes the NFD for a validator in the validatorList contract.\n[ ONLY OWNER CAN CHANGE ]","events":[],"recommendations":{}},{"name":"changeValidatorCommissionAddress","args":[{"type":"uint64","name":"validatorId"},{"type":"address","name":"commissionAddress"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Change the commission address that validator rewards are sent to.\n[ ONLY OWNER CAN CHANGE ]","events":[],"recommendations":{}},{"name":"changeValidatorRewardInfo","args":[{"type":"uint64","name":"validatorId"},{"type":"uint8","name":"EntryGatingType"},{"type":"address","name":"EntryGatingAddress"},{"type":"uint64[4]","name":"EntryGatingAssets"},{"type":"uint64","name":"GatingAssetMinBalance"},{"type":"uint64","name":"RewardPerPayout"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Allow the additional rewards (gating entry, additional token rewards) information be changed at will.\n[ ONLY OWNER CAN CHANGE ]","events":[],"recommendations":{}},{"name":"addPool","args":[{"type":"pay","name":"mbrPayment","desc":"payment from caller which covers mbr increase of adding a new pool"},{"type":"uint64","name":"validatorId","desc":"is id of validator to pool to (must be owner or manager)"},{"type":"uint64","name":"nodeNum","desc":"is node number to add to"}],"returns":{"type":"(uint64,uint64,uint64)","struct":"ValidatorPoolKey","desc":"pool key to created pool"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.\nThe caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.\n\n[ ONLY OWNER OR MANAGER CAN call ]","events":[{"name":"retiOP_validatorAddedPool","args":[{"type":"uint64","name":"id"},{"type":"uint16","name":"num"},{"type":"uint64","name":"poolAppId"}]}],"recommendations":{}},{"name":"addStake","args":[{"type":"pay","name":"stakedAmountPayment","desc":"- payment coming from staker to place into a pool"},{"type":"uint64","name":"validatorId","desc":"- The id of the validator."},{"type":"uint64","name":"valueToVerify","desc":"- only if validator has gating to enter - this is asset id or nfd id that corresponds to gating.\nTxn sender is factored in as well if that is part of gating.\n*"}],"returns":{"type":"(uint64,uint64,uint64)","struct":"ValidatorPoolKey","desc":"- The key of the validator pool."},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Adds stake to a validator pool.","events":[{"name":"retiOP_stakeAdded","args":[{"type":"uint64","name":"id"},{"type":"uint16","name":"poolNum"},{"type":"uint64","name":"poolAppId"},{"type":"address","name":"staker"},{"type":"uint64","name":"amountStaked"}]}],"recommendations":{}},{"name":"setTokenPayoutRatio","args":[{"type":"uint64","name":"validatorId","desc":"- validator id (and thus pool) calling us.  Verified so that sender MUST be pool 1 of this validator."}],"returns":{"type":"(uint64[24],uint64)","struct":"PoolTokenPayoutRatio","desc":"PoolTokenPayoutRatio - the finished ratio data"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios\nof stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40\nin pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by\npool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.\nIt would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of\ntheir 'current' stake which changes as part of the payouts themselves (and people could be changing stake\nduring the epoch updates across pools)\n\nMultiple pools will call us via pool 1 (pool2->pool1->validator, etc.) so don't assert on pool1 calling multiple\ntimes in same epoch.  Just return.","events":[],"recommendations":{}},{"name":"stakeUpdatedViaRewards","args":[{"type":"(uint64,uint64,uint64)","struct":"ValidatorPoolKey","name":"poolKey","desc":"- ValidatorPoolKey type"},{"type":"uint64","name":"algoToAdd","desc":"- amount this validator's total stake increased via rewards"},{"type":"uint64","name":"rewardTokenAmountReserved","desc":"- amount this validator's total stake increased via rewards (that should be"},{"type":"uint64","name":"validatorCommission","desc":"- the commission amount the validator was paid, if any"},{"type":"uint64","name":"saturatedBurnToFeeSink","desc":"- if the pool was in saturated state, the amount sent back to the fee sink.\nseen as 'accounted for/pending spent')"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total\nstake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.\nThe calling App id is validated against our pool list as well.","events":[{"name":"retiOP_epochRewardUpdate","args":[{"type":"uint64","name":"id"},{"type":"uint16","name":"poolNum"},{"type":"uint64","name":"poolAppId"},{"type":"uint64","name":"validatorCommission"},{"type":"uint64","name":"saturatedBurnToFeeSink"},{"type":"uint64","name":"algoAdded"},{"type":"uint64","name":"rewardTokenHeldBack"}]}],"recommendations":{}},{"name":"stakeRemoved","args":[{"type":"(uint64,uint64,uint64)","struct":"ValidatorPoolKey","name":"poolKey","desc":"calling us from which stake was removed"},{"type":"address","name":"staker","desc":""},{"type":"uint64","name":"amountRemoved","desc":"- algo amount removed"},{"type":"uint64","name":"rewardRemoved","desc":"- if applicable, amount of token reward removed (by pool 1 caller) or TO remove and pay out (via pool 1 from different pool caller)"},{"type":"bool","name":"stakerRemoved","desc":""}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed\nfrom the specified pool.  This is used to update the stats we have in our PoolInfo storage.\nIf any amount of rewardRemoved is specified, then that amount of reward is sent to the use\nThe calling App id is validated against our pool list as well.","events":[{"name":"retiOP_stakeRemoved","args":[{"type":"uint64","name":"id"},{"type":"uint16","name":"poolNum"},{"type":"uint64","name":"poolAppId"},{"type":"address","name":"staker"},{"type":"uint64","name":"amountUnstaked"},{"type":"uint64","name":"rewardTokensReceived"},{"type":"uint64","name":"rewardTokenAssetId"}]}],"recommendations":{}},{"name":"findPoolForStaker","args":[{"type":"uint64","name":"validatorId","desc":"- The id of the validator."},{"type":"address","name":"staker","desc":"- The address of the staker."},{"type":"uint64","name":"amountToStake","desc":"- The amount to stake."}],"returns":{"type":"((uint64,uint64,uint64),bool,bool)","desc":", boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'\nto this VALIDATOR, and true/false if staker is new to the protocol."},"actions":{"create":[],"call":["NoOp"]},"readonly":true,"desc":"Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.\nFirst checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds\nto new pool if necessary.","events":[],"recommendations":{}},{"name":"movePoolToNode","args":[{"type":"uint64","name":"validatorId","desc":"- The id of the validator."},{"type":"uint64","name":"poolAppId","desc":""},{"type":"uint64","name":"nodeNum","desc":""}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Find the specified pool (in any node number) and move it to the specified node.\nThe pool account is forced offline if moved so prior node will still run for 320 rounds but\nnew key goes online on new node soon after (320 rounds after it goes online)\nNo-op if success, asserts if not found or can't move  (no space in target)\n[ ONLY OWNER OR MANAGER CAN CHANGE ]","events":[],"recommendations":{}},{"name":"emptyTokenRewards","args":[{"type":"uint64","name":"validatorId","desc":"- The id of the validator."},{"type":"address","name":"receiver","desc":"- the account to send the tokens to (must already be opted-in to the reward token)"}],"returns":{"type":"uint64","desc":"the amount of reward token sent"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Sends the reward tokens held in pool 1 to specified receiver.\nThis is intended to be used by the owner when they want to get reward tokens 'back' which they sent to\nthe first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will\nNOT be sent as they must be held back for stakers to later claim.\n[ ONLY OWNER CAN CALL]","events":[],"recommendations":{}}],"arcs":[22,28],"desc":"ValidatorRegistry is the 'master contract' for the reti pooling protocol.\nA single immutable instance of this is deployed.  All state for all validators including information about their\npools and nodes is stored via this contract in global state and box storage.  Data in the pools themselves is stored\nwithin the StakingPool contract instance, also in global state and box storage.\nSee the StakingPool contract comments for details on how this contract creates new instances of them.","networks":{},"state":{"schema":{"global":{"ints":4,"bytes":0},"local":{"ints":0,"bytes":0}},"keys":{"global":{"stakingPoolInitialized":{"keyType":"AVMString","valueType":"AVMUint64","key":"aW5pdA=="},"numValidators":{"keyType":"AVMString","valueType":"AVMUint64","key":"bnVtVg=="},"numStakers":{"keyType":"AVMString","valueType":"AVMUint64","key":"bnVtU3Rha2Vycw=="},"totalAlgoStaked":{"keyType":"AVMString","valueType":"AVMUint64","key":"c3Rha2Vk"}},"local":{},"box":{"stakingPoolApprovalProgram":{"keyType":"AVMString","valueType":"AVMBytes","key":"cG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcw=="}}},"maps":{"global":{},"local":{},"box":{"validatorList":{"keyType":"uint64","valueType":"ValidatorInfo","prefix":"dg=="},"stakerPoolSet":{"keyType":"address","valueType":"(uint64,uint64,uint64)[6]","prefix":"c3Bz"}}}},"bareActions":{"create":[],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[675,694,713,745,830,847,887,980,1053,1910,1947,1969,2001,2216,2294,2392,2536,2570,2716,2743,2762,2801,2813,2847,2900,2968,3030,3302,3395,3446,3536,3606,3615,3784,3923,4095,4202,4215,4282,4347,4410,4544,4569,4585,4636,4658,4751],"errorMessage":"Box must have value"},{"pc":[2472],"errorMessage":"Bytes has valid prefix"},{"pc":[1342,1469],"errorMessage":"If specifying NFD, account adding validator must be owner"},{"pc":[2653],"errorMessage":"No empty slot available in the staker pool set"},{"pc":[3752],"errorMessage":"No matching slot found when told to remove a pool from the stakers set"},{"pc":[2271],"errorMessage":"No pool available with free stake.  Validator needs to add another pool"},{"pc":[3],"errorMessage":"OnCompletion must be NoOp"},{"pc":[4682],"errorMessage":"The passed in app id doesn't match the passed in ids"},{"pc":[1678],"errorMessage":"already at max pool size"},{"pc":[2428,2735,4134,4175,4689],"errorMessage":"application exists"},{"pc":[1276,1651,1944],"errorMessage":"assert target is match for conditions"},{"pc":[2038,2118],"errorMessage":"asset exists"},{"pc":[4184],"errorMessage":"balance of remaining reward tokens should match the held back amount"},{"pc":[4597],"errorMessage":"can only be called by owner or manager of validator"},{"pc":[4552],"errorMessage":"can only be called by validator owner"},{"pc":[4003],"errorMessage":"can't move to same node"},{"pc":[1920],"errorMessage":"can't stake with a validator that is past its sunsetting time"},{"pc":[551,658,1290,2560,2594,3121,3380,3808],"errorMessage":"check GlobalState exists"},{"pc":[1195],"errorMessage":"commission percentage not valid"},{"pc":[3943],"errorMessage":"couldn't find pool app id in nodes to move"},{"pc":[1178],"errorMessage":"epoch length not in allowable range"},{"pc":[1285],"errorMessage":"fee must be 10 ALGO or more to prevent spamming of validators"},{"pc":[1156],"errorMessage":"gating type not valid"},{"pc":[404,461,766,862,903,1002,2313,2411,2722,2914,3054,3329,3452,3548,3637,3977,4126,4314,4364,4453,4676,4808],"errorMessage":"index access is out of bounds"},{"pc":[1808,2508,2944,3067,3345,4013,4835],"errorMessage":"index out of bounds"},{"pc":[1555],"errorMessage":"invalid Entry gating type"},{"pc":[780,1016],"errorMessage":"max array length exceeded"},{"pc":[2028],"errorMessage":"must have required minimum balance of validator defined token to add stake"},{"pc":[4422],"errorMessage":"must stake at least the minimum for this pool"},{"pc":[1399],"errorMessage":"needs to at least be valid address"},{"pc":[4784],"errorMessage":"no available space in specified node for this pool"},{"pc":[4768],"errorMessage":"node number not in valid range"},{"pc":[3935],"errorMessage":"node number out of allowable range"},{"pc":[1240],"errorMessage":"number of pools per node must be be between 1 and the maximum allowed number"},{"pc":[413,470,493,1781,2499,2607,3186,3491,3559,3825],"errorMessage":"overflow"},{"pc":[839],"errorMessage":"pool id must be between 1 and number of pools for this validator"},{"pc":[4629],"errorMessage":"pool id not in valid range"},{"pc":[4649],"errorMessage":"pool id outside of range of pools created for this validator"},{"pc":[2154],"errorMessage":"provided nfd for entry isn't owned or linked to the staker"},{"pc":[3426],"errorMessage":"reward being removed must be covered by hold back amount"},{"pc":[3413],"errorMessage":"rewardRemoved can't be set if validator doesn't have reward token!"},{"pc":[1145],"errorMessage":"sender must be owner to add new validator"},{"pc":[3285],"errorMessage":"should only be called if algo or reward was removed"},{"pc":[2122],"errorMessage":"specified asset must be created by creator that is one of the linked addresses in an nfd"},{"pc":[2048],"errorMessage":"specified asset must be created by creator that the validator defined as a requirement to stake"},{"pc":[2095],"errorMessage":"specified asset must be identical to the asset id defined as a requirement to stake"},{"pc":[2186],"errorMessage":"specified nfd must be a segment of the nfd the validator specified as a requirement"},{"pc":[1663,1896],"errorMessage":"specified validator id isn't valid"},{"pc":[1220],"errorMessage":"staking pool must have minimum entry of 1 algo"},{"pc":[1257],"errorMessage":"sunsettingOn must be later than now if set"},{"pc":[1077],"errorMessage":"the specified validator id doesn't exist"},{"pc":[4619],"errorMessage":"the specified validator id isn't valid"},{"pc":[4118],"errorMessage":"this validator doesn't have a reward token defined"},{"pc":[2233],"errorMessage":"total staked for all of a validators pools may not exceed hard cap"},{"pc":[1113,1620,1875],"errorMessage":"transaction type is pay"},{"pc":[1209],"errorMessage":"validatorCommissionAddress must be set if percent to validator is not 0"}],"pcOffsetMethod":"cblocks"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYXJjNC9pbmRleC5kLnRzOjpDb250cmFjdC5hcHByb3ZhbFByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDE4IDggMjY4IDQzMiAyMDAgNzAwIDkwMCAxOTIgMTAwMDAwMCAyMjYgNDA5NiAyNzggMjUyIDc0MTAwIFRNUExfTkZEX1JFR0lTVFJZX0FQUF9JRAogICAgYnl0ZWNibG9jayAidiIgMHgxNTFmN2M3NSAiIiAic3Rha2VkIiAibnVtU3Rha2VycyIgInBvb2xUZW1wbGF0ZUFwcHJvdmFsQnl0ZXMiICJzcHMiIDB4MDAgIm51bVYiICJpLm93bmVyLmEiICJpbml0IiAweDAwMDIgMHgwMDAwIDB4MDY4MTAxIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEgMHgwMDAxMDAwMDAwMDAwMDAwMDNlOCAweDYzZjNmMjhiIDB4MTJmNGJkNGIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg4LTg5CiAgICAvLyBAY29udHJhY3QoeyBhdm1WZXJzaW9uOiAxMSB9KQogICAgLy8gZXhwb3J0IGNsYXNzIFZhbGlkYXRvclJlZ2lzdHJ5IGV4dGVuZHMgQ29udHJhY3QgewogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBieiBtYWluX2NyZWF0ZV9Ob09wQDM3CiAgICBwdXNoYnl0ZXNzIDB4MWI1ZTgyYzYgMHg3OTQ3MmQ4MyAweDVmN2FjZmQ5IDB4MzE3MmNhOWQgMHg4YTg3MTQyZCAweGQxMzY2Y2MzIDB4M2IwNDVjNWMgMHg3NWFmZjYxZCAweDFmMmYwMTA5IDB4MmZhMjJjNGIgMHg5MTBlOTRhYyAweDU3Mjc2N2QxIDB4OWI1MDRhYWYgMHhmYmM2MzE3OCAweDI0NDk4Y2Y0IDB4Zjg0NmRkN2EgMHg4MzA1MDUwMSAweDdiYmI2YzhkIDB4ZjgzOTQxNGEgMHgwYzMxN2NmYiAweDNlMjg4OTcyIDB4ZGQ1ZmFhZGEgMHgxOGFhYzdhNyAweGY5OWVmNTRkIDB4MTA4MDlkNGQgMHhlNzc4ZGQ1YSAweGJmNTI1OWQwIDB4NGRmOGQ4NmUgMHg0MThmY2VmYyAweGEyZGM1MWI1IDB4Mjg3M2Y1MDQgMHgwNTQ3ZjRmZSAweGNiNjY4MzU4IC8vIG1ldGhvZCAiaW5pdFN0YWtpbmdDb250cmFjdCh1aW50NjQpdm9pZCIsIG1ldGhvZCAibG9hZFN0YWtpbmdDb250cmFjdERhdGEodWludDY0LGJ5dGVbXSl2b2lkIiwgbWV0aG9kICJmaW5hbGl6ZVN0YWtpbmdDb250cmFjdCgpdm9pZCIsIG1ldGhvZCAiZ2FzKCl2b2lkIiwgbWV0aG9kICJnZXRNYnJBbW91bnRzKCkodWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KSIsIG1ldGhvZCAiZ2V0UHJvdG9jb2xDb25zdHJhaW50cygpKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJnZXROdW1WYWxpZGF0b3JzKCl1aW50NjQiLCBtZXRob2QgImdldFZhbGlkYXRvckNvbmZpZyh1aW50NjQpKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MsdWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQzMix1aW50MzIsYWRkcmVzcyx1aW50NjQsdWludDY0LHVpbnQ4LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJnZXRWYWxpZGF0b3JTdGF0ZSh1aW50NjQpKHVpbnQxNix1aW50NjQsdWludDY0LHVpbnQ2NCkiLCBtZXRob2QgImdldFZhbGlkYXRvck93bmVyQW5kTWFuYWdlcih1aW50NjQpKGFkZHJlc3MsYWRkcmVzcykiLCBtZXRob2QgImdldFBvb2xzKHVpbnQ2NCkodWludDY0LHVpbnQxNix1aW50NjQpW10iLCBtZXRob2QgImdldFBvb2xBcHBJZCh1aW50NjQsdWludDY0KXVpbnQ2NCIsIG1ldGhvZCAiZ2V0UG9vbEluZm8oKHVpbnQ2NCx1aW50NjQsdWludDY0KSkodWludDY0LHVpbnQxNix1aW50NjQpIiwgbWV0aG9kICJnZXRDdXJNYXhTdGFrZVBlclBvb2wodWludDY0KXVpbnQ2NCIsIG1ldGhvZCAiZG9lc1N0YWtlck5lZWRUb1BheU1CUihhZGRyZXNzKWJvb2wiLCBtZXRob2QgImdldFN0YWtlZFBvb2xzRm9yQWNjb3VudChhZGRyZXNzKSh1aW50NjQsdWludDY0LHVpbnQ2NClbXSIsIG1ldGhvZCAiZ2V0VG9rZW5QYXlvdXRSYXRpbyh1aW50NjQpKHVpbnQ2NFsyNF0sdWludDY0KSIsIG1ldGhvZCAiZ2V0Tm9kZVBvb2xBc3NpZ25tZW50cyh1aW50NjQpKCh1aW50NjRbM10pWzhdKSIsIG1ldGhvZCAiZ2V0TkZEUmVnaXN0cnlJRCgpdWludDY0IiwgbWV0aG9kICJhZGRWYWxpZGF0b3IocGF5LHN0cmluZywodWludDY0LGFkZHJlc3MsYWRkcmVzcyx1aW50NjQsdWludDgsYWRkcmVzcyx1aW50NjRbNF0sdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDMyLHVpbnQzMixhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDgsdWludDY0LHVpbnQ2NCkpdWludDY0IiwgbWV0aG9kICJjaGFuZ2VWYWxpZGF0b3JNYW5hZ2VyKHVpbnQ2NCxhZGRyZXNzKXZvaWQiLCBtZXRob2QgImNoYW5nZVZhbGlkYXRvclN1bnNldEluZm8odWludDY0LHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiY2hhbmdlVmFsaWRhdG9yTkZEKHVpbnQ2NCx1aW50NjQsc3RyaW5nKXZvaWQiLCBtZXRob2QgImNoYW5nZVZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzKHVpbnQ2NCxhZGRyZXNzKXZvaWQiLCBtZXRob2QgImNoYW5nZVZhbGlkYXRvclJld2FyZEluZm8odWludDY0LHVpbnQ4LGFkZHJlc3MsdWludDY0WzRdLHVpbnQ2NCx1aW50NjQpdm9pZCIsIG1ldGhvZCAiYWRkUG9vbChwYXksdWludDY0LHVpbnQ2NCkodWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJhZGRTdGFrZShwYXksdWludDY0LHVpbnQ2NCkodWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJzZXRUb2tlblBheW91dFJhdGlvKHVpbnQ2NCkodWludDY0WzI0XSx1aW50NjQpIiwgbWV0aG9kICJzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzKCh1aW50NjQsdWludDY0LHVpbnQ2NCksdWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiLCBtZXRob2QgInN0YWtlUmVtb3ZlZCgodWludDY0LHVpbnQ2NCx1aW50NjQpLGFkZHJlc3MsdWludDY0LHVpbnQ2NCxib29sKXZvaWQiLCBtZXRob2QgImZpbmRQb29sRm9yU3Rha2VyKHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCkoKHVpbnQ2NCx1aW50NjQsdWludDY0KSxib29sLGJvb2wpIiwgbWV0aG9kICJtb3ZlUG9vbFRvTm9kZSh1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJlbXB0eVRva2VuUmV3YXJkcyh1aW50NjQsYWRkcmVzcyl1aW50NjQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBpbml0U3Rha2luZ0NvbnRyYWN0IGxvYWRTdGFraW5nQ29udHJhY3REYXRhIG1haW5fZmluYWxpemVTdGFraW5nQ29udHJhY3Rfcm91dGVANSBtYWluX2dhc19yb3V0ZUA2IG1haW5fZ2V0TWJyQW1vdW50c19yb3V0ZUA3IGdldFByb3RvY29sQ29uc3RyYWludHMgZ2V0TnVtVmFsaWRhdG9ycyBnZXRWYWxpZGF0b3JDb25maWcgZ2V0VmFsaWRhdG9yU3RhdGUgZ2V0VmFsaWRhdG9yT3duZXJBbmRNYW5hZ2VyIGdldFBvb2xzIGdldFBvb2xBcHBJZCBnZXRQb29sSW5mbyBnZXRDdXJNYXhTdGFrZVBlclBvb2wgZG9lc1N0YWtlck5lZWRUb1BheU1CUiBnZXRTdGFrZWRQb29sc0ZvckFjY291bnQgZ2V0VG9rZW5QYXlvdXRSYXRpbyBnZXROb2RlUG9vbEFzc2lnbm1lbnRzIGdldE5GRFJlZ2lzdHJ5SUQgYWRkVmFsaWRhdG9yIGNoYW5nZVZhbGlkYXRvck1hbmFnZXIgY2hhbmdlVmFsaWRhdG9yU3Vuc2V0SW5mbyBjaGFuZ2VWYWxpZGF0b3JORkQgY2hhbmdlVmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgY2hhbmdlVmFsaWRhdG9yUmV3YXJkSW5mbyBhZGRQb29sIGFkZFN0YWtlIHNldFRva2VuUGF5b3V0UmF0aW8gc3Rha2VVcGRhdGVkVmlhUmV3YXJkcyBzdGFrZVJlbW92ZWQgZmluZFBvb2xGb3JTdGFrZXIgbW92ZVBvb2xUb05vZGUgZW1wdHlUb2tlblJld2FyZHMKICAgIGVycgoKbWFpbl9nZXRNYnJBbW91bnRzX3JvdXRlQDc6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNTEKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgcHVzaGJ5dGVzIDB4MTUxZjdjNzUwMDAwMDAwMDAwMDZjMjE0MDAwMDAwMDAwMDBlYjNhYzAwMDAwMDAwMDA0ZmJiNTQwMDAwMDAwMDAwMDEyMTc0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5fZ2FzX3JvdXRlQDY6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxNDAKICAgIC8vIGdhcygpOiB2b2lkIHt9CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2ZpbmFsaXplU3Rha2luZ0NvbnRyYWN0X3JvdXRlQDU6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5NQogICAgLy8gc3Rha2luZ1Bvb2xJbml0aWFsaXplZCA9IEdsb2JhbFN0YXRlPGJvb2xlYW4+KHsga2V5OiAnaW5pdCcgfSkKICAgIGJ5dGVjIDEwIC8vICJpbml0IgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM0CiAgICAvLyB0aGlzLnN0YWtpbmdQb29sSW5pdGlhbGl6ZWQudmFsdWUgPSB0cnVlCiAgICBpbnRjXzEgLy8gMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMwogICAgLy8gZmluYWxpemVTdGFraW5nQ29udHJhY3QoKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9Ob09wQDM3OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODgtODkKICAgIC8vIEBjb250cmFjdCh7IGF2bVZlcnNpb246IDExIH0pCiAgICAvLyBleHBvcnQgY2xhc3MgVmFsaWRhdG9yUmVnaXN0cnkgZXh0ZW5kcyBDb250cmFjdCB7CiAgICBwdXNoYnl0ZXMgMHhiODQ0N2IzNiAvLyBtZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAogICAgbWF0Y2ggY3JlYXRlQXBwbGljYXRpb24KICAgIGVycgoKCi8vIF9wdXlhX2xpYi51dGlsLmVuc3VyZV9idWRnZXQocmVxdWlyZWRfYnVkZ2V0OiB1aW50NjQsIGZlZV9zb3VyY2U6IHVpbnQ2NCkgLT4gdm9pZDoKZW5zdXJlX2J1ZGdldDoKICAgIHByb3RvIDIgMAogICAgZnJhbWVfZGlnIC0yCiAgICBwdXNoaW50IDEwIC8vIDEwCiAgICArCgplbnN1cmVfYnVkZ2V0X3doaWxlX3RvcEAxOgogICAgZnJhbWVfZGlnIDAKICAgIGdsb2JhbCBPcGNvZGVCdWRnZXQKICAgID4KICAgIGJ6IGVuc3VyZV9idWRnZXRfYWZ0ZXJfd2hpbGVANgogICAgaXR4bl9iZWdpbgogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIHB1c2hpbnQgNSAvLyBEZWxldGVBcHBsaWNhdGlvbgogICAgaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KICAgIGJ5dGVjIDEzIC8vIDB4MDY4MTAxCiAgICBpdHhuX2ZpZWxkIEFwcHJvdmFsUHJvZ3JhbQogICAgYnl0ZWMgMTMgLy8gMHgwNjgxMDEKICAgIGl0eG5fZmllbGQgQ2xlYXJTdGF0ZVByb2dyYW0KICAgIGZyYW1lX2RpZyAtMQogICAgc3dpdGNoIGVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfMEAzIGVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfMUA0CgplbnN1cmVfYnVkZ2V0X3N3aXRjaF9jYXNlX25leHRANToKICAgIGl0eG5fc3VibWl0CiAgICBiIGVuc3VyZV9idWRnZXRfd2hpbGVfdG9wQDEKCmVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfMUA0OgogICAgZ2xvYmFsIE1pblR4bkZlZQogICAgaXR4bl9maWVsZCBGZWUKICAgIGIgZW5zdXJlX2J1ZGdldF9zd2l0Y2hfY2FzZV9uZXh0QDUKCmVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfMEAzOgogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBiIGVuc3VyZV9idWRnZXRfc3dpdGNoX2Nhc2VfbmV4dEA1CgplbnN1cmVfYnVkZ2V0X2FmdGVyX3doaWxlQDY6CiAgICByZXRzdWIKCgovLyBjb250cmFjdHMvdXRpbHMuYWxnby50czo6d2lkZVJhdGlvKG51bWVyYXRvckZhY3RvcnM6IGJ5dGVzLCBkZW5vbWluYXRvckZhY3RvcnM6IGJ5dGVzKSAtPiB1aW50NjQsIGJ5dGVzLCBieXRlczoKd2lkZVJhdGlvOgogICAgLy8gY29udHJhY3RzL3V0aWxzLmFsZ28udHM6NAogICAgLy8gZXhwb3J0IGZ1bmN0aW9uIHdpZGVSYXRpbyhudW1lcmF0b3JGYWN0b3JzOiB1aW50NjRbXSwgZGVub21pbmF0b3JGYWN0b3JzOiB1aW50NjRbXSk6IHVpbnQ2NCB7CiAgICBwcm90byAyIDMKICAgIGludGNfMCAvLyAwCiAgICBieXRlY18yIC8vICIiCiAgICBkdXAKICAgIC8vIGNvbnRyYWN0cy91dGlscy5hbGdvLnRzOjUKICAgIC8vIGxldCBudW1lcmF0b3IgPSBuZXcgVWludDEyOCgxbikKICAgIGJ5dGVjIDE0IC8vIDB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEKICAgIC8vIGNvbnRyYWN0cy91dGlscy5hbGdvLnRzOjYKICAgIC8vIGZvciAoY29uc3QgZmFjdG9yIG9mIG51bWVyYXRvckZhY3RvcnMpIHsKICAgIGZyYW1lX2RpZyAtMgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBpbnRjXzAgLy8gMAoKd2lkZVJhdGlvX2Zvcl9oZWFkZXJAMToKICAgIC8vIGNvbnRyYWN0cy91dGlscy5hbGdvLnRzOjYKICAgIC8vIGZvciAoY29uc3QgZmFjdG9yIG9mIG51bWVyYXRvckZhY3RvcnMpIHsKICAgIGZyYW1lX2RpZyA1CiAgICBmcmFtZV9kaWcgNAogICAgPAogICAgYnogd2lkZVJhdGlvX2FmdGVyX2ZvckA0CiAgICBmcmFtZV9kaWcgLTIKICAgIGV4dHJhY3QgMiAwCiAgICBmcmFtZV9kaWcgNQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgaW50Y18zIC8vIDgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gY29udHJhY3RzL3V0aWxzLmFsZ28udHM6NwogICAgLy8gbnVtZXJhdG9yID0gbmV3IFVpbnQxMjgoQmlnVWludChmYWN0b3IpICogbnVtZXJhdG9yLmFzQmlnVWludCgpKQogICAgZnJhbWVfZGlnIDMKICAgIGIqCiAgICBkdXAKICAgIGxlbgogICAgcHVzaGludCAxNiAvLyAxNgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgcHVzaGludCAxNiAvLyAxNgogICAgYnplcm8KICAgIGJ8CiAgICBmcmFtZV9idXJ5IDMKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBmcmFtZV9idXJ5IDUKICAgIGIgd2lkZVJhdGlvX2Zvcl9oZWFkZXJAMQoKd2lkZVJhdGlvX2FmdGVyX2ZvckA0OgogICAgLy8gY29udHJhY3RzL3V0aWxzLmFsZ28udHM6MTAKICAgIC8vIGxldCBkZW5vbWluYXRvciA9IG5ldyBVaW50MTI4KDFuKQogICAgYnl0ZWMgMTQgLy8gMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMQogICAgZnJhbWVfYnVyeSAwCiAgICAvLyBjb250cmFjdHMvdXRpbHMuYWxnby50czoxMQogICAgLy8gZm9yIChjb25zdCBmYWN0b3Igb2YgZGVub21pbmF0b3JGYWN0b3JzKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgZnJhbWVfYnVyeSAxCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAyCgp3aWRlUmF0aW9fZm9yX2hlYWRlckA1OgogICAgLy8gY29udHJhY3RzL3V0aWxzLmFsZ28udHM6MTEKICAgIC8vIGZvciAoY29uc3QgZmFjdG9yIG9mIGRlbm9taW5hdG9yRmFjdG9ycykgewogICAgZnJhbWVfZGlnIDIKICAgIGZyYW1lX2RpZyAxCiAgICA8CiAgICBieiB3aWRlUmF0aW9fYWZ0ZXJfZm9yQDgKICAgIGZyYW1lX2RpZyAtMQogICAgZXh0cmFjdCAyIDAKICAgIGZyYW1lX2RpZyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludGNfMyAvLyA4CiAgICAqCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICAvLyBjb250cmFjdHMvdXRpbHMuYWxnby50czoxMgogICAgLy8gZGVub21pbmF0b3IgPSBuZXcgVWludDEyOChCaWdVaW50KGZhY3RvcikgKiBkZW5vbWluYXRvci5hc0JpZ1VpbnQoKSkKICAgIGZyYW1lX2RpZyAwCiAgICBiKgogICAgZHVwCiAgICBsZW4KICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIGJ6ZXJvCiAgICBifAogICAgZnJhbWVfYnVyeSAwCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSAyCiAgICBiIHdpZGVSYXRpb19mb3JfaGVhZGVyQDUKCndpZGVSYXRpb19hZnRlcl9mb3JAODoKICAgIC8vIGNvbnRyYWN0cy91dGlscy5hbGdvLnRzOjE1CiAgICAvLyBjb25zdCByYXRpbzogYmlndWludCA9IG51bWVyYXRvci5hc0JpZ1VpbnQoKSAvIGRlbm9taW5hdG9yLmFzQmlnVWludCgpCiAgICBmcmFtZV9kaWcgMwogICAgZnJhbWVfZGlnIDAKICAgIGIvCiAgICAvLyBjb250cmFjdHMvdXRpbHMuYWxnby50czoxNgogICAgLy8gcmV0dXJuIG5ldyBVaW50NjQocmF0aW8pLmFzVWludDY0KCkKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzMgLy8gOAogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgaW50Y18zIC8vIDgKICAgIGJ6ZXJvCiAgICBifAogICAgYnRvaQogICAgZnJhbWVfZGlnIC0yCiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2J1cnkgMgogICAgZnJhbWVfYnVyeSAxCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5jcmVhdGVBcHBsaWNhdGlvbltyb3V0aW5nXSgpIC0+IHZvaWQ6CmNyZWF0ZUFwcGxpY2F0aW9uOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTUKICAgIC8vIHN0YWtpbmdQb29sSW5pdGlhbGl6ZWQgPSBHbG9iYWxTdGF0ZTxib29sZWFuPih7IGtleTogJ2luaXQnIH0pCiAgICBieXRlYyAxMCAvLyAiaW5pdCIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNwogICAgLy8gdGhpcy5zdGFraW5nUG9vbEluaXRpYWxpemVkLnZhbHVlID0gZmFsc2UKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTcKICAgIC8vIG51bVZhbGlkYXRvcnMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiAnbnVtVicgfSkKICAgIGJ5dGVjIDggLy8gIm51bVYiCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTgKICAgIC8vIHRoaXMubnVtVmFsaWRhdG9ycy52YWx1ZSA9IDAKICAgIGludGNfMCAvLyAwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAwCiAgICAvLyBudW1TdGFrZXJzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogJ251bVN0YWtlcnMnIH0pCiAgICBieXRlYyA0IC8vICJudW1TdGFrZXJzIgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE5CiAgICAvLyB0aGlzLm51bVN0YWtlcnMudmFsdWUgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMwogICAgLy8gdG90YWxBbGdvU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogJ3N0YWtlZCcgfSkKICAgIGJ5dGVjXzMgLy8gInN0YWtlZCIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMAogICAgLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgPSAwCiAgICBpbnRjXzAgLy8gMAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNgogICAgLy8gY3JlYXRlQXBwbGljYXRpb24oKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmluaXRTdGFraW5nQ29udHJhY3Rbcm91dGluZ10oKSAtPiB2b2lkOgppbml0U3Rha2luZ0NvbnRyYWN0OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzCiAgICAvLyBpbml0U3Rha2luZ0NvbnRyYWN0KGFwcHJvdmFsUHJvZ3JhbVNpemU6IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTMKICAgIC8vIHN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtID0gQm94PGJ5dGVzPih7IGtleTogJ3Bvb2xUZW1wbGF0ZUFwcHJvdmFsQnl0ZXMnIH0pCiAgICBieXRlYyA1IC8vICJwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzIgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI1CiAgICAvLyB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLmNyZWF0ZSh7IHNpemU6IGFwcHJvdmFsUHJvZ3JhbVNpemUgfSkKICAgIHN3YXAKICAgIGJveF9jcmVhdGUKICAgIHBvcAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzCiAgICAvLyBpbml0U3Rha2luZ0NvbnRyYWN0KGFwcHJvdmFsUHJvZ3JhbVNpemU6IHVpbnQ2NCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5sb2FkU3Rha2luZ0NvbnRyYWN0RGF0YVtyb3V0aW5nXSgpIC0+IHZvaWQ6CmxvYWRTdGFraW5nQ29udHJhY3REYXRhOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4CiAgICAvLyBsb2FkU3Rha2luZ0NvbnRyYWN0RGF0YShvZmZzZXQ6IHVpbnQ2NCwgZGF0YTogYnl0ZXMpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGV4dHJhY3QgMiAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjkKICAgIC8vIGFzc2VydCghdGhpcy5zdGFraW5nUG9vbEluaXRpYWxpemVkLnZhbHVlKQogICAgaW50Y18wIC8vIDAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk1CiAgICAvLyBzdGFraW5nUG9vbEluaXRpYWxpemVkID0gR2xvYmFsU3RhdGU8Ym9vbGVhbj4oeyBrZXk6ICdpbml0JyB9KQogICAgYnl0ZWMgMTAgLy8gImluaXQiCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjkKICAgIC8vIGFzc2VydCghdGhpcy5zdGFraW5nUG9vbEluaXRpYWxpemVkLnZhbHVlKQogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgICEKICAgIGFzc2VydAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTMKICAgIC8vIHN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtID0gQm94PGJ5dGVzPih7IGtleTogJ3Bvb2xUZW1wbGF0ZUFwcHJvdmFsQnl0ZXMnIH0pCiAgICBieXRlYyA1IC8vICJwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzIgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTMwCiAgICAvLyB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLnJlcGxhY2Uob2Zmc2V0LCBkYXRhKQogICAgY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyOAogICAgLy8gbG9hZFN0YWtpbmdDb250cmFjdERhdGEob2Zmc2V0OiB1aW50NjQsIGRhdGE6IGJ5dGVzKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmdldFByb3RvY29sQ29uc3RyYWludHNbcm91dGluZ10oKSAtPiB2b2lkOgpnZXRQcm90b2NvbENvbnN0cmFpbnRzOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM2OQogICAgLy8gcmV0dXJuIEdsb2JhbC5wYXlvdXRzTWF4QmFsYW5jZQogICAgZ2xvYmFsIFBheW91dHNNYXhCYWxhbmNlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxOTQKICAgIC8vIG1heEFsZ29QZXJWYWxpZGF0b3I6IHRoaXMubWF4QWxsb3dlZFN0YWtlKCksCiAgICBjYWxsc3ViIG1heEFsbG93ZWRTdGFrZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM3MwogICAgLy8gcmV0dXJuIG9wLm9ubGluZVN0YWtlKCkKICAgIG9ubGluZV9zdGFrZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM1MgogICAgLy8gcmV0dXJuIHdpZGVSYXRpbyhbb25saW5lLCBNQVhfVkFMSURBVE9SX1NPRlRfUENUX09GX09OTElORV8xREVDSU1BTF0sIFsxMDAwXSkKICAgIGl0b2IKICAgIGJ5dGVjIDExIC8vIDB4MDAwMgogICAgc3dhcAogICAgY29uY2F0CiAgICBwdXNoaW50IDEwMCAvLyAxMDAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgYnl0ZWMgMTUgLy8gMHgwMDAxMDAwMDAwMDAwMDAwMDNlOAogICAgY2FsbHN1YiB3aWRlUmF0aW8KICAgIHBvcG4gMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTg3LTE5OQogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgICBlcG9jaFBheW91dFJvdW5kc01pbjogTUlOX0VQT0NIX0xFTkdUSCwKICAgIC8vICAgICBlcG9jaFBheW91dFJvdW5kc01heDogTUFYX0VQT0NIX0xFTkdUSCwKICAgIC8vICAgICBtaW5QY3RUb1ZhbGlkYXRvcldGb3VyRGVjaW1hbHM6IE1JTl9QQ1RfVE9fVkFMSURBVE9SLAogICAgLy8gICAgIG1heFBjdFRvVmFsaWRhdG9yV0ZvdXJEZWNpbWFsczogTUFYX1BDVF9UT19WQUxJREFUT1IsCiAgICAvLyAgICAgbWluRW50cnlTdGFrZTogTUlOX0FMR09fU1RBS0VfUEVSX1BPT0wsCiAgICAvLyAgICAgbWF4QWxnb1BlclBvb2w6IHRoaXMubWF4QWxnb0FsbG93ZWRQZXJQb29sKCksCiAgICAvLyAgICAgbWF4QWxnb1BlclZhbGlkYXRvcjogdGhpcy5tYXhBbGxvd2VkU3Rha2UoKSwKICAgIC8vICAgICBhbXRDb25zaWRlcmVkU2F0dXJhdGVkOiB0aGlzLmFsZ29TYXR1cmF0aW9uTGV2ZWwoKSwKICAgIC8vICAgICBtYXhOb2RlczogTUFYX05PREVTLAogICAgLy8gICAgIG1heFBvb2xzUGVyTm9kZTogTUFYX1BPT0xTX1BFUl9OT0RFLAogICAgLy8gICAgIG1heFN0YWtlcnNQZXJQb29sOiBNQVhfU1RBS0VSU19QRVJfUE9PTCwKICAgIC8vIH0KICAgIHVuY292ZXIgMgogICAgaXRvYgogICAgcHVzaGJ5dGVzIDB4MDAwMDAwMDAwMDAwMDAwMTAwMDAwMDAwMDAwZjQyNDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmNDI0MDAwMDAwMDAwMDAwZjQyNDAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTk2CiAgICAvLyBtYXhOb2RlczogTUFYX05PREVTLAogICAgaW50Y18zIC8vIDgKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE4Ny0xOTkKICAgIC8vIHJldHVybiB7CiAgICAvLyAgICAgZXBvY2hQYXlvdXRSb3VuZHNNaW46IE1JTl9FUE9DSF9MRU5HVEgsCiAgICAvLyAgICAgZXBvY2hQYXlvdXRSb3VuZHNNYXg6IE1BWF9FUE9DSF9MRU5HVEgsCiAgICAvLyAgICAgbWluUGN0VG9WYWxpZGF0b3JXRm91ckRlY2ltYWxzOiBNSU5fUENUX1RPX1ZBTElEQVRPUiwKICAgIC8vICAgICBtYXhQY3RUb1ZhbGlkYXRvcldGb3VyRGVjaW1hbHM6IE1BWF9QQ1RfVE9fVkFMSURBVE9SLAogICAgLy8gICAgIG1pbkVudHJ5U3Rha2U6IE1JTl9BTEdPX1NUQUtFX1BFUl9QT09MLAogICAgLy8gICAgIG1heEFsZ29QZXJQb29sOiB0aGlzLm1heEFsZ29BbGxvd2VkUGVyUG9vbCgpLAogICAgLy8gICAgIG1heEFsZ29QZXJWYWxpZGF0b3I6IHRoaXMubWF4QWxsb3dlZFN0YWtlKCksCiAgICAvLyAgICAgYW10Q29uc2lkZXJlZFNhdHVyYXRlZDogdGhpcy5hbGdvU2F0dXJhdGlvbkxldmVsKCksCiAgICAvLyAgICAgbWF4Tm9kZXM6IE1BWF9OT0RFUywKICAgIC8vICAgICBtYXhQb29sc1Blck5vZGU6IE1BWF9QT09MU19QRVJfTk9ERSwKICAgIC8vICAgICBtYXhTdGFrZXJzUGVyUG9vbDogTUFYX1NUQUtFUlNfUEVSX1BPT0wsCiAgICAvLyB9CiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjE5NwogICAgLy8gbWF4UG9vbHNQZXJOb2RlOiBNQVhfUE9PTFNfUEVSX05PREUsCiAgICBwdXNoaW50IDMgLy8gMwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTg3LTE5OQogICAgLy8gcmV0dXJuIHsKICAgIC8vICAgICBlcG9jaFBheW91dFJvdW5kc01pbjogTUlOX0VQT0NIX0xFTkdUSCwKICAgIC8vICAgICBlcG9jaFBheW91dFJvdW5kc01heDogTUFYX0VQT0NIX0xFTkdUSCwKICAgIC8vICAgICBtaW5QY3RUb1ZhbGlkYXRvcldGb3VyRGVjaW1hbHM6IE1JTl9QQ1RfVE9fVkFMSURBVE9SLAogICAgLy8gICAgIG1heFBjdFRvVmFsaWRhdG9yV0ZvdXJEZWNpbWFsczogTUFYX1BDVF9UT19WQUxJREFUT1IsCiAgICAvLyAgICAgbWluRW50cnlTdGFrZTogTUlOX0FMR09fU1RBS0VfUEVSX1BPT0wsCiAgICAvLyAgICAgbWF4QWxnb1BlclBvb2w6IHRoaXMubWF4QWxnb0FsbG93ZWRQZXJQb29sKCksCiAgICAvLyAgICAgbWF4QWxnb1BlclZhbGlkYXRvcjogdGhpcy5tYXhBbGxvd2VkU3Rha2UoKSwKICAgIC8vICAgICBhbXRDb25zaWRlcmVkU2F0dXJhdGVkOiB0aGlzLmFsZ29TYXR1cmF0aW9uTGV2ZWwoKSwKICAgIC8vICAgICBtYXhOb2RlczogTUFYX05PREVTLAogICAgLy8gICAgIG1heFBvb2xzUGVyTm9kZTogTUFYX1BPT0xTX1BFUl9OT0RFLAogICAgLy8gICAgIG1heFN0YWtlcnNQZXJQb29sOiBNQVhfU1RBS0VSU19QRVJfUE9PTCwKICAgIC8vIH0KICAgIGl0b2IKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTk4CiAgICAvLyBtYXhTdGFrZXJzUGVyUG9vbDogTUFYX1NUQUtFUlNfUEVSX1BPT0wsCiAgICBpbnRjIDYgLy8gMjAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxODctMTk5CiAgICAvLyByZXR1cm4gewogICAgLy8gICAgIGVwb2NoUGF5b3V0Um91bmRzTWluOiBNSU5fRVBPQ0hfTEVOR1RILAogICAgLy8gICAgIGVwb2NoUGF5b3V0Um91bmRzTWF4OiBNQVhfRVBPQ0hfTEVOR1RILAogICAgLy8gICAgIG1pblBjdFRvVmFsaWRhdG9yV0ZvdXJEZWNpbWFsczogTUlOX1BDVF9UT19WQUxJREFUT1IsCiAgICAvLyAgICAgbWF4UGN0VG9WYWxpZGF0b3JXRm91ckRlY2ltYWxzOiBNQVhfUENUX1RPX1ZBTElEQVRPUiwKICAgIC8vICAgICBtaW5FbnRyeVN0YWtlOiBNSU5fQUxHT19TVEFLRV9QRVJfUE9PTCwKICAgIC8vICAgICBtYXhBbGdvUGVyUG9vbDogdGhpcy5tYXhBbGdvQWxsb3dlZFBlclBvb2woKSwKICAgIC8vICAgICBtYXhBbGdvUGVyVmFsaWRhdG9yOiB0aGlzLm1heEFsbG93ZWRTdGFrZSgpLAogICAgLy8gICAgIGFtdENvbnNpZGVyZWRTYXR1cmF0ZWQ6IHRoaXMuYWxnb1NhdHVyYXRpb25MZXZlbCgpLAogICAgLy8gICAgIG1heE5vZGVzOiBNQVhfTk9ERVMsCiAgICAvLyAgICAgbWF4UG9vbHNQZXJOb2RlOiBNQVhfUE9PTFNfUEVSX05PREUsCiAgICAvLyAgICAgbWF4U3Rha2Vyc1BlclBvb2w6IE1BWF9TVEFLRVJTX1BFUl9QT09MLAogICAgLy8gfQogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxODUKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5nZXROdW1WYWxpZGF0b3JzW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0TnVtVmFsaWRhdG9yczoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIwNwogICAgLy8gcmV0dXJuIHRoaXMubnVtVmFsaWRhdG9ycy52YWx1ZQogICAgaW50Y18wIC8vIDAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk3CiAgICAvLyBudW1WYWxpZGF0b3JzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogJ251bVYnIH0pCiAgICBieXRlYyA4IC8vICJudW1WIgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjA3CiAgICAvLyByZXR1cm4gdGhpcy5udW1WYWxpZGF0b3JzLnZhbHVlCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjA1CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGl0b2IKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0VmFsaWRhdG9yQ29uZmlnW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0VmFsaWRhdG9yQ29uZmlnOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjEwCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIxMgogICAgLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnCiAgICBpdG9iCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMTIKICAgIC8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZwogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGV4dHJhY3QgMCAyNDIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIxMAogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmdldFZhbGlkYXRvclN0YXRlW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0VmFsaWRhdG9yU3RhdGU6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMTUKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjE3CiAgICAvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZQogICAgaXRvYgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3CiAgICAvLyB2YWxpZGF0b3JMaXN0ID0gQm94TWFwPFZhbGlkYXRvcklkVHlwZSwgVmFsaWRhdG9ySW5mbz4oeyBrZXlQcmVmaXg6ICd2JyB9KQogICAgYnl0ZWNfMCAvLyAidiIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjE3CiAgICAvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGV4dHJhY3QgMjQyIDI2CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMTUKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5nZXRWYWxpZGF0b3JPd25lckFuZE1hbmFnZXJbcm91dGluZ10oKSAtPiB2b2lkOgpnZXRWYWxpZGF0b3JPd25lckFuZE1hbmFnZXI6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMjAKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjIzCiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5vd25lciwKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIyMwogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcub3duZXIsCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZXh0cmFjdCAwIDI0MgogICAgZHVwCiAgICBleHRyYWN0IDggMzIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIyNAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcubWFuYWdlciwKICAgIHN3YXAKICAgIGV4dHJhY3QgNDAgMzIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIyMi0yMjUKICAgIC8vIHJldHVybiBbCiAgICAvLyAgICAgdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcub3duZXIsCiAgICAvLyAgICAgdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcubWFuYWdlciwKICAgIC8vIF0KICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjIwCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0UG9vbHNbcm91dGluZ10oKSAtPiB2b2lkOgpnZXRQb29sczoKICAgIGludGNfMCAvLyAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzQKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjM2CiAgICAvLyBjb25zdCByZXREYXRhOiBQb29sSW5mb1tdID0gW10KICAgIGJ5dGVjIDEyIC8vIDB4MDAwMAogICAgc3dhcAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjM3CiAgICAvLyBjb25zdCBwb29sU2V0ID0gY2xvbmUodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29scykKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIzNwogICAgLy8gY29uc3QgcG9vbFNldCA9IGNsb25lKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHMpCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjM4CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcG9vbFNldC5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18wIC8vIDAKCmdldFBvb2xzX3doaWxlX3RvcEAyOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjM4CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcG9vbFNldC5sZW5ndGg7IGkgKz0gMSkgewogICAgZHVwCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICA8CiAgICBieiBnZXRQb29sc19ibG9ja0A3CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyMzkKICAgIC8vIGlmIChwb29sU2V0W2ldLnBvb2xBcHBJZCA9PT0gMCkgewogICAgZGlnIDEKICAgIGludGMgNCAvLyAyNjgKICAgIGludGMgNSAvLyA0MzIKICAgIGV4dHJhY3QzCiAgICBkaWcgMQogICAgaW50Y18yIC8vIDE4CiAgICAqCiAgICBpbnRjXzIgLy8gMTgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBidXJ5IDUKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgYnogZ2V0UG9vbHNfYmxvY2tANwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjQzCiAgICAvLyByZXREYXRhLnB1c2gocG9vbFNldFtpXSkKICAgIGRpZyAyCiAgICBkdXAKICAgIGRpZyA1CiAgICBjb25jYXQgLy8gb24gZXJyb3I6IG1heCBhcnJheSBsZW5ndGggZXhjZWVkZWQKICAgIHN3YXAKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQxNgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGl0b2IKICAgIGV4dHJhY3QgNiAyCiAgICByZXBsYWNlMiAwCiAgICBidXJ5IDMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIzOAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHBvb2xTZXQubGVuZ3RoOyBpICs9IDEpIHsKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMQogICAgYiBnZXRQb29sc193aGlsZV90b3BAMgoKZ2V0UG9vbHNfYmxvY2tANzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjIzNAogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIGRpZyAzCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5nZXRQb29sQXBwSWRbcm91dGluZ10oKSAtPiB2b2lkOgpnZXRQb29sQXBwSWQ6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNTMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgYnRvaQogICAgZHVwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNTYKICAgIC8vIHBvb2xJZCAhPT0gMCAmJiBwb29sSWQgPD0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29scy5sZW5ndGgsCiAgICBieiBnZXRQb29sQXBwSWRfYm9vbF9mYWxzZUA0CiAgICBkaWcgMQogICAgaXRvYgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3CiAgICAvLyB2YWxpZGF0b3JMaXN0ID0gQm94TWFwPFZhbGlkYXRvcklkVHlwZSwgVmFsaWRhdG9ySW5mbz4oeyBrZXlQcmVmaXg6ICd2JyB9KQogICAgYnl0ZWNfMCAvLyAidiIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjU2CiAgICAvLyBwb29sSWQgIT09IDAgJiYgcG9vbElkIDw9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHMubGVuZ3RoLAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZHVwCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICA8PQogICAgYnogZ2V0UG9vbEFwcElkX2Jvb2xfZmFsc2VANAogICAgaW50Y18xIC8vIDEKCmdldFBvb2xBcHBJZF9ib29sX21lcmdlQDU6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNTUtMjU4CiAgICAvLyBhc3NlcnQoCiAgICAvLyAgICAgcG9vbElkICE9PSAwICYmIHBvb2xJZCA8PSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzLmxlbmd0aCwKICAgIC8vICAgICAncG9vbCBpZCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgbnVtYmVyIG9mIHBvb2xzIGZvciB0aGlzIHZhbGlkYXRvcicsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gcG9vbCBpZCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgbnVtYmVyIG9mIHBvb2xzIGZvciB0aGlzIHZhbGlkYXRvcgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjU5CiAgICAvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1twb29sSWQgLSAxXS5wb29sQXBwSWQKICAgIGRpZyAxCiAgICBpdG9iCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNTkKICAgIC8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzW3Bvb2xJZCAtIDFdLnBvb2xBcHBJZAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGRpZyAxCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgc3dhcAogICAgaW50YyA0IC8vIDI2OAogICAgaW50YyA1IC8vIDQzMgogICAgZXh0cmFjdDMKICAgIHN3YXAKICAgIGludGNfMiAvLyAxOAogICAgKgogICAgaW50Y18yIC8vIDE4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGV4dHJhY3QgMCA4CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNTMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKZ2V0UG9vbEFwcElkX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIGdldFBvb2xBcHBJZF9ib29sX21lcmdlQDUKCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0UG9vbEluZm9bcm91dGluZ10oKSAtPiB2b2lkOgpnZXRQb29sSW5mbzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI2MgogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNjQKICAgIC8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXQogICAgZHVwCiAgICBleHRyYWN0IDAgOAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3CiAgICAvLyB2YWxpZGF0b3JMaXN0ID0gQm94TWFwPFZhbGlkYXRvcklkVHlwZSwgVmFsaWRhdG9ySW5mbz4oeyBrZXlQcmVmaXg6ICd2JyB9KQogICAgYnl0ZWNfMCAvLyAidiIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjY0CiAgICAvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0KICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBzd2FwCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBzd2FwCiAgICBpbnRjIDQgLy8gMjY4CiAgICBpbnRjIDUgLy8gNDMyCiAgICBleHRyYWN0MwogICAgc3dhcAogICAgaW50Y18yIC8vIDE4CiAgICAqCiAgICBpbnRjXzIgLy8gMTgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjYyCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0Q3VyTWF4U3Rha2VQZXJQb29sW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0Q3VyTWF4U3Rha2VQZXJQb29sOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mjc0CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIGNhbGxzdWIgY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmdldEN1ck1heFN0YWtlUGVyUG9vbAogICAgaXRvYgogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5kb2VzU3Rha2VyTmVlZFRvUGF5TUJSW3JvdXRpbmddKCkgLT4gdm9pZDoKZG9lc1N0YWtlck5lZWRUb1BheU1CUjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMQogICAgLy8gc3Rha2VyUG9vbFNldCA9IEJveE1hcDxBY2NvdW50LCBGaXhlZEFycmF5PFZhbGlkYXRvclBvb2xLZXksIHR5cGVvZiBNQVhfUE9PTFNfUEVSX1NUQUtFUj4+KHsga2V5UHJlZml4OiAnc3BzJyB9KQogICAgYnl0ZWMgNiAvLyAic3BzIgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MjkyCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMQogICAgLy8gc3Rha2VyUG9vbFNldCA9IEJveE1hcDxBY2NvdW50LCBGaXhlZEFycmF5PFZhbGlkYXRvclBvb2xLZXksIHR5cGVvZiBNQVhfUE9PTFNfUEVSX1NUQUtFUj4+KHsga2V5UHJlZml4OiAnc3BzJyB9KQogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyOTQKICAgIC8vIHJldHVybiAhdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikuZXhpc3RzCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgICEKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5MgogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICBieXRlYyA3IC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5nZXRTdGFrZWRQb29sc0ZvckFjY291bnRbcm91dGluZ10oKSAtPiB2b2lkOgpnZXRTdGFrZWRQb29sc0ZvckFjY291bnQ6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiAyCiAgICBieXRlY18yIC8vICIiCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTEKICAgIC8vIHN0YWtlclBvb2xTZXQgPSBCb3hNYXA8QWNjb3VudCwgRml4ZWRBcnJheTxWYWxpZGF0b3JQb29sS2V5LCB0eXBlb2YgTUFYX1BPT0xTX1BFUl9TVEFLRVI+Pih7IGtleVByZWZpeDogJ3NwcycgfSkKICAgIGJ5dGVjIDYgLy8gInNwcyIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMwMwogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTEKICAgIC8vIHN0YWtlclBvb2xTZXQgPSBCb3hNYXA8QWNjb3VudCwgRml4ZWRBcnJheTxWYWxpZGF0b3JQb29sS2V5LCB0eXBlb2YgTUFYX1BPT0xTX1BFUl9TVEFLRVI+Pih7IGtleVByZWZpeDogJ3NwcycgfSkKICAgIGNvbmNhdAogICAgZHVwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDUKICAgIC8vIGlmICghdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikuZXhpc3RzKSB7CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJueiBnZXRTdGFrZWRQb29sc0ZvckFjY291bnRfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDYKICAgIC8vIHJldHVybiBbXQogICAgYnl0ZWMgMTIgLy8gMHgwMDAwCgpnZXRTdGFrZWRQb29sc0ZvckFjY291bnRfYWZ0ZXJfaW5saW5lZF9jb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50QDk6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50X2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMwOAogICAgLy8gY29uc3QgcmV0RGF0YTogVmFsaWRhdG9yUG9vbEtleVtdID0gW10KICAgIGJ5dGVjIDEyIC8vIDB4MDAwMAogICAgYnVyeSAzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDkKICAgIC8vIGNvbnN0IHBvb2xTZXQgPSBjbG9uZSh0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZSkKICAgIGR1cAogICAgYm94X2dldAogICAgc3dhcAogICAgYnVyeSA1CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzEwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcG9vbFNldC5sZW5ndGg7IGkgKz0gMSkgewogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMgoKZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50X3doaWxlX3RvcEA0OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzEwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcG9vbFNldC5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDEKICAgIHB1c2hpbnQgNiAvLyA2CiAgICA8CiAgICBieiBnZXRTdGFrZWRQb29sc0ZvckFjY291bnRfYWZ0ZXJfd2hpbGVAOAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzExCiAgICAvLyBpZiAocG9vbFNldFtpXS5pZCAhPT0gMCkgewogICAgZGlnIDEKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgICoKICAgIGRpZyA0CiAgICBzd2FwCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgYnVyeSA2CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGJ6IGdldFN0YWtlZFBvb2xzRm9yQWNjb3VudF9hZnRlcl9pZl9lbHNlQDcKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMxMgogICAgLy8gcmV0RGF0YS5wdXNoKHBvb2xTZXRbaV0pCiAgICBkaWcgMgogICAgZHVwCiAgICBkaWcgNgogICAgY29uY2F0IC8vIG9uIGVycm9yOiBtYXggYXJyYXkgbGVuZ3RoIGV4Y2VlZGVkCiAgICBzd2FwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBleHRyYWN0IDYgMgogICAgcmVwbGFjZTIgMAogICAgYnVyeSAzCgpnZXRTdGFrZWRQb29sc0ZvckFjY291bnRfYWZ0ZXJfaWZfZWxzZUA3OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzEwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgcG9vbFNldC5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDEKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDIKICAgIGIgZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50X3doaWxlX3RvcEA0CgpnZXRTdGFrZWRQb29sc0ZvckFjY291bnRfYWZ0ZXJfd2hpbGVAODoKICAgIGRpZyAyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMDMKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgYiBnZXRTdGFrZWRQb29sc0ZvckFjY291bnRfYWZ0ZXJfaW5saW5lZF9jb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0U3Rha2VkUG9vbHNGb3JBY2NvdW50QDkKCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0VG9rZW5QYXlvdXRSYXRpb1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldFRva2VuUGF5b3V0UmF0aW86CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMjUKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzI3CiAgICAvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvCiAgICBpdG9iCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMjcKICAgIC8vIHJldHVybiB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8KICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjIDcgLy8gNzAwCiAgICBpbnRjIDYgLy8gMjAwCiAgICBleHRyYWN0MwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzI1CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0Tm9kZVBvb2xBc3NpZ25tZW50c1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldE5vZGVQb29sQXNzaWdubWVudHM6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMzAKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzMyCiAgICAvLyBhc3NlcnQodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS5leGlzdHMsICJ0aGUgc3BlY2lmaWVkIHZhbGlkYXRvciBpZCBkb2Vzbid0IGV4aXN0IikKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMzMgogICAgLy8gYXNzZXJ0KHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkuZXhpc3RzLCAidGhlIHNwZWNpZmllZCB2YWxpZGF0b3IgaWQgZG9lc24ndCBleGlzdCIpCiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIHRoZSBzcGVjaWZpZWQgdmFsaWRhdG9yIGlkIGRvZXNuJ3QgZXhpc3QKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjMzNAogICAgLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUubm9kZVBvb2xBc3NpZ25tZW50cwogICAgYm94X2dldAogICAgcG9wCiAgICBpbnRjIDggLy8gOTAwCiAgICBpbnRjIDkgLy8gMTkyCiAgICBleHRyYWN0MwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzMwCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0TkZEUmVnaXN0cnlJRFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldE5GRFJlZ2lzdHJ5SUQ6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozMzkKICAgIC8vIHJldHVybiBuZmRSZWdpc3RyeUFwcElkCiAgICBpbnRjIDE2IC8vIFRNUExfTkZEX1JFR0lTVFJZX0FQUF9JRAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzM3CiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIGl0b2IKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuYWRkVmFsaWRhdG9yW3JvdXRpbmddKCkgLT4gdm9pZDoKYWRkVmFsaWRhdG9yOgogICAgaW50Y18wIC8vIDAKICAgIGJ5dGVjXzIgLy8gIiIKICAgIGR1cG4gNAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzUwCiAgICAvLyBhZGRWYWxpZGF0b3IobWJyUGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCBuZmROYW1lOiBzdHJpbmcsIGNvbmZpZzogVmFsaWRhdG9yQ29uZmlnKTogdWludDY0IHsKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgZHVwbiAyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDQ2CiAgICAvLyBhc3NlcnQoY29uZmlnLm93bmVyICE9PSBHbG9iYWwuemVyb0FkZHJlc3MpCiAgICBleHRyYWN0IDggMzIKICAgIGR1cAogICAgY292ZXIgMgogICAgZHVwCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNDcKICAgIC8vIGFzc2VydChjb25maWcubWFuYWdlciAhPT0gR2xvYmFsLnplcm9BZGRyZXNzKQogICAgZGlnIDEKICAgIGV4dHJhY3QgNDAgMzIKICAgIGR1cAogICAgY292ZXIgMwogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAhPQogICAgYXNzZXJ0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDQ4CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gY29uZmlnLm93bmVyLCAnc2VuZGVyIG11c3QgYmUgb3duZXIgdG8gYWRkIG5ldyB2YWxpZGF0b3InKQogICAgdHhuIFNlbmRlcgogICAgPT0KICAgIGFzc2VydCAvLyBzZW5kZXIgbXVzdCBiZSBvd25lciB0byBhZGQgbmV3IHZhbGlkYXRvcgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA1MQogICAgLy8gY29uZmlnLmVudHJ5R2F0aW5nVHlwZS5hc1VpbnQ2NCgpID49IEdBVElOR19UWVBFX05PTkUgJiYKICAgIHB1c2hpbnQgODAgLy8gODAKICAgIGdldGJ5dGUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTIKICAgIC8vIGNvbmZpZy5lbnRyeUdhdGluZ1R5cGUuYXNVaW50NjQoKSA8PSBHQVRJTkdfVFlQRV9DT05TVF9NQVgsCiAgICBwdXNoaW50IDQgLy8gNAogICAgPD0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTEtMTA1MgogICAgLy8gY29uZmlnLmVudHJ5R2F0aW5nVHlwZS5hc1VpbnQ2NCgpID49IEdBVElOR19UWVBFX05PTkUgJiYKICAgIC8vICAgICBjb25maWcuZW50cnlHYXRpbmdUeXBlLmFzVWludDY0KCkgPD0gR0FUSU5HX1RZUEVfQ09OU1RfTUFYLAogICAgYnogYWRkVmFsaWRhdG9yX2Jvb2xfZmFsc2VAMTMKICAgIGludGNfMSAvLyAxCgphZGRWYWxpZGF0b3JfYm9vbF9tZXJnZUAxNDoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTAtMTA1NAogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIGNvbmZpZy5lbnRyeUdhdGluZ1R5cGUuYXNVaW50NjQoKSA+PSBHQVRJTkdfVFlQRV9OT05FICYmCiAgICAvLyAgICAgICAgIGNvbmZpZy5lbnRyeUdhdGluZ1R5cGUuYXNVaW50NjQoKSA8PSBHQVRJTkdfVFlQRV9DT05TVF9NQVgsCiAgICAvLyAgICAgJ2dhdGluZyB0eXBlIG5vdCB2YWxpZCcsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gZ2F0aW5nIHR5cGUgbm90IHZhbGlkCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDU2CiAgICAvLyBjb25maWcuZXBvY2hSb3VuZExlbmd0aC5hc1VpbnQ2NCgpID49IE1JTl9FUE9DSF9MRU5HVEggJiYKICAgIGRpZyAyCiAgICBwdXNoaW50IDE2OSAvLyAxNjkKICAgIGV4dHJhY3RfdWludDMyCiAgICBkdXAKICAgIGJ1cnkgOQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA1Ni0xMDU3CiAgICAvLyBjb25maWcuZXBvY2hSb3VuZExlbmd0aC5hc1VpbnQ2NCgpID49IE1JTl9FUE9DSF9MRU5HVEggJiYKICAgIC8vICAgICBjb25maWcuZXBvY2hSb3VuZExlbmd0aC5hc1VpbnQ2NCgpIDw9IE1BWF9FUE9DSF9MRU5HVEgsCiAgICBieiBhZGRWYWxpZGF0b3JfYm9vbF9mYWxzZUAxNwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA1NwogICAgLy8gY29uZmlnLmVwb2NoUm91bmRMZW5ndGguYXNVaW50NjQoKSA8PSBNQVhfRVBPQ0hfTEVOR1RILAogICAgZGlnIDcKICAgIGludGMgMTAgLy8gMTAwMDAwMAogICAgPD0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTYtMTA1NwogICAgLy8gY29uZmlnLmVwb2NoUm91bmRMZW5ndGguYXNVaW50NjQoKSA+PSBNSU5fRVBPQ0hfTEVOR1RIICYmCiAgICAvLyAgICAgY29uZmlnLmVwb2NoUm91bmRMZW5ndGguYXNVaW50NjQoKSA8PSBNQVhfRVBPQ0hfTEVOR1RILAogICAgYnogYWRkVmFsaWRhdG9yX2Jvb2xfZmFsc2VAMTcKICAgIGludGNfMSAvLyAxCgphZGRWYWxpZGF0b3JfYm9vbF9tZXJnZUAxODoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNTUtMTA1OQogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIGNvbmZpZy5lcG9jaFJvdW5kTGVuZ3RoLmFzVWludDY0KCkgPj0gTUlOX0VQT0NIX0xFTkdUSCAmJgogICAgLy8gICAgICAgICBjb25maWcuZXBvY2hSb3VuZExlbmd0aC5hc1VpbnQ2NCgpIDw9IE1BWF9FUE9DSF9MRU5HVEgsCiAgICAvLyAgICAgJ2Vwb2NoIGxlbmd0aCBub3QgaW4gYWxsb3dhYmxlIHJhbmdlJywKICAgIC8vICkKICAgIGFzc2VydCAvLyBlcG9jaCBsZW5ndGggbm90IGluIGFsbG93YWJsZSByYW5nZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA2MQogICAgLy8gY29uZmlnLnBlcmNlbnRUb1ZhbGlkYXRvci5hc1VpbnQ2NCgpID49IE1JTl9QQ1RfVE9fVkFMSURBVE9SICYmCiAgICBkaWcgMgogICAgcHVzaGludCAxNzMgLy8gMTczCiAgICBleHRyYWN0X3VpbnQzMgogICAgZHVwCiAgICBidXJ5IDgKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNjIKICAgIC8vIGNvbmZpZy5wZXJjZW50VG9WYWxpZGF0b3IuYXNVaW50NjQoKSA8PSBNQVhfUENUX1RPX1ZBTElEQVRPUiwKICAgIGludGMgMTAgLy8gMTAwMDAwMAogICAgPD0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNjEtMTA2MgogICAgLy8gY29uZmlnLnBlcmNlbnRUb1ZhbGlkYXRvci5hc1VpbnQ2NCgpID49IE1JTl9QQ1RfVE9fVkFMSURBVE9SICYmCiAgICAvLyAgICAgY29uZmlnLnBlcmNlbnRUb1ZhbGlkYXRvci5hc1VpbnQ2NCgpIDw9IE1BWF9QQ1RfVE9fVkFMSURBVE9SLAogICAgYnogYWRkVmFsaWRhdG9yX2Jvb2xfZmFsc2VAMjAKICAgIGludGNfMSAvLyAxCgphZGRWYWxpZGF0b3JfYm9vbF9tZXJnZUAyMToKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNjAtMTA2NAogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIGNvbmZpZy5wZXJjZW50VG9WYWxpZGF0b3IuYXNVaW50NjQoKSA+PSBNSU5fUENUX1RPX1ZBTElEQVRPUiAmJgogICAgLy8gICAgICAgICBjb25maWcucGVyY2VudFRvVmFsaWRhdG9yLmFzVWludDY0KCkgPD0gTUFYX1BDVF9UT19WQUxJREFUT1IsCiAgICAvLyAgICAgJ2NvbW1pc3Npb24gcGVyY2VudGFnZSBub3QgdmFsaWQnLAogICAgLy8gKQogICAgYXNzZXJ0IC8vIGNvbW1pc3Npb24gcGVyY2VudGFnZSBub3QgdmFsaWQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNjUKICAgIC8vIGlmIChjb25maWcucGVyY2VudFRvVmFsaWRhdG9yLmFzVWludDY0KCkgIT09IDApIHsKICAgIGRpZyA2CiAgICBieiBhZGRWYWxpZGF0b3JfYWZ0ZXJfaWZfZWxzZUAyMwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA2NwogICAgLy8gY29uZmlnLnZhbGlkYXRvckNvbW1pc3Npb25BZGRyZXNzICE9PSBHbG9iYWwuemVyb0FkZHJlc3MsCiAgICBkaWcgMgogICAgZXh0cmFjdCAxNzcgMzIKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNjYtMTA2OQogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIGNvbmZpZy52YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyAhPT0gR2xvYmFsLnplcm9BZGRyZXNzLAogICAgLy8gICAgICd2YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyBtdXN0IGJlIHNldCBpZiBwZXJjZW50IHRvIHZhbGlkYXRvciBpcyBub3QgMCcsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gdmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgbXVzdCBiZSBzZXQgaWYgcGVyY2VudCB0byB2YWxpZGF0b3IgaXMgbm90IDAKCmFkZFZhbGlkYXRvcl9hZnRlcl9pZl9lbHNlQDIzOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3MQogICAgLy8gYXNzZXJ0KGNvbmZpZy5taW5FbnRyeVN0YWtlID49IE1JTl9BTEdPX1NUQUtFX1BFUl9QT09MLCAnc3Rha2luZyBwb29sIG11c3QgaGF2ZSBtaW5pbXVtIGVudHJ5IG9mIDEgYWxnbycpCiAgICBkaWcgMgogICAgZHVwCiAgICBwdXNoaW50IDIwOSAvLyAyMDkKICAgIGV4dHJhY3RfdWludDY0CiAgICBpbnRjIDEwIC8vIDEwMDAwMDAKICAgID49CiAgICBhc3NlcnQgLy8gc3Rha2luZyBwb29sIG11c3QgaGF2ZSBtaW5pbXVtIGVudHJ5IG9mIDEgYWxnbwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3NAogICAgLy8gY29uZmlnLnBvb2xzUGVyTm9kZS5hc1VpbnQ2NCgpID4gMCAmJiBjb25maWcucG9vbHNQZXJOb2RlLmFzVWludDY0KCkgPD0gTUFYX1BPT0xTX1BFUl9OT0RFLAogICAgcHVzaGludCAyMjUgLy8gMjI1CiAgICBnZXRieXRlCiAgICBkdXAKICAgIGJ1cnkgNwogICAgYnogYWRkVmFsaWRhdG9yX2Jvb2xfZmFsc2VAMjYKICAgIGRpZyA1CiAgICBwdXNoaW50IDMgLy8gMwogICAgPD0KICAgIGJ6IGFkZFZhbGlkYXRvcl9ib29sX2ZhbHNlQDI2CiAgICBpbnRjXzEgLy8gMQoKYWRkVmFsaWRhdG9yX2Jvb2xfbWVyZ2VAMjc6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDczLTEwNzYKICAgIC8vIGFzc2VydCgKICAgIC8vICAgICBjb25maWcucG9vbHNQZXJOb2RlLmFzVWludDY0KCkgPiAwICYmIGNvbmZpZy5wb29sc1Blck5vZGUuYXNVaW50NjQoKSA8PSBNQVhfUE9PTFNfUEVSX05PREUsCiAgICAvLyAgICAgJ251bWJlciBvZiBwb29scyBwZXIgbm9kZSBtdXN0IGJlIGJlIGJldHdlZW4gMSBhbmQgdGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXInLAogICAgLy8gKQogICAgYXNzZXJ0IC8vIG51bWJlciBvZiBwb29scyBwZXIgbm9kZSBtdXN0IGJlIGJlIGJldHdlZW4gMSBhbmQgdGhlIG1heGltdW0gYWxsb3dlZCBudW1iZXIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNzcKICAgIC8vIGlmIChjb25maWcuc3Vuc2V0dGluZ09uICE9PSAwKSB7CiAgICBkaWcgMgogICAgaW50YyAxMSAvLyAyMjYKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGJ1cnkgNgogICAgYnogYWRkVmFsaWRhdG9yX2FmdGVyX2lmX2Vsc2VAMjkKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNzgKICAgIC8vIGFzc2VydChjb25maWcuc3Vuc2V0dGluZ09uID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwgJ3N1bnNldHRpbmdPbiBtdXN0IGJlIGxhdGVyIHRoYW4gbm93IGlmIHNldCcpCiAgICBkaWcgNAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgPgogICAgYXNzZXJ0IC8vIHN1bnNldHRpbmdPbiBtdXN0IGJlIGxhdGVyIHRoYW4gbm93IGlmIHNldAoKYWRkVmFsaWRhdG9yX2FmdGVyX2lmX2Vsc2VAMjk6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTMtMzU2CiAgICAvLyBhc3NlcnRNYXRjaChtYnJQYXltZW50LCB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkVmFsaWRhdG9yTWJyLAogICAgLy8gfSkKICAgIGRpZyAzCiAgICBkdXAKICAgIGd0eG5zIFJlY2VpdmVyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTQKICAgIC8vIHJlY2VpdmVyOiBHbG9iYWwuY3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTMtMzU2CiAgICAvLyBhc3NlcnRNYXRjaChtYnJQYXltZW50LCB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkVmFsaWRhdG9yTWJyLAogICAgLy8gfSkKICAgID09CiAgICBkaWcgMQogICAgZ3R4bnMgQW1vdW50CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTUKICAgIC8vIGFtb3VudDogdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkVmFsaWRhdG9yTWJyLAogICAgcHVzaGludCA0NDI5MDAgLy8gNDQyOTAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTMtMzU2CiAgICAvLyBhc3NlcnRNYXRjaChtYnJQYXltZW50LCB7CiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gICAgIGFtb3VudDogdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkVmFsaWRhdG9yTWJyLAogICAgLy8gfSkKICAgID09CiAgICAmJgogICAgYXNzZXJ0IC8vIGFzc2VydCB0YXJnZXQgaXMgbWF0Y2ggZm9yIGNvbmRpdGlvbnMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM1OAogICAgLy8gYXNzZXJ0KG1iclBheW1lbnQuZmVlID4gMTAgKiAxMDAwMDAwLCAnZmVlIG11c3QgYmUgMTAgQUxHTyBvciBtb3JlIHRvIHByZXZlbnQgc3BhbW1pbmcgb2YgdmFsaWRhdG9ycycpCiAgICBndHhucyBGZWUKICAgIHB1c2hpbnQgMTAwMDAwMDAgLy8gMTAwMDAwMDAKICAgID4KICAgIGFzc2VydCAvLyBmZWUgbXVzdCBiZSAxMCBBTEdPIG9yIG1vcmUgdG8gcHJldmVudCBzcGFtbWluZyBvZiB2YWxpZGF0b3JzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNjEKICAgIC8vIGNvbnN0IHZhbGlkYXRvcklkOiB1aW50NjQgPSB0aGlzLm51bVZhbGlkYXRvcnMudmFsdWUgKyAxCiAgICBpbnRjXzAgLy8gMAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTcKICAgIC8vIG51bVZhbGlkYXRvcnMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiAnbnVtVicgfSkKICAgIGJ5dGVjIDggLy8gIm51bVYiCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNjEKICAgIC8vIGNvbnN0IHZhbGlkYXRvcklkOiB1aW50NjQgPSB0aGlzLm51bVZhbGlkYXRvcnMudmFsdWUgKyAxCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk3CiAgICAvLyBudW1WYWxpZGF0b3JzID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogJ251bVYnIH0pCiAgICBieXRlYyA4IC8vICJudW1WIgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MzYyCiAgICAvLyB0aGlzLm51bVZhbGlkYXRvcnMudmFsdWUgPSB2YWxpZGF0b3JJZAogICAgZGlnIDEKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNjQKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkuY3JlYXRlKCkKICAgIGl0b2IKICAgIGR1cAogICAgYnVyeSAxMQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3CiAgICAvLyB2YWxpZGF0b3JMaXN0ID0gQm94TWFwPFZhbGlkYXRvcklkVHlwZSwgVmFsaWRhdG9ySW5mbz4oeyBrZXlQcmVmaXg6ICd2JyB9KQogICAgYnl0ZWNfMCAvLyAidiIKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM2NAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS5jcmVhdGUoKQogICAgZHVwCiAgICBwdXNoaW50IDEwOTIgLy8gMTA5MgogICAgYm94X2NyZWF0ZQogICAgcG9wCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNjUKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnID0gY2xvbmUoY29uZmlnKQogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZGlnIDYKICAgIGR1cAogICAgY292ZXIgNAogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM2NgogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuaWQgPSB2YWxpZGF0b3JJZAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMwogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjM2OQogICAgLy8gaWYgKGNvbmZpZy5uZmRGb3JJbmZvICE9PSAwKSB7CiAgICBwdXNoaW50IDcyIC8vIDcyCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBidXJ5IDEwCiAgICBieiBhZGRWYWxpZGF0b3JfYWZ0ZXJfaWZfZWxzZUAzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNzUKICAgIC8vIFR4bi5zZW5kZXIgPT09IEFjY291bnQob3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMoY29uZmlnLm5mZEZvckluZm8sIEJ5dGVzKCdpLm93bmVyLmEnKSlbMF0pLAogICAgdHhuIFNlbmRlcgogICAgZGlnIDkKICAgIGJ5dGVjIDkgLy8gImkub3duZXIuYSIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgID09CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNzQtMzc3CiAgICAvLyBhc3NlcnQoCiAgICAvLyAgICAgVHhuLnNlbmRlciA9PT0gQWNjb3VudChvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhjb25maWcubmZkRm9ySW5mbywgQnl0ZXMoJ2kub3duZXIuYScpKVswXSksCiAgICAvLyAgICAgJ0lmIHNwZWNpZnlpbmcgTkZELCBhY2NvdW50IGFkZGluZyB2YWxpZGF0b3IgbXVzdCBiZSBvd25lcicsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gSWYgc3BlY2lmeWluZyBORkQsIGFjY291bnQgYWRkaW5nIHZhbGlkYXRvciBtdXN0IGJlIG93bmVyCgphZGRWYWxpZGF0b3JfYWZ0ZXJfaWZfZWxzZUAzOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Mzg5CiAgICAvLyBlbWl0PHJldGlPUF9hZGRlZFZhbGlkYXRvcj4oeyBpZDogdmFsaWRhdG9ySWQsIG93bmVyOiBjb25maWcub3duZXIsIG1hbmFnZXI6IGNvbmZpZy5tYW5hZ2VyIH0pCiAgICBkaWcgOQogICAgZHVwCiAgICBkaWcgMwogICAgY29uY2F0CiAgICBkaWcgMgogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHhhOGRkMjFjYiAvLyBtZXRob2QgInJldGlPUF9hZGRlZFZhbGlkYXRvcih1aW50NjQsYWRkcmVzcyxhZGRyZXNzKSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czozNTAKICAgIC8vIGFkZFZhbGlkYXRvcihtYnJQYXltZW50OiBndHhuLlBheW1lbnRUeG4sIG5mZE5hbWU6IHN0cmluZywgY29uZmlnOiBWYWxpZGF0b3JDb25maWcpOiB1aW50NjQgewogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKYWRkVmFsaWRhdG9yX2Jvb2xfZmFsc2VAMjY6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhZGRWYWxpZGF0b3JfYm9vbF9tZXJnZUAyNwoKYWRkVmFsaWRhdG9yX2Jvb2xfZmFsc2VAMjA6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhZGRWYWxpZGF0b3JfYm9vbF9tZXJnZUAyMQoKYWRkVmFsaWRhdG9yX2Jvb2xfZmFsc2VAMTc6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhZGRWYWxpZGF0b3JfYm9vbF9tZXJnZUAxOAoKYWRkVmFsaWRhdG9yX2Jvb2xfZmFsc2VAMTM6CiAgICBpbnRjXzAgLy8gMAogICAgYiBhZGRWYWxpZGF0b3JfYm9vbF9tZXJnZUAxNAoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5jaGFuZ2VWYWxpZGF0b3JNYW5hZ2VyW3JvdXRpbmddKCkgLT4gdm9pZDoKY2hhbmdlVmFsaWRhdG9yTWFuYWdlcjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQwMAogICAgLy8gY2hhbmdlVmFsaWRhdG9yTWFuYWdlcih2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBtYW5hZ2VyOiBBY2NvdW50KTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MDEKICAgIC8vIHRoaXMuY2FsbGVyTXVzdEJlT3duZXIodmFsaWRhdG9ySWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBjYWxsZXJNdXN0QmVPd25lcgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDAyCiAgICAvLyBhc3NlcnQobWFuYWdlciAhPT0gR2xvYmFsLnplcm9BZGRyZXNzLCAnbmVlZHMgdG8gYXQgbGVhc3QgYmUgdmFsaWQgYWRkcmVzcycpCiAgICBkdXAKICAgIGdsb2JhbCBaZXJvQWRkcmVzcwogICAgIT0KICAgIGFzc2VydCAvLyBuZWVkcyB0byBhdCBsZWFzdCBiZSB2YWxpZCBhZGRyZXNzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MDMKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1hbmFnZXIgPSBtYW5hZ2VyCiAgICBzd2FwCiAgICBpdG9iCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MDMKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1hbmFnZXIgPSBtYW5hZ2VyCiAgICBwdXNoaW50IDQwIC8vIDQwCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MDAKICAgIC8vIGNoYW5nZVZhbGlkYXRvck1hbmFnZXIodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgbWFuYWdlcjogQWNjb3VudCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5jaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvW3JvdXRpbmddKCkgLT4gdm9pZDoKY2hhbmdlVmFsaWRhdG9yU3Vuc2V0SW5mbzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQxNAogICAgLy8gY2hhbmdlVmFsaWRhdG9yU3Vuc2V0SW5mbyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBzdW5zZXR0aW5nT246IHVpbnQ2NCwgc3Vuc2V0dGluZ1RvOiBWYWxpZGF0b3JJZFR5cGUpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQxNQogICAgLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZCkKICAgIGRpZyAyCiAgICBjYWxsc3ViIGNhbGxlck11c3RCZU93bmVyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MTYKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnN1bnNldHRpbmdPbiA9IHN1bnNldHRpbmdPbgogICAgdW5jb3ZlciAyCiAgICBpdG9iCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MTYKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnN1bnNldHRpbmdPbiA9IHN1bnNldHRpbmdPbgogICAgZHVwCiAgICBpbnRjIDExIC8vIDIyNgogICAgdW5jb3ZlciA0CiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDE3CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5zdW5zZXR0aW5nVG8gPSBzdW5zZXR0aW5nVG8KICAgIHB1c2hpbnQgMjM0IC8vIDIzNAogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDE0CiAgICAvLyBjaGFuZ2VWYWxpZGF0b3JTdW5zZXRJbmZvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHN1bnNldHRpbmdPbjogdWludDY0LCBzdW5zZXR0aW5nVG86IFZhbGlkYXRvcklkVHlwZSk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5jaGFuZ2VWYWxpZGF0b3JORkRbcm91dGluZ10oKSAtPiB2b2lkOgpjaGFuZ2VWYWxpZGF0b3JORkQ6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MjkKICAgIC8vIGNoYW5nZVZhbGlkYXRvck5GRCh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBuZmRBcHBJRDogdWludDY0LCBuZmROYW1lOiBzdHJpbmcpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGR1cAogICAgYnRvaQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDMwCiAgICAvLyB0aGlzLmNhbGxlck11c3RCZU93bmVyKHZhbGlkYXRvcklkKQogICAgZGlnIDIKICAgIGNhbGxzdWIgY2FsbGVyTXVzdEJlT3duZXIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQzNQogICAgLy8gVHhuLnNlbmRlciA9PT0gQWNjb3VudChvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyhuZmRBcHBJRCwgQnl0ZXMoJ2kub3duZXIuYScpKVswXSksCiAgICB0eG4gU2VuZGVyCiAgICBzd2FwCiAgICBieXRlYyA5IC8vICJpLm93bmVyLmEiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICA9PQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDM0LTQzNwogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIFR4bi5zZW5kZXIgPT09IEFjY291bnQob3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXMobmZkQXBwSUQsIEJ5dGVzKCdpLm93bmVyLmEnKSlbMF0pLAogICAgLy8gICAgICdJZiBzcGVjaWZ5aW5nIE5GRCwgYWNjb3VudCBhZGRpbmcgdmFsaWRhdG9yIG11c3QgYmUgb3duZXInLAogICAgLy8gKQogICAgYXNzZXJ0IC8vIElmIHNwZWNpZnlpbmcgTkZELCBhY2NvdW50IGFkZGluZyB2YWxpZGF0b3IgbXVzdCBiZSBvd25lcgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDM4CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5uZmRGb3JJbmZvID0gbmZkQXBwSUQKICAgIHN3YXAKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQzOAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcubmZkRm9ySW5mbyA9IG5mZEFwcElECiAgICBwdXNoaW50IDcyIC8vIDcyCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0MjkKICAgIC8vIGNoYW5nZVZhbGlkYXRvck5GRCh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBuZmRBcHBJRDogdWludDY0LCBuZmROYW1lOiBzdHJpbmcpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuY2hhbmdlVmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3Nbcm91dGluZ10oKSAtPiB2b2lkOgpjaGFuZ2VWYWxpZGF0b3JDb21taXNzaW9uQWRkcmVzczoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ0NQogICAgLy8gY2hhbmdlVmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3ModmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgY29tbWlzc2lvbkFkZHJlc3M6IEFjY291bnQpOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ0NgogICAgLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIGNhbGxlck11c3RCZU93bmVyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NDcKICAgIC8vIGFzc2VydChjb21taXNzaW9uQWRkcmVzcyAhPT0gR2xvYmFsLnplcm9BZGRyZXNzKQogICAgZHVwCiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ0OAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcudmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3MgPSBjb21taXNzaW9uQWRkcmVzcwogICAgc3dhcAogICAgaXRvYgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3CiAgICAvLyB2YWxpZGF0b3JMaXN0ID0gQm94TWFwPFZhbGlkYXRvcklkVHlwZSwgVmFsaWRhdG9ySW5mbz4oeyBrZXlQcmVmaXg6ICd2JyB9KQogICAgYnl0ZWNfMCAvLyAidiIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDQ4CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy52YWxpZGF0b3JDb21taXNzaW9uQWRkcmVzcyA9IGNvbW1pc3Npb25BZGRyZXNzCiAgICBwdXNoaW50IDE3NyAvLyAxNzcKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ0NQogICAgLy8gY2hhbmdlVmFsaWRhdG9yQ29tbWlzc2lvbkFkZHJlc3ModmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgY29tbWlzc2lvbkFkZHJlc3M6IEFjY291bnQpOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuY2hhbmdlVmFsaWRhdG9yUmV3YXJkSW5mb1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmNoYW5nZVZhbGlkYXRvclJld2FyZEluZm86CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NTUtNDYyCiAgICAvLyBjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvKAogICAgLy8gICAgIHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsCiAgICAvLyAgICAgRW50cnlHYXRpbmdUeXBlOiBVaW50OCwKICAgIC8vICAgICBFbnRyeUdhdGluZ0FkZHJlc3M6IEFjY291bnQsCiAgICAvLyAgICAgRW50cnlHYXRpbmdBc3NldHM6IEZpeGVkQXJyYXk8dWludDY0LCA0PiwKICAgIC8vICAgICBHYXRpbmdBc3NldE1pbkJhbGFuY2U6IHVpbnQ2NCwKICAgIC8vICAgICBSZXdhcmRQZXJQYXlvdXQ6IHVpbnQ2NCwKICAgIC8vICk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNgogICAgY292ZXIgMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDYzCiAgICAvLyB0aGlzLmNhbGxlck11c3RCZU93bmVyKHZhbGlkYXRvcklkKQogICAgY2FsbHN1YiBjYWxsZXJNdXN0QmVPd25lcgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDY2CiAgICAvLyBFbnRyeUdhdGluZ1R5cGUuYXNVaW50NjQoKSA+PSBHQVRJTkdfVFlQRV9OT05FICYmIEVudHJ5R2F0aW5nVHlwZS5hc1VpbnQ2NCgpIDwgR0FUSU5HX1RZUEVfQ09OU1RfTUFYLAogICAgYnRvaQogICAgZHVwCiAgICBwdXNoaW50IDQgLy8gNAogICAgPAogICAgYnogY2hhbmdlVmFsaWRhdG9yUmV3YXJkSW5mb19ib29sX2ZhbHNlQDQKICAgIGludGNfMSAvLyAxCgpjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvX2Jvb2xfbWVyZ2VANToKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ2NS00NjgKICAgIC8vIGFzc2VydCgKICAgIC8vICAgICBFbnRyeUdhdGluZ1R5cGUuYXNVaW50NjQoKSA+PSBHQVRJTkdfVFlQRV9OT05FICYmIEVudHJ5R2F0aW5nVHlwZS5hc1VpbnQ2NCgpIDwgR0FUSU5HX1RZUEVfQ09OU1RfTUFYLAogICAgLy8gICAgICdpbnZhbGlkIEVudHJ5IGdhdGluZyB0eXBlJywKICAgIC8vICkKICAgIGFzc2VydCAvLyBpbnZhbGlkIEVudHJ5IGdhdGluZyB0eXBlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NjkKICAgIC8vIGlmIChFbnRyeUdhdGluZ1R5cGUuYXNVaW50NjQoKSA9PT0gR0FUSU5HX1RZUEVfQVNTRVRTX0NSRUFURURfQlkpIHsKICAgIGR1cAogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBieiBjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvX2FmdGVyX2lmX2Vsc2VANwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDcwCiAgICAvLyBhc3NlcnQoRW50cnlHYXRpbmdBZGRyZXNzICE9PSBHbG9iYWwuemVyb0FkZHJlc3MpCiAgICBkaWcgNAogICAgZ2xvYmFsIFplcm9BZGRyZXNzCiAgICAhPQogICAgYXNzZXJ0CgpjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvX2FmdGVyX2lmX2Vsc2VANzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ3OAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuZW50cnlHYXRpbmdUeXBlID0gRW50cnlHYXRpbmdUeXBlCiAgICBkaWcgNgogICAgaXRvYgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3CiAgICAvLyB2YWxpZGF0b3JMaXN0ID0gQm94TWFwPFZhbGlkYXRvcklkVHlwZSwgVmFsaWRhdG9ySW5mbz4oeyBrZXlQcmVmaXg6ICd2JyB9KQogICAgYnl0ZWNfMCAvLyAidiIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDc4CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5lbnRyeUdhdGluZ1R5cGUgPSBFbnRyeUdhdGluZ1R5cGUKICAgIGR1cAogICAgcHVzaGludCA4MCAvLyA4MAogICAgZGlnIDgKICAgIGJveF9yZXBsYWNlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0NzkKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLmVudHJ5R2F0aW5nQWRkcmVzcyA9IEVudHJ5R2F0aW5nQWRkcmVzcwogICAgZHVwCiAgICBwdXNoaW50IDgxIC8vIDgxCiAgICBkaWcgNwogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ4MAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuZW50cnlHYXRpbmdBc3NldHMgPSBjbG9uZShFbnRyeUdhdGluZ0Fzc2V0cykKICAgIGR1cAogICAgcHVzaGludCAxMTMgLy8gMTEzCiAgICBkaWcgNgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ4MQogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuZ2F0aW5nQXNzZXRNaW5CYWxhbmNlID0gR2F0aW5nQXNzZXRNaW5CYWxhbmNlCiAgICBkdXAKICAgIHB1c2hpbnQgMTQ1IC8vIDE0NQogICAgZGlnIDUKICAgIGJveF9yZXBsYWNlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0ODIKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnJld2FyZFBlclBheW91dCA9IFJld2FyZFBlclBheW91dAogICAgcHVzaGludCAxNjEgLy8gMTYxCiAgICBkaWcgMwogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ1NS00NjIKICAgIC8vIGNoYW5nZVZhbGlkYXRvclJld2FyZEluZm8oCiAgICAvLyAgICAgdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwKICAgIC8vICAgICBFbnRyeUdhdGluZ1R5cGU6IFVpbnQ4LAogICAgLy8gICAgIEVudHJ5R2F0aW5nQWRkcmVzczogQWNjb3VudCwKICAgIC8vICAgICBFbnRyeUdhdGluZ0Fzc2V0czogRml4ZWRBcnJheTx1aW50NjQsIDQ+LAogICAgLy8gICAgIEdhdGluZ0Fzc2V0TWluQmFsYW5jZTogdWludDY0LAogICAgLy8gICAgIFJld2FyZFBlclBheW91dDogdWludDY0LAogICAgLy8gKTogdm9pZCB7CiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpjaGFuZ2VWYWxpZGF0b3JSZXdhcmRJbmZvX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIGNoYW5nZVZhbGlkYXRvclJld2FyZEluZm9fYm9vbF9tZXJnZUA1CgoKLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmFkZFBvb2xbcm91dGluZ10oKSAtPiB2b2lkOgphZGRQb29sOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NDk2CiAgICAvLyBhZGRQb29sKG1iclBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwgdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgbm9kZU51bTogdWludDY0KTogVmFsaWRhdG9yUG9vbEtleSB7CiAgICB0eG4gR3JvdXBJbmRleAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGR1cAogICAgZ3R4bnMgVHlwZUVudW0KICAgIGludGNfMSAvLyBwYXkKICAgID09CiAgICBhc3NlcnQgLy8gdHJhbnNhY3Rpb24gdHlwZSBpcyBwYXkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ5OAogICAgLy8gdGhpcy5jYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcih2YWxpZGF0b3JJZCkKICAgIGRpZyAxCiAgICBjYWxsc3ViIGNhbGxlck11c3RCZU93bmVyT3JNYW5hZ2VyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MDEKICAgIC8vIGFzc2VydE1hdGNoKG1iclBheW1lbnQsIHsgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLCBhbW91bnQ6IHRoaXMuZ2V0TWJyQW1vdW50cygpLmFkZFBvb2xNYnIgfSkKICAgIGRpZyAyCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICB1bmNvdmVyIDMKICAgIGd0eG5zIEFtb3VudAogICAgcHVzaGludCA5NjM1MDAgLy8gOTYzNTAwCiAgICA9PQogICAgJiYKICAgIGFzc2VydCAvLyBhc3NlcnQgdGFyZ2V0IGlzIG1hdGNoIGZvciBjb25kaXRpb25zCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MDMKICAgIC8vIGFzc2VydCh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLmV4aXN0cywgInNwZWNpZmllZCB2YWxpZGF0b3IgaWQgaXNuJ3QgdmFsaWQiKQogICAgZGlnIDEKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBkaWcgMQogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MDMKICAgIC8vIGFzc2VydCh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLmV4aXN0cywgInNwZWNpZmllZCB2YWxpZGF0b3IgaWQgaXNuJ3QgdmFsaWQiKQogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBzcGVjaWZpZWQgdmFsaWRhdG9yIGlkIGlzbid0IHZhbGlkCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MDUKICAgIC8vIGxldCBudW1Qb29sczogdWludDY0ID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZS5udW1Qb29scy5hc1VpbnQ2NCgpCiAgICBkdXAKICAgIGJveF9nZXQKICAgIHBvcAogICAgZHVwCiAgICBleHRyYWN0IDI0MiAyNgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MDYKICAgIC8vIGlmICgobnVtUG9vbHMgYXMgdWludDY0KSA+PSBNQVhfUE9PTFMpIHsKICAgIGR1cAogICAgcHVzaGludCAyNCAvLyAyNAogICAgPj0KICAgICEKICAgIGFzc2VydCAvLyBhbHJlYWR5IGF0IG1heCBwb29sIHNpemUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUwOQogICAgLy8gbnVtUG9vbHMgKz0gMQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUxMi01MzAKICAgIC8vIGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgICBvbkNvbXBsZXRpb246IE9uQ29tcGxldGVBY3Rpb24uTm9PcCwKICAgIC8vICAgICBhcHByb3ZhbFByb2dyYW06IFsKICAgIC8vICAgICAgICAgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5leHRyYWN0KDAsIDQwOTYpLAogICAgLy8gICAgICAgICB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLmV4dHJhY3QoNDA5NiwgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5sZW5ndGggLSA0MDk2KSwKICAgIC8vICAgICBdLAogICAgLy8gICAgIGNsZWFyU3RhdGVQcm9ncmFtOiBzdGFraW5nUG9vbC5jbGVhclN0YXRlUHJvZ3JhbSwKICAgIC8vICAgICBnbG9iYWxOdW1VaW50OiBzdGFraW5nUG9vbC5nbG9iYWxVaW50cywKICAgIC8vICAgICBnbG9iYWxOdW1CeXRlczogc3Rha2luZ1Bvb2wuZ2xvYmFsQnl0ZXMsCiAgICAvLyAgICAgZXh0cmFQcm9ncmFtUGFnZXM6IDMsCiAgICAvLyAgICAgYXBwQXJnczogWwogICAgLy8gICAgICAgICAvLyBjcmVhdGluZ0NvbnRyYWN0SUQsIHZhbGlkYXRvcklkLCBwb29sSWQsIG1pbkVudHJ5U3Rha2UKICAgIC8vICAgICAgICAgbWV0aG9kU2VsZWN0b3IoJ2NyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkJyksCiAgICAvLyAgICAgICAgIG9wLml0b2IoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLmlkKSwKICAgIC8vICAgICAgICAgb3AuaXRvYih2YWxpZGF0b3JJZCksCiAgICAvLyAgICAgICAgIG9wLml0b2IobnVtUG9vbHMgYXMgdWludDY0KSwKICAgIC8vICAgICAgICAgb3AuaXRvYih0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5taW5FbnRyeVN0YWtlKSwKICAgIC8vICAgICBdLAogICAgLy8gfSkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkzCiAgICAvLyBzdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbSA9IEJveDxieXRlcz4oeyBrZXk6ICdwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzJyB9KQogICAgYnl0ZWMgNSAvLyAicG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcyIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUxNQogICAgLy8gdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5leHRyYWN0KDAsIDQwOTYpLAogICAgaW50Y18wIC8vIDAKICAgIGludGMgMTIgLy8gNDA5NgogICAgYm94X2V4dHJhY3QKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkzCiAgICAvLyBzdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbSA9IEJveDxieXRlcz4oeyBrZXk6ICdwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzJyB9KQogICAgYnl0ZWMgNSAvLyAicG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcyIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUxNgogICAgLy8gdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5leHRyYWN0KDQwOTYsIHRoaXMuc3Rha2luZ1Bvb2xBcHByb3ZhbFByb2dyYW0ubGVuZ3RoIC0gNDA5NiksCiAgICBib3hfbGVuCiAgICBwb3AKICAgIGludGMgMTIgLy8gNDA5NgogICAgLQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTMKICAgIC8vIHN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtID0gQm94PGJ5dGVzPih7IGtleTogJ3Bvb2xUZW1wbGF0ZUFwcHJvdmFsQnl0ZXMnIH0pCiAgICBieXRlYyA1IC8vICJwb29sVGVtcGxhdGVBcHByb3ZhbEJ5dGVzIgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTE2CiAgICAvLyB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLmV4dHJhY3QoNDA5NiwgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5sZW5ndGggLSA0MDk2KSwKICAgIGludGMgMTIgLy8gNDA5NgogICAgdW5jb3ZlciAyCiAgICBib3hfZXh0cmFjdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTI1CiAgICAvLyBvcC5pdG9iKEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25JZC5pZCksCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uSUQKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUyNwogICAgLy8gb3AuaXRvYihudW1Qb29scyBhcyB1aW50NjQpLAogICAgZGlnIDMKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUyOAogICAgLy8gb3AuaXRvYih0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5taW5FbnRyeVN0YWtlKSwKICAgIHVuY292ZXIgNQogICAgZXh0cmFjdCAwIDI0MgogICAgZXh0cmFjdCAyMDkgOAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTI0CiAgICAvLyBtZXRob2RTZWxlY3RvcignY3JlYXRlQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQnKSwKICAgIHB1c2hieXRlcyAweDU5ZTkwYWE2IC8vIG1ldGhvZCAiY3JlYXRlQXBwbGljYXRpb24odWludDY0LHVpbnQ2NCx1aW50NjQsdWludDY0KXZvaWQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDYKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MjEKICAgIC8vIGV4dHJhUHJvZ3JhbVBhZ2VzOiAzLAogICAgcHVzaGludCAzIC8vIDMKICAgIGl0eG5fZmllbGQgRXh0cmFQcm9ncmFtUGFnZXMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjQ5NwogICAgLy8gY29uc3Qgc3Rha2luZ1Bvb2wgPSBjb21waWxlQXJjNChTdGFraW5nUG9vbCkKICAgIHB1c2hpbnQgMyAvLyAzCiAgICBpdHhuX2ZpZWxkIEdsb2JhbE51bUJ5dGVTbGljZQogICAgcHVzaGludCAxMSAvLyAxMQogICAgaXR4bl9maWVsZCBHbG9iYWxOdW1VaW50CiAgICBwdXNoYnl0ZXMgYmFzZTY0KEM0RUJRdz09KQogICAgaXR4bl9maWVsZCBDbGVhclN0YXRlUHJvZ3JhbVBhZ2VzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIHN3YXAKICAgIGl0eG5fZmllbGQgQXBwcm92YWxQcm9ncmFtUGFnZXMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUxMwogICAgLy8gb25Db21wbGV0aW9uOiBPbkNvbXBsZXRlQWN0aW9uLk5vT3AsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBPbkNvbXBsZXRpb24KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUxMi01MzAKICAgIC8vIGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgICBvbkNvbXBsZXRpb246IE9uQ29tcGxldGVBY3Rpb24uTm9PcCwKICAgIC8vICAgICBhcHByb3ZhbFByb2dyYW06IFsKICAgIC8vICAgICAgICAgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5leHRyYWN0KDAsIDQwOTYpLAogICAgLy8gICAgICAgICB0aGlzLnN0YWtpbmdQb29sQXBwcm92YWxQcm9ncmFtLmV4dHJhY3QoNDA5NiwgdGhpcy5zdGFraW5nUG9vbEFwcHJvdmFsUHJvZ3JhbS5sZW5ndGggLSA0MDk2KSwKICAgIC8vICAgICBdLAogICAgLy8gICAgIGNsZWFyU3RhdGVQcm9ncmFtOiBzdGFraW5nUG9vbC5jbGVhclN0YXRlUHJvZ3JhbSwKICAgIC8vICAgICBnbG9iYWxOdW1VaW50OiBzdGFraW5nUG9vbC5nbG9iYWxVaW50cywKICAgIC8vICAgICBnbG9iYWxOdW1CeXRlczogc3Rha2luZ1Bvb2wuZ2xvYmFsQnl0ZXMsCiAgICAvLyAgICAgZXh0cmFQcm9ncmFtUGFnZXM6IDMsCiAgICAvLyAgICAgYXBwQXJnczogWwogICAgLy8gICAgICAgICAvLyBjcmVhdGluZ0NvbnRyYWN0SUQsIHZhbGlkYXRvcklkLCBwb29sSWQsIG1pbkVudHJ5U3Rha2UKICAgIC8vICAgICAgICAgbWV0aG9kU2VsZWN0b3IoJ2NyZWF0ZUFwcGxpY2F0aW9uKHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCl2b2lkJyksCiAgICAvLyAgICAgICAgIG9wLml0b2IoR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbklkLmlkKSwKICAgIC8vICAgICAgICAgb3AuaXRvYih2YWxpZGF0b3JJZCksCiAgICAvLyAgICAgICAgIG9wLml0b2IobnVtUG9vbHMgYXMgdWludDY0KSwKICAgIC8vICAgICAgICAgb3AuaXRvYih0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5taW5FbnRyeVN0YWtlKSwKICAgIC8vICAgICBdLAogICAgLy8gfSkuc3VibWl0KCkKICAgIHB1c2hpbnQgNiAvLyA2CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MzIKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuc3RhdGUubnVtUG9vbHMgPSBuZXcgVWludDE2KG51bVBvb2xzKQogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGR1cAogICAgZXh0cmFjdCA2IDIKICAgIGRpZyAzCiAgICBwdXNoaW50IDI0MiAvLyAyNDIKICAgIGRpZyAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTM1CiAgICAvLyBjb25zdCBwb29sQXBwSWQgPSBJVHhuLmNyZWF0ZWRBcHBsaWNhdGlvbklkLmlkCiAgICBpdHhuIENyZWF0ZWRBcHBsaWNhdGlvbklECiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1MzYKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHNbbnVtUG9vbHMgLSAxXS5wb29sQXBwSWQgPSBwb29sQXBwSWQKICAgIHVuY292ZXIgMwogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGRpZyAxCiAgICBpdG9iCiAgICBkaWcgMQogICAgcHVzaGludCAyNCAvLyAyNAogICAgPAogICAgYXNzZXJ0IC8vIGluZGV4IG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIGludGNfMiAvLyAxOAogICAgKgogICAgaW50YyA0IC8vIDI2OAogICAgKwogICAgdW5jb3ZlciA1CiAgICBzd2FwCiAgICBkaWcgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUzNwogICAgLy8gdGhpcy5hZGRQb29sVG9Ob2RlKHZhbGlkYXRvcklkLCBwb29sQXBwSWQsIG5vZGVOdW0pCiAgICB1bmNvdmVyIDYKICAgIHVuY292ZXIgMgogICAgdW5jb3ZlciA2CiAgICBjYWxsc3ViIGFkZFBvb2xUb05vZGUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjUzOS01NDMKICAgIC8vIGVtaXQ8cmV0aU9QX3ZhbGlkYXRvckFkZGVkUG9vbD4oewogICAgLy8gICAgIGlkOiB2YWxpZGF0b3JJZCwKICAgIC8vICAgICBudW06IG5ldyBVaW50MTYobnVtUG9vbHMpLAogICAgLy8gICAgIHBvb2xBcHBJZDogcG9vbEFwcElkLAogICAgLy8gfSkKICAgIGRpZyAzCiAgICB1bmNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHhmYmNjMGY2YiAvLyBtZXRob2QgInJldGlPUF92YWxpZGF0b3JBZGRlZFBvb2wodWludDY0LHVpbnQxNix1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU0NQogICAgLy8gcmV0dXJuIHsgaWQ6IHZhbGlkYXRvcklkLCBwb29sSWQ6IG51bVBvb2xzIGFzIHVpbnQ2NCwgcG9vbEFwcElkOiBvcC5JVHhuLmNyZWF0ZWRBcHBsaWNhdGlvbklkLmlkIH0KICAgIGl0eG4gQ3JlYXRlZEFwcGxpY2F0aW9uSUQKICAgIGNvdmVyIDIKICAgIGNvbmNhdAogICAgc3dhcAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo0OTYKICAgIC8vIGFkZFBvb2wobWJyUGF5bWVudDogZ3R4bi5QYXltZW50VHhuLCB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBub2RlTnVtOiB1aW50NjQpOiBWYWxpZGF0b3JQb29sS2V5IHsKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuYWRkU3Rha2Vbcm91dGluZ10oKSAtPiB2b2lkOgphZGRTdGFrZToKICAgIGludGNfMCAvLyAwCiAgICBkdXBuIDcKICAgIGJ5dGVjXzIgLy8gIiIKICAgIGR1cG4gMTQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU1Ny01NjEKICAgIC8vIGFkZFN0YWtlKAogICAgLy8gICAgIHN0YWtlZEFtb3VudFBheW1lbnQ6IGd0eG4uUGF5bWVudFR4biwKICAgIC8vICAgICB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLAogICAgLy8gICAgIHZhbHVlVG9WZXJpZnk6IHVpbnQ2NCwKICAgIC8vICk6IFZhbGlkYXRvclBvb2xLZXkgewogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICBkdXAKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIHN3YXAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU2MgogICAgLy8gYXNzZXJ0KHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkuZXhpc3RzLCAic3BlY2lmaWVkIHZhbGlkYXRvciBpZCBpc24ndCB2YWxpZCIpCiAgICBpdG9iCiAgICBkdXAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cG4gMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTYyCiAgICAvLyBhc3NlcnQodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS5leGlzdHMsICJzcGVjaWZpZWQgdmFsaWRhdG9yIGlkIGlzbid0IHZhbGlkIikKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIHNwZWNpZmllZCB2YWxpZGF0b3IgaWQgaXNuJ3QgdmFsaWQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU2NQogICAgLy8gaWYgKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnN1bnNldHRpbmdPbiA+IDApIHsKICAgIGJveF9nZXQKICAgIHBvcAogICAgZXh0cmFjdCAwIDI0MgogICAgaW50YyAxMSAvLyAyMjYKICAgIGV4dHJhY3RfdWludDY0CiAgICBieiBhZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU2OAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcuc3Vuc2V0dGluZ09uID4gR2xvYmFsLmxhdGVzdFRpbWVzdGFtcCwKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGV4dHJhY3QgMCAyNDIKICAgIGludGMgMTEgLy8gMjI2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgPgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTY3LTU3MAogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLnN1bnNldHRpbmdPbiA+IEdsb2JhbC5sYXRlc3RUaW1lc3RhbXAsCiAgICAvLyAgICAgImNhbid0IHN0YWtlIHdpdGggYSB2YWxpZGF0b3IgdGhhdCBpcyBwYXN0IGl0cyBzdW5zZXR0aW5nIHRpbWUiLAogICAgLy8gKQogICAgYXNzZXJ0IC8vIGNhbid0IHN0YWtlIHdpdGggYSB2YWxpZGF0b3IgdGhhdCBpcyBwYXN0IGl0cyBzdW5zZXR0aW5nIHRpbWUKCmFkZFN0YWtlX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU3MwogICAgLy8gY29uc3Qgc3Rha2VyID0gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgZHVwCiAgICBidXJ5IDI0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1NzctNTgwCiAgICAvLyBhc3NlcnRNYXRjaChzdGFrZWRBbW91bnRQYXltZW50LCB7CiAgICAvLyAgICAgc2VuZGVyOiBzdGFrZXIsCiAgICAvLyAgICAgcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgLy8gfSkKICAgIGRpZyA1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGd0eG5zIFNlbmRlcgogICAgZHVwCiAgICBidXJ5IDI0CiAgICA9PQogICAgc3dhcAogICAgZ3R4bnMgUmVjZWl2ZXIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU3OQogICAgLy8gcmVjZWl2ZXI6IEdsb2JhbC5jdXJyZW50QXBwbGljYXRpb25BZGRyZXNzLAogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU3Ny01ODAKICAgIC8vIGFzc2VydE1hdGNoKHN0YWtlZEFtb3VudFBheW1lbnQsIHsKICAgIC8vICAgICBzZW5kZXI6IHN0YWtlciwKICAgIC8vICAgICByZWNlaXZlcjogR2xvYmFsLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MsCiAgICAvLyB9KQogICAgPT0KICAgICYmCiAgICBhc3NlcnQgLy8gYXNzZXJ0IHRhcmdldCBpcyBtYXRjaCBmb3IgY29uZGl0aW9ucwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIyOAogICAgLy8gY29uc3QgdHlwZSA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLmVudHJ5R2F0aW5nVHlwZQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZXh0cmFjdCAwIDI0MgogICAgcHVzaGludCA4MCAvLyA4MAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIyOQogICAgLy8gaWYgKHR5cGUuYXNVaW50NjQoKSA9PT0gR0FUSU5HX1RZUEVfTk9ORSkgewogICAgZ2V0Ynl0ZQogICAgZHVwCiAgICBidXJ5IDEwCiAgICBieiBhZGRTdGFrZV9hZnRlcl9pbmxpbmVkX2NvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5kb2VzU3Rha2VyTWVldEdhdGluZ0A1MQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzMgogICAgLy8gY29uc3Qgc3Rha2VyID0gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgYnVyeSAyMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzMwogICAgLy8gY29uc3QgY29uZmlnID0gY2xvbmUodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcpCiAgICBkdXAKICAgIGJveF9nZXQKICAgIHN3YXAKICAgIGJ1cnkgMjkKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjM3CiAgICAvLyB0eXBlLmFzVWludDY0KCkgPT09IEdBVElOR19UWVBFX0FTU0VUU19DUkVBVEVEX0JZIHx8CiAgICBkaWcgOAogICAgaW50Y18xIC8vIDEKICAgID09CiAgICBkdXAKICAgIGJ1cnkgOQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzNy0xMjM4CiAgICAvLyB0eXBlLmFzVWludDY0KCkgPT09IEdBVElOR19UWVBFX0FTU0VUU19DUkVBVEVEX0JZIHx8CiAgICAvLyB0eXBlLmFzVWludDY0KCkgPT09IEdBVElOR19UWVBFX0FTU0VUX0lEIHx8CiAgICBibnogYWRkU3Rha2VfaWZfYm9keUAyOQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzOAogICAgLy8gdHlwZS5hc1VpbnQ2NCgpID09PSBHQVRJTkdfVFlQRV9BU1NFVF9JRCB8fAogICAgZGlnIDgKICAgIHB1c2hpbnQgMiAvLyAyCiAgICA9PQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzNy0xMjM4CiAgICAvLyB0eXBlLmFzVWludDY0KCkgPT09IEdBVElOR19UWVBFX0FTU0VUU19DUkVBVEVEX0JZIHx8CiAgICAvLyB0eXBlLmFzVWludDY0KCkgPT09IEdBVElOR19UWVBFX0FTU0VUX0lEIHx8CiAgICBibnogYWRkU3Rha2VfaWZfYm9keUAyOQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIzOQogICAgLy8gdHlwZS5hc1VpbnQ2NCgpID09PSBHQVRJTkdfVFlQRV9DUkVBVEVEX0JZX05GRF9BRERSRVNTRVMKICAgIGRpZyA4CiAgICBwdXNoaW50IDMgLy8gMwogICAgPT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMzctMTIzOQogICAgLy8gdHlwZS5hc1VpbnQ2NCgpID09PSBHQVRJTkdfVFlQRV9BU1NFVFNfQ1JFQVRFRF9CWSB8fAogICAgLy8gdHlwZS5hc1VpbnQ2NCgpID09PSBHQVRJTkdfVFlQRV9BU1NFVF9JRCB8fAogICAgLy8gdHlwZS5hc1VpbnQ2NCgpID09PSBHQVRJTkdfVFlQRV9DUkVBVEVEX0JZX05GRF9BRERSRVNTRVMKICAgIGJ6IGFkZFN0YWtlX2FmdGVyX2lmX2Vsc2VAMzIKCmFkZFN0YWtlX2lmX2JvZHlAMjk6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjQxCiAgICAvLyBhc3NlcnQodmFsdWVUb1ZlcmlmeSAhPT0gMCkKICAgIGRpZyAyCiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNDIKICAgIC8vIGxldCBiYWxSZXF1aXJlZCA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLmdhdGluZ0Fzc2V0TWluQmFsYW5jZQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZXh0cmFjdCAwIDI0MgogICAgcHVzaGludCAxNDUgLy8gMTQ1CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBidXJ5IDIxCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjQzCiAgICAvLyBpZiAoYmFsUmVxdWlyZWQgPT09IDApIHsKICAgIGJueiBhZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDMxCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjQ0CiAgICAvLyBiYWxSZXF1aXJlZCA9IDEKICAgIGludGNfMSAvLyAxCiAgICBidXJ5IDIwCgphZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDMxOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI0NwogICAgLy8gb3AuQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShzdGFrZXIsIHZhbHVlVG9WZXJpZnkpWzBdID49IGJhbFJlcXVpcmVkLAogICAgZGlnIDIxCiAgICBkaWcgMwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBwb3AKICAgIGRpZyAyMAogICAgPj0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNDYtMTI0OQogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIG9wLkFzc2V0SG9sZGluZy5hc3NldEJhbGFuY2Uoc3Rha2VyLCB2YWx1ZVRvVmVyaWZ5KVswXSA+PSBiYWxSZXF1aXJlZCwKICAgIC8vICAgICAnbXVzdCBoYXZlIHJlcXVpcmVkIG1pbmltdW0gYmFsYW5jZSBvZiB2YWxpZGF0b3IgZGVmaW5lZCB0b2tlbiB0byBhZGQgc3Rha2UnLAogICAgLy8gKQogICAgYXNzZXJ0IC8vIG11c3QgaGF2ZSByZXF1aXJlZCBtaW5pbXVtIGJhbGFuY2Ugb2YgdmFsaWRhdG9yIGRlZmluZWQgdG9rZW4gdG8gYWRkIHN0YWtlCgphZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDMyOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI1MQogICAgLy8gaWYgKHR5cGUuYXNVaW50NjQoKSA9PT0gR0FUSU5HX1RZUEVfQVNTRVRTX0NSRUFURURfQlkpIHsKICAgIGRpZyA3CiAgICBieiBhZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDM0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjUzCiAgICAvLyBBc3NldCh2YWx1ZVRvVmVyaWZ5KS5jcmVhdG9yID09PSBjb25maWcuZW50cnlHYXRpbmdBZGRyZXNzLAogICAgZGlnIDIKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBkaWcgMjgKICAgIGV4dHJhY3QgMCAyNDIKICAgIGV4dHJhY3QgODEgMzIKICAgID09CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjUyLTEyNTUKICAgIC8vIGFzc2VydCgKICAgIC8vICAgICBBc3NldCh2YWx1ZVRvVmVyaWZ5KS5jcmVhdG9yID09PSBjb25maWcuZW50cnlHYXRpbmdBZGRyZXNzLAogICAgLy8gICAgICdzcGVjaWZpZWQgYXNzZXQgbXVzdCBiZSBjcmVhdGVkIGJ5IGNyZWF0b3IgdGhhdCB0aGUgdmFsaWRhdG9yIGRlZmluZWQgYXMgYSByZXF1aXJlbWVudCB0byBzdGFrZScsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gc3BlY2lmaWVkIGFzc2V0IG11c3QgYmUgY3JlYXRlZCBieSBjcmVhdG9yIHRoYXQgdGhlIHZhbGlkYXRvciBkZWZpbmVkIGFzIGEgcmVxdWlyZW1lbnQgdG8gc3Rha2UKCmFkZFN0YWtlX2FmdGVyX2lmX2Vsc2VAMzQ6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjU3CiAgICAvLyBpZiAodHlwZS5hc1VpbnQ2NCgpID09PSBHQVRJTkdfVFlQRV9BU1NFVF9JRCkgewogICAgZGlnIDgKICAgIHB1c2hpbnQgMiAvLyAyCiAgICA9PQogICAgYnogYWRkU3Rha2VfYWZ0ZXJfaWZfZWxzZUA0MgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI1OAogICAgLy8gbGV0IGZvdW5kID0gZmFsc2UKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDE4CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAxMwoKYWRkU3Rha2VfZm9yX2hlYWRlckAzNjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNTkKICAgIC8vIGZvciAoY29uc3QgYXNzZXRJZCBvZiBjb25maWcuZW50cnlHYXRpbmdBc3NldHMpIHsKICAgIGRpZyAxMgogICAgcHVzaGludCA0IC8vIDQKICAgIDwKICAgIGJ6IGFkZFN0YWtlX2Jsb2NrQDQxCiAgICBkaWcgMjcKICAgIGV4dHJhY3QgMCAyNDIKICAgIGV4dHJhY3QgMTEzIDMyCiAgICBkaWcgMTMKICAgIGludGNfMyAvLyA4CiAgICAqCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI2MAogICAgLy8gaWYgKHZhbHVlVG9WZXJpZnkgPT09IGFzc2V0SWQpIHsKICAgIGRpZyAzCiAgICA9PQogICAgYnogYWRkU3Rha2VfYWZ0ZXJfaWZfZWxzZUAzOQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI2MQogICAgLy8gZm91bmQgPSB0cnVlCiAgICBpbnRjXzEgLy8gMQogICAgYnVyeSAxOAoKYWRkU3Rha2VfYmxvY2tANDE6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjY1CiAgICAvLyBhc3NlcnQoZm91bmQsICdzcGVjaWZpZWQgYXNzZXQgbXVzdCBiZSBpZGVudGljYWwgdG8gdGhlIGFzc2V0IGlkIGRlZmluZWQgYXMgYSByZXF1aXJlbWVudCB0byBzdGFrZScpCiAgICBkaWcgMTcKICAgIGFzc2VydCAvLyBzcGVjaWZpZWQgYXNzZXQgbXVzdCBiZSBpZGVudGljYWwgdG8gdGhlIGFzc2V0IGlkIGRlZmluZWQgYXMgYSByZXF1aXJlbWVudCB0byBzdGFrZQoKYWRkU3Rha2VfYWZ0ZXJfaWZfZWxzZUA0MjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNjcKICAgIC8vIGlmICh0eXBlLmFzVWludDY0KCkgPT09IEdBVElOR19UWVBFX0NSRUFURURfQllfTkZEX0FERFJFU1NFUykgewogICAgZGlnIDgKICAgIHB1c2hpbnQgMyAvLyAzCiAgICA9PQogICAgYnogYWRkU3Rha2VfYWZ0ZXJfaWZfZWxzZUA0NAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI3MQogICAgLy8gdGhpcy5pc0FkZHJlc3NJbk5GRENBQWxnb0xpc3QoY29uZmlnLmVudHJ5R2F0aW5nQXNzZXRzWzBdLCBBc3NldCh2YWx1ZVRvVmVyaWZ5KS5jcmVhdG9yKSwKICAgIGRpZyAyNwogICAgZXh0cmFjdCAwIDI0MgogICAgZXh0cmFjdCAxMTMgMzIKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDMKICAgIGFzc2V0X3BhcmFtc19nZXQgQXNzZXRDcmVhdG9yCiAgICBhc3NlcnQgLy8gYXNzZXQgZXhpc3RzCiAgICBjYWxsc3ViIGlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI3MC0xMjczCiAgICAvLyBhc3NlcnQoCiAgICAvLyAgICAgdGhpcy5pc0FkZHJlc3NJbk5GRENBQWxnb0xpc3QoY29uZmlnLmVudHJ5R2F0aW5nQXNzZXRzWzBdLCBBc3NldCh2YWx1ZVRvVmVyaWZ5KS5jcmVhdG9yKSwKICAgIC8vICAgICAnc3BlY2lmaWVkIGFzc2V0IG11c3QgYmUgY3JlYXRlZCBieSBjcmVhdG9yIHRoYXQgaXMgb25lIG9mIHRoZSBsaW5rZWQgYWRkcmVzc2VzIGluIGFuIG5mZCcsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gc3BlY2lmaWVkIGFzc2V0IG11c3QgYmUgY3JlYXRlZCBieSBjcmVhdG9yIHRoYXQgaXMgb25lIG9mIHRoZSBsaW5rZWQgYWRkcmVzc2VzIGluIGFuIG5mZAoKYWRkU3Rha2VfYWZ0ZXJfaWZfZWxzZUA0NDoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyNzUKICAgIC8vIGlmICh0eXBlLmFzVWludDY0KCkgPT09IEdBVElOR19UWVBFX1NFR01FTlRfT0ZfTkZEKSB7CiAgICBkaWcgOAogICAgcHVzaGludCA0IC8vIDQKICAgID09CiAgICBieiBhZGRTdGFrZV9hZnRlcl9pbmxpbmVkX2NvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5kb2VzU3Rha2VyTWVldEdhdGluZ0A1MQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4MgogICAgLy8gb3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXModXNlck9mZmVyZWRORkRBcHBJRCwgQnl0ZXMoJ2kub3duZXIuYScpKVswXSA9PT0gZW5jb2RlQXJjNChzdGFrZXIpIHx8CiAgICBkaWcgMgogICAgYnl0ZWMgOSAvLyAiaS5vd25lci5hIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZGlnIDIyCiAgICA9PQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4Mi0xMjgzCiAgICAvLyBvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyh1c2VyT2ZmZXJlZE5GREFwcElELCBCeXRlcygnaS5vd25lci5hJykpWzBdID09PSBlbmNvZGVBcmM0KHN0YWtlcikgfHwKICAgIC8vICAgICB0aGlzLmlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdCh1c2VyT2ZmZXJlZE5GREFwcElELCBzdGFrZXIpLAogICAgYm56IGFkZFN0YWtlX2Jvb2xfdHJ1ZUA0NwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTI4MwogICAgLy8gdGhpcy5pc0FkZHJlc3NJbk5GRENBQWxnb0xpc3QodXNlck9mZmVyZWRORkRBcHBJRCwgc3Rha2VyKSwKICAgIGRpZyAyCiAgICBkaWcgMjIKICAgIGNhbGxzdWIgaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjgyLTEyODMKICAgIC8vIG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKHVzZXJPZmZlcmVkTkZEQXBwSUQsIEJ5dGVzKCdpLm93bmVyLmEnKSlbMF0gPT09IGVuY29kZUFyYzQoc3Rha2VyKSB8fAogICAgLy8gICAgIHRoaXMuaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0KHVzZXJPZmZlcmVkTkZEQXBwSUQsIHN0YWtlciksCiAgICBieiBhZGRTdGFrZV9ib29sX2ZhbHNlQDQ4CgphZGRTdGFrZV9ib29sX3RydWVANDc6CiAgICBpbnRjXzEgLy8gMQoKYWRkU3Rha2VfYm9vbF9tZXJnZUA0OToKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyODEtMTI4NQogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKHVzZXJPZmZlcmVkTkZEQXBwSUQsIEJ5dGVzKCdpLm93bmVyLmEnKSlbMF0gPT09IGVuY29kZUFyYzQoc3Rha2VyKSB8fAogICAgLy8gICAgICAgICB0aGlzLmlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdCh1c2VyT2ZmZXJlZE5GREFwcElELCBzdGFrZXIpLAogICAgLy8gICAgICJwcm92aWRlZCBuZmQgZm9yIGVudHJ5IGlzbid0IG93bmVkIG9yIGxpbmtlZCB0byB0aGUgc3Rha2VyIiwKICAgIC8vICkKICAgIGFzc2VydCAvLyBwcm92aWRlZCBuZmQgZm9yIGVudHJ5IGlzbid0IG93bmVkIG9yIGxpbmtlZCB0byB0aGUgc3Rha2VyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjg5CiAgICAvLyBvcC5idG9pKG9wLkFwcEdsb2JhbC5nZXRFeEJ5dGVzKHVzZXJPZmZlcmVkTkZEQXBwSUQsIEJ5dGVzKCdpLnBhcmVudEFwcElEJykpWzBdKSA9PT0KICAgIGRpZyAyCiAgICBwdXNoYnl0ZXMgImkucGFyZW50QXBwSUQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICBidG9pCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjkwCiAgICAvLyBjb25maWcuZW50cnlHYXRpbmdBc3NldHNbMF0sCiAgICBkaWcgMjgKICAgIGV4dHJhY3QgMCAyNDIKICAgIGV4dHJhY3QgMTEzIDMyCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyODktMTI5MAogICAgLy8gb3AuYnRvaShvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyh1c2VyT2ZmZXJlZE5GREFwcElELCBCeXRlcygnaS5wYXJlbnRBcHBJRCcpKVswXSkgPT09CiAgICAvLyAgICAgY29uZmlnLmVudHJ5R2F0aW5nQXNzZXRzWzBdLAogICAgPT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyODgtMTI5MgogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIG9wLmJ0b2kob3AuQXBwR2xvYmFsLmdldEV4Qnl0ZXModXNlck9mZmVyZWRORkRBcHBJRCwgQnl0ZXMoJ2kucGFyZW50QXBwSUQnKSlbMF0pID09PQogICAgLy8gICAgICAgICBjb25maWcuZW50cnlHYXRpbmdBc3NldHNbMF0sCiAgICAvLyAgICAgJ3NwZWNpZmllZCBuZmQgbXVzdCBiZSBhIHNlZ21lbnQgb2YgdGhlIG5mZCB0aGUgdmFsaWRhdG9yIHNwZWNpZmllZCBhcyBhIHJlcXVpcmVtZW50JywKICAgIC8vICkKICAgIGFzc2VydCAvLyBzcGVjaWZpZWQgbmZkIG11c3QgYmUgYSBzZWdtZW50IG9mIHRoZSBuZmQgdGhlIHZhbGlkYXRvciBzcGVjaWZpZWQgYXMgYSByZXF1aXJlbWVudAoKYWRkU3Rha2VfYWZ0ZXJfaW5saW5lZF9jb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZG9lc1N0YWtlck1lZXRHYXRpbmdANTE6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1ODcKICAgIC8vIGxldCByZWFsQW1vdW50ID0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQKICAgIGRpZyA0CiAgICBndHhucyBBbW91bnQKICAgIGJ1cnkgMTEKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU4OAogICAgLy8gbGV0IG1ickFtdExlZnRCZWhpbmQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDEyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTEKICAgIC8vIHN0YWtlclBvb2xTZXQgPSBCb3hNYXA8QWNjb3VudCwgRml4ZWRBcnJheTxWYWxpZGF0b3JQb29sS2V5LCB0eXBlb2YgTUFYX1BPT0xTX1BFUl9TVEFLRVI+Pih7IGtleVByZWZpeDogJ3NwcycgfSkKICAgIGJ5dGVjIDYgLy8gInNwcyIKICAgIGRpZyAyMwogICAgY29uY2F0CiAgICBkdXAKICAgIGJ1cnkgMjcKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI5NAogICAgLy8gcmV0dXJuICF0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS5leGlzdHMKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTkwCiAgICAvLyBpZiAodGhpcy5kb2VzU3Rha2VyTmVlZFRvUGF5TUJSKHN0YWtlcikpIHsKICAgIGJ6IGFkZFN0YWtlX2lmX2JvZHlANAogICAgZGlnIDEwCiAgICBidXJ5IDEwCgphZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDU6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MDAKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuc3RhdGUudG90YWxBbGdvU3Rha2VkICsgcmVhbEFtb3VudCA8IHRoaXMubWF4QWxsb3dlZFN0YWtlKCksCiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBleHRyYWN0IDI0MiAyNgogICAgcHVzaGludCAxMCAvLyAxMAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAxMAogICAgZHVwCiAgICBjb3ZlciAyCiAgICArCiAgICBjYWxsc3ViIG1heEFsbG93ZWRTdGFrZQogICAgPAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTk5LTYwMgogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuc3RhdGUudG90YWxBbGdvU3Rha2VkICsgcmVhbEFtb3VudCA8IHRoaXMubWF4QWxsb3dlZFN0YWtlKCksCiAgICAvLyAgICAgJ3RvdGFsIHN0YWtlZCBmb3IgYWxsIG9mIGEgdmFsaWRhdG9ycyBwb29scyBtYXkgbm90IGV4Y2VlZCBoYXJkIGNhcCcsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gdG90YWwgc3Rha2VkIGZvciBhbGwgb2YgYSB2YWxpZGF0b3JzIHBvb2xzIG1heSBub3QgZXhjZWVkIGhhcmQgY2FwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MDYKICAgIC8vIGNvbnN0IGZpbmRSZXQgPSB0aGlzLmZpbmRQb29sRm9yU3Rha2VyKHZhbGlkYXRvcklkLCBzdGFrZXIsIHJlYWxBbW91bnQpCiAgICBkaWcgNAogICAgZGlnIDI0CiAgICB1bmNvdmVyIDIKICAgIGNhbGxzdWIgY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmZpbmRQb29sRm9yU3Rha2VyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MDcKICAgIC8vIGNvbnN0IHBvb2xLZXkgPSBjbG9uZShmaW5kUmV0WzBdKQogICAgZHVwCiAgICBleHRyYWN0IDAgMjQKICAgIGR1cAogICAgY292ZXIgMgogICAgYnVyeSAyNwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjA4CiAgICAvLyBjb25zdCBpc05ld1N0YWtlclRvVmFsaWRhdG9yID0gZmluZFJldFsxXQogICAgZHVwCiAgICBpbnRjIDkgLy8gMTkyCiAgICBnZXRiaXQKICAgIGJ1cnkgMTYKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYwOQogICAgLy8gY29uc3QgaXNOZXdTdGFrZXJUb1Byb3RvY29sID0gZmluZFJldFsyXQogICAgcHVzaGludCAxOTMgLy8gMTkzCiAgICBnZXRiaXQKICAgIGJ1cnkgMTYKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYxMAogICAgLy8gaWYgKHBvb2xLZXkucG9vbElkID09PSAwKSB7CiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYnVyeSA3CiAgICAhCiAgICAhCiAgICBhc3NlcnQgLy8gTm8gcG9vbCBhdmFpbGFibGUgd2l0aCBmcmVlIHN0YWtlLiAgVmFsaWRhdG9yIG5lZWRzIHRvIGFkZCBhbm90aGVyIHBvb2wKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDAKICAgIC8vIGFzc2VydCh0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS5leGlzdHMpCiAgICBkaWcgMjUKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDIKICAgIC8vIGNvbnN0IHBvb2xTZXQgPSBjbG9uZSh0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZSkKICAgIGJveF9nZXQKICAgIHBvcAogICAgYnVyeSAyNAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE0MwogICAgLy8gbGV0IGZpcnN0RW1wdHk6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDE5CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTQ0CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDE3CgphZGRTdGFrZV93aGlsZV90b3BANzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDQKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCB0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZS5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDI1CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkaWcgMTYKICAgIHB1c2hpbnQgNiAvLyA2CiAgICA8CiAgICBieiBhZGRTdGFrZV9hZnRlcl93aGlsZUAxNgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE0NgogICAgLy8gcG9vbFNldFtpXS5pZCA9PT0gcG9vbEtleS5pZCAmJgogICAgZGlnIDE2CiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICAqCiAgICBkaWcgMjQKICAgIHN3YXAKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgZHVwCiAgICBidXJ5IDI4CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYnVyeSA4CiAgICBkaWcgMjUKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgPT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDYtMTE0NwogICAgLy8gcG9vbFNldFtpXS5pZCA9PT0gcG9vbEtleS5pZCAmJgogICAgLy8gcG9vbFNldFtpXS5wb29sSWQgPT09IHBvb2xLZXkucG9vbElkICYmCiAgICBieiBhZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDEyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTQ3CiAgICAvLyBwb29sU2V0W2ldLnBvb2xJZCA9PT0gcG9vbEtleS5wb29sSWQgJiYKICAgIGRpZyAyNgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE0Ni0xMTQ3CiAgICAvLyBwb29sU2V0W2ldLmlkID09PSBwb29sS2V5LmlkICYmCiAgICAvLyBwb29sU2V0W2ldLnBvb2xJZCA9PT0gcG9vbEtleS5wb29sSWQgJiYKICAgIGludGNfMyAvLyA4CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTQ3CiAgICAvLyBwb29sU2V0W2ldLnBvb2xJZCA9PT0gcG9vbEtleS5wb29sSWQgJiYKICAgIGV4dHJhY3RfdWludDY0CiAgICBkaWcgNgogICAgPT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNDYtMTE0NwogICAgLy8gcG9vbFNldFtpXS5pZCA9PT0gcG9vbEtleS5pZCAmJgogICAgLy8gcG9vbFNldFtpXS5wb29sSWQgPT09IHBvb2xLZXkucG9vbElkICYmCiAgICBieiBhZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDEyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTQ4CiAgICAvLyBwb29sU2V0W2ldLnBvb2xBcHBJZCA9PT0gcG9vbEtleS5wb29sQXBwSWQKICAgIGRpZyAyNgogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAyNQogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgID09CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTQ2LTExNDgKICAgIC8vIHBvb2xTZXRbaV0uaWQgPT09IHBvb2xLZXkuaWQgJiYKICAgIC8vIHBvb2xTZXRbaV0ucG9vbElkID09PSBwb29sS2V5LnBvb2xJZCAmJgogICAgLy8gcG9vbFNldFtpXS5wb29sQXBwSWQgPT09IHBvb2xLZXkucG9vbEFwcElkCiAgICBibnogYWRkU3Rha2VfYWZ0ZXJfaW5saW5lZF9jb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkudXBkYXRlU3Rha2VyUG9vbFNldEAxNwoKYWRkU3Rha2VfYWZ0ZXJfaWZfZWxzZUAxMjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNTMKICAgIC8vIGlmIChmaXJzdEVtcHR5ID09PSAwICYmIHBvb2xTZXRbaV0uaWQgPT09IDApIHsKICAgIGRpZyAxOAogICAgYm56IGFkZFN0YWtlX2FmdGVyX2lmX2Vsc2VAMTUKICAgIGRpZyA2CiAgICBibnogYWRkU3Rha2VfYWZ0ZXJfaWZfZWxzZUAxNQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE1NAogICAgLy8gZmlyc3RFbXB0eSA9IGkgKyAxCiAgICBkaWcgMTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDE5CgphZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDE1OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE0NAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlLmxlbmd0aDsgaSArPSAxKSB7CiAgICBkaWcgMTYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDE3CiAgICBiIGFkZFN0YWtlX3doaWxlX3RvcEA3CgphZGRTdGFrZV9hZnRlcl9pbmxpbmVkX2NvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS51cGRhdGVTdGFrZXJQb29sU2V0QDE3OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEwMAogICAgLy8gY29uc3QgcG9vbEFwcElkID0gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0ucG9vbEFwcElkCiAgICBkaWcgMjQKICAgIGV4dHJhY3QgMCA4CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGJ1cnkgMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEwMAogICAgLy8gY29uc3QgcG9vbEFwcElkID0gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0ucG9vbEFwcElkCiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkaWcgNwogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIHN3YXAKICAgIGludGMgNCAvLyAyNjgKICAgIGludGMgNSAvLyA0MzIKICAgIGV4dHJhY3QzCiAgICBkaWcgMQogICAgaW50Y18yIC8vIDE4CiAgICAqCiAgICBzd2FwCiAgICBkaWcgMQogICAgaW50Y18yIC8vIDE4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEwNC0xMTE2CiAgICAvLyBhYmlDYWxsPHR5cGVvZiBTdGFraW5nUG9vbC5wcm90b3R5cGUuYWRkU3Rha2U+KHsKICAgIC8vICAgICBhcHBJZDogQXBwbGljYXRpb24ocG9vbEFwcElkKSwKICAgIC8vICAgICBhcmdzOiBbCiAgICAvLyAgICAgICAgIC8vID09PT09PT0KICAgIC8vICAgICAgICAgLy8gVEhJUyBJUyBBIFNFTkQgb2YgdGhlIGFtb3VudCByZWNlaXZlZCByaWdodCBiYWNrIG91dCBhbmQgaW50byB0aGUgc3Rha2luZyBwb29sIGNvbnRyYWN0IGFjY291bnQuCiAgICAvLyAgICAgICAgIGl0eG4ucGF5bWVudCh7CiAgICAvLyAgICAgICAgICAgICBhbW91bnQ6IHN0YWtlZEFtb3VudFBheW1lbnQuYW1vdW50IC0gbWJyQW10UGFpZCwKICAgIC8vICAgICAgICAgICAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihwb29sQXBwSWQpLmFkZHJlc3MsCiAgICAvLyAgICAgICAgIH0pLAogICAgLy8gICAgICAgICAvLyA9PT09PT09CiAgICAvLyAgICAgICAgIHN0YWtlZEFtb3VudFBheW1lbnQuc2VuZGVyLAogICAgLy8gICAgIF0sCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTExMAogICAgLy8gYW1vdW50OiBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCAtIG1ickFtdFBhaWQsCiAgICBkaWcgMTQKICAgIGRpZyAxNgogICAgLQogICAgZHVwCiAgICBjb3ZlciAyCiAgICBidXJ5IDIxCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTExCiAgICAvLyByZWNlaXZlcjogQXBwbGljYXRpb24ocG9vbEFwcElkKS5hZGRyZXNzLAogICAgZHVwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEwOS0xMTEyCiAgICAvLyBpdHhuLnBheW1lbnQoewogICAgLy8gICAgIGFtb3VudDogc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgLSBtYnJBbXRQYWlkLAogICAgLy8gICAgIHJlY2VpdmVyOiBBcHBsaWNhdGlvbihwb29sQXBwSWQpLmFkZHJlc3MsCiAgICAvLyB9KSwKICAgIGludGNfMSAvLyAxCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMDQtMTExNgogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZ1Bvb2wucHJvdG90eXBlLmFkZFN0YWtlPih7CiAgICAvLyAgICAgYXBwSWQ6IEFwcGxpY2F0aW9uKHBvb2xBcHBJZCksCiAgICAvLyAgICAgYXJnczogWwogICAgLy8gICAgICAgICAvLyA9PT09PT09CiAgICAvLyAgICAgICAgIC8vIFRISVMgSVMgQSBTRU5EIG9mIHRoZSBhbW91bnQgcmVjZWl2ZWQgcmlnaHQgYmFjayBvdXQgYW5kIGludG8gdGhlIHN0YWtpbmcgcG9vbCBjb250cmFjdCBhY2NvdW50LgogICAgLy8gICAgICAgICBpdHhuLnBheW1lbnQoewogICAgLy8gICAgICAgICAgICAgYW1vdW50OiBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCAtIG1ickFtdFBhaWQsCiAgICAvLyAgICAgICAgICAgICByZWNlaXZlcjogQXBwbGljYXRpb24ocG9vbEFwcElkKS5hZGRyZXNzLAogICAgLy8gICAgICAgICB9KSwKICAgIC8vICAgICAgICAgLy8gPT09PT09PQogICAgLy8gICAgICAgICBzdGFrZWRBbW91bnRQYXltZW50LnNlbmRlciwKICAgIC8vICAgICBdLAogICAgLy8gfSkKICAgIGl0eG5fbmV4dAogICAgcHVzaGJ5dGVzIDB4ZjljNzBjYmQgLy8gbWV0aG9kICJhZGRTdGFrZShwYXksYWRkcmVzcyl1aW50NjQiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDI0CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZHVwCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CiAgICBnaXR4biAxIExhc3RMb2cKICAgIGV4dHJhY3QgMCA0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgID09CiAgICBhc3NlcnQgLy8gQnl0ZXMgaGFzIHZhbGlkIHByZWZpeAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTExNwogICAgLy8gZW5zdXJlQnVkZ2V0KDUwMCkKICAgIHB1c2hpbnQgNTAwIC8vIDUwMAogICAgaW50Y18wIC8vIDAKICAgIGNhbGxzdWIgZW5zdXJlX2J1ZGdldAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEyMAogICAgLy8gY29uc3QgW3Bvb2xOdW1TdGFrZXJzLCBudW1TdGFrZXJzRGVmaW5lZF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQocG9vbEFwcElkLCBCeXRlcygnbnVtU3Rha2VycycpKQogICAgZHVwCiAgICBieXRlYyA0IC8vICJudW1TdGFrZXJzIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMjEKICAgIC8vIGNvbnN0IFtwb29sQWxnb1N0YWtlZCwgc3Rha2VkRGVmaW5lZF0gPSBvcC5BcHBHbG9iYWwuZ2V0RXhVaW50NjQocG9vbEFwcElkLCBCeXRlcygnc3Rha2VkJykpCiAgICB1bmNvdmVyIDIKICAgIGJ5dGVjXzMgLy8gInN0YWtlZCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTIyCiAgICAvLyBhc3NlcnQobnVtU3Rha2Vyc0RlZmluZWQpCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEyMwogICAgLy8gYXNzZXJ0KHN0YWtlZERlZmluZWQpCiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMjUKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1twb29sS2V5LnBvb2xJZCAtIDFdLnRvdGFsU3Rha2VycyA9IG5ldyBVaW50MTYocG9vbE51bVN0YWtlcnMpCiAgICBzd2FwCiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgcHVzaGludCAxNiAvLyAxNgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA2IDIKICAgIHVuY292ZXIgMwogICAgcHVzaGludCAyNCAvLyAyNAogICAgPAogICAgYXNzZXJ0IC8vIGluZGV4IG91dCBvZiBib3VuZHMKICAgIGRpZyAyCiAgICBwdXNoaW50IDI3NiAvLyAyNzYKICAgICsKICAgIGRpZyA0CiAgICBzd2FwCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTI2CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbEFsZ29TdGFrZWQgPSBwb29sQWxnb1N0YWtlZAogICAgaXRvYgogICAgc3dhcAogICAgaW50YyAxMyAvLyAyNzgKICAgICsKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTI5CiAgICAvLyBpZiAoaXNOZXdTdGFrZXJUb1ZhbGlkYXRvcikgewogICAgZGlnIDEzCiAgICBieiBhZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDIwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTMwCiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuc3RhdGUudG90YWxTdGFrZXJzICs9IDEKICAgIGR1cG4gMgogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGV4dHJhY3QgMjQyIDI2CiAgICBwdXNoaW50IDIgLy8gMgogICAgZXh0cmFjdF91aW50NjQKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBpdG9iCiAgICBwdXNoaW50IDI0NCAvLyAyNDQKICAgIHN3YXAKICAgIGJveF9yZXBsYWNlCgphZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDIwOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTEzMgogICAgLy8gaWYgKGlzTmV3U3Rha2VyVG9Qcm90b2NvbCkgewogICAgZGlnIDE0CiAgICBieiBhZGRTdGFrZV9hZnRlcl9pZl9lbHNlQDIyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTMzCiAgICAvLyB0aGlzLm51bVN0YWtlcnMudmFsdWUgKz0gMQogICAgaW50Y18wIC8vIDAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMAogICAgLy8gbnVtU3Rha2VycyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6ICdudW1TdGFrZXJzJyB9KQogICAgYnl0ZWMgNCAvLyAibnVtU3Rha2VycyIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMzMKICAgIC8vIHRoaXMubnVtU3Rha2Vycy52YWx1ZSArPSAxCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMAogICAgLy8gbnVtU3Rha2VycyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6ICdudW1TdGFrZXJzJyB9KQogICAgYnl0ZWMgNCAvLyAibnVtU3Rha2VycyIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMzMKICAgIC8vIHRoaXMubnVtU3Rha2Vycy52YWx1ZSArPSAxCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAoKYWRkU3Rha2VfYWZ0ZXJfaWZfZWxzZUAyMjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMzUKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5zdGF0ZS50b3RhbEFsZ29TdGFrZWQgKz0gc3Rha2VkQW1vdW50UGF5bWVudC5hbW91bnQgLSBtYnJBbXRQYWlkCiAgICBkdXBuIDIKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBleHRyYWN0IDI0MiAyNgogICAgcHVzaGludCAxMCAvLyAxMAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAxNwogICAgZHVwCiAgICBjb3ZlciAyCiAgICArCiAgICBpdG9iCiAgICB1bmNvdmVyIDIKICAgIGludGMgMTQgLy8gMjUyCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTM2CiAgICAvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSArPSBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCAtIG1ickFtdFBhaWQKICAgIGludGNfMCAvLyAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDMKICAgIC8vIHRvdGFsQWxnb1N0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6ICdzdGFrZWQnIH0pCiAgICBieXRlY18zIC8vICJzdGFrZWQiCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTM2CiAgICAvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSArPSBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCAtIG1ickFtdFBhaWQKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICArCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDMKICAgIC8vIHRvdGFsQWxnb1N0YWtlZCA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6ICdzdGFrZWQnIH0pCiAgICBieXRlY18zIC8vICJzdGFrZWQiCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTM2CiAgICAvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSArPSBzdGFrZWRBbW91bnRQYXltZW50LmFtb3VudCAtIG1ickFtdFBhaWQKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2MjcKICAgIC8vIHBvb2xOdW06IG5ldyBVaW50MTYocG9vbEtleS5wb29sSWQpLAogICAgZGlnIDUKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDYgMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjI4CiAgICAvLyBwb29sQXBwSWQ6IHBvb2xLZXkucG9vbEFwcElkLAogICAgZGlnIDI1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGV4dHJhY3QgMTYgOAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjI1LTYzMQogICAgLy8gZW1pdDxyZXRpT1Bfc3Rha2VBZGRlZD4oewogICAgLy8gICAgIGlkOiB2YWxpZGF0b3JJZCwKICAgIC8vICAgICBwb29sTnVtOiBuZXcgVWludDE2KHBvb2xLZXkucG9vbElkKSwKICAgIC8vICAgICBwb29sQXBwSWQ6IHBvb2xLZXkucG9vbEFwcElkLAogICAgLy8gICAgIGFtb3VudFN0YWtlZDogcmVhbEFtb3VudCwKICAgIC8vICAgICBzdGFrZXI6IHN0YWtlciwKICAgIC8vIH0pCiAgICBkaWcgNAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZGlnIDI0CiAgICBjb25jYXQKICAgIGRpZyAxMQogICAgaXRvYgogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHg5NjJiNDE0MyAvLyBtZXRob2QgInJldGlPUF9zdGFrZUFkZGVkKHVpbnQ2NCx1aW50MTYsdWludDY0LGFkZHJlc3MsdWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1NTctNTYxCiAgICAvLyBhZGRTdGFrZSgKICAgIC8vICAgICBzdGFrZWRBbW91bnRQYXltZW50OiBndHhuLlBheW1lbnRUeG4sCiAgICAvLyAgICAgdmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwKICAgIC8vICAgICB2YWx1ZVRvVmVyaWZ5OiB1aW50NjQsCiAgICAvLyApOiBWYWxpZGF0b3JQb29sS2V5IHsKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCmFkZFN0YWtlX2FmdGVyX3doaWxlQDE2OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE1NwogICAgLy8gaWYgKGZpcnN0RW1wdHkgPT09IDApIHsKICAgIGRpZyAxOAogICAgZHVwCiAgICAhCiAgICAhCiAgICBhc3NlcnQgLy8gTm8gZW1wdHkgc2xvdCBhdmFpbGFibGUgaW4gdGhlIHN0YWtlciBwb29sIHNldAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE2MAogICAgLy8gdGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWVbZmlyc3RFbXB0eSAtIDFdID0gY2xvbmUocG9vbEtleSkKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICAqCiAgICBkaWcgMjYKICAgIHN3YXAKICAgIGRpZyAyNgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjYxNQogICAgLy8gdGhpcy51cGRhdGVTdGFrZXJQb29sU2V0KHN0YWtlciwgcG9vbEtleSkKICAgIGIgYWRkU3Rha2VfYWZ0ZXJfaW5saW5lZF9jb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkudXBkYXRlU3Rha2VyUG9vbFNldEAxNwoKYWRkU3Rha2VfaWZfYm9keUA0OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NTkzCiAgICAvLyBtYnJBbXRMZWZ0QmVoaW5kID0gdGhpcy5nZXRNYnJBbW91bnRzKCkuYWRkU3Rha2VyTWJyCiAgICBpbnRjIDE1IC8vIDc0MTAwCiAgICBidXJ5IDEyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1OTQKICAgIC8vIHJlYWxBbW91bnQgLT0gbWJyQW10TGVmdEJlaGluZAogICAgZGlnIDEwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1OTMKICAgIC8vIG1ickFtdExlZnRCZWhpbmQgPSB0aGlzLmdldE1ickFtb3VudHMoKS5hZGRTdGFrZXJNYnIKICAgIGludGMgMTUgLy8gNzQxMDAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjU5NAogICAgLy8gcmVhbEFtb3VudCAtPSBtYnJBbXRMZWZ0QmVoaW5kCiAgICAtCiAgICBidXJ5IDEwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo1OTUKICAgIC8vIHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLmNyZWF0ZSgpCiAgICBkaWcgMjUKICAgIHB1c2hpbnQgMTQ0IC8vIDE0NAogICAgYm94X2NyZWF0ZQogICAgcG9wCiAgICBiIGFkZFN0YWtlX2FmdGVyX2lmX2Vsc2VANQoKYWRkU3Rha2VfYm9vbF9mYWxzZUA0ODoKICAgIGludGNfMCAvLyAwCiAgICBiIGFkZFN0YWtlX2Jvb2xfbWVyZ2VANDkKCmFkZFN0YWtlX2FmdGVyX2lmX2Vsc2VAMzk6CiAgICBkaWcgMTIKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDEzCiAgICBiIGFkZFN0YWtlX2Zvcl9oZWFkZXJAMzYKCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuc2V0VG9rZW5QYXlvdXRSYXRpb1tyb3V0aW5nXSgpIC0+IHZvaWQ6CnNldFRva2VuUGF5b3V0UmF0aW86CiAgICBpbnRjXzAgLy8gMAogICAgYnl0ZWNfMiAvLyAiIgogICAgZHVwbiAzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NTEKICAgIC8vIHNldFRva2VuUGF5b3V0UmF0aW8odmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IFBvb2xUb2tlblBheW91dFJhdGlvIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY1MwogICAgLy8gY29uc3QgcG9vbDFBcHBJRCA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHNbMF0ucG9vbEFwcElkCiAgICBpdG9iCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY1MwogICAgLy8gY29uc3QgcG9vbDFBcHBJRCA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUucG9vbHNbMF0ucG9vbEFwcElkCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50YyA0IC8vIDI2OAogICAgaW50YyA1IC8vIDQzMgogICAgZXh0cmFjdDMKICAgIGV4dHJhY3QgMCAxOCAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwbiAyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NTQKICAgIC8vIGFzc2VydChwb29sMUFwcElEICE9PSAwKQogICAgYXNzZXJ0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NTYKICAgIC8vIGlmIChUeG4uc2VuZGVyICE9PSBBcHBsaWNhdGlvbihwb29sMUFwcElEKS5hZGRyZXNzKSB7CiAgICB0eG4gU2VuZGVyCiAgICBzd2FwCiAgICBhcHBfcGFyYW1zX2dldCBBcHBBZGRyZXNzCiAgICBhc3NlcnQgLy8gYXBwbGljYXRpb24gZXhpc3RzCiAgICAhPQogICAgYnogc2V0VG9rZW5QYXlvdXRSYXRpb19hZnRlcl9pZl9lbHNlQDMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY1NwogICAgLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUudG9rZW5QYXlvdXRSYXRpbwogICAgZGlnIDEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjIDcgLy8gNzAwCiAgICBpbnRjIDYgLy8gMjAwCiAgICBleHRyYWN0MwoKc2V0VG9rZW5QYXlvdXRSYXRpb19hZnRlcl9pbmxpbmVkX2NvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5zZXRUb2tlblBheW91dFJhdGlvQDEzOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjUxCiAgICAvLyBzZXRUb2tlblBheW91dFJhdGlvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiBQb29sVG9rZW5QYXlvdXRSYXRpbyB7CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgpzZXRUb2tlblBheW91dFJhdGlvX2FmdGVyX2lmX2Vsc2VAMzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY2MwogICAgLy8gY29uc3QgY3VyUm91bmQgPSBHbG9iYWwucm91bmQKICAgIGdsb2JhbCBSb3VuZAogICAgYnVyeSA1CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NjQKICAgIC8vIGNvbnN0IGxhc3RQYXlvdXRVcGRhdGUgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8udXBkYXRlZEZvclBheW91dAogICAgZGlnIDEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjIDcgLy8gNzAwCiAgICBpbnRjIDYgLy8gMjAwCiAgICBleHRyYWN0MwogICAgaW50YyA5IC8vIDE5MgogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYnVyeSA0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NjUKICAgIC8vIGlmIChsYXN0UGF5b3V0VXBkYXRlICE9PSAwKSB7CiAgICBieiBzZXRUb2tlblBheW91dFJhdGlvX2FmdGVyX2lmX2Vsc2VAOQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjY3CiAgICAvLyBpZiAob3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHBvb2wxQXBwSUQsIEJ5dGVzKCdsYXN0UGF5b3V0JykpWzBdID09PSBsYXN0UGF5b3V0VXBkYXRlKSB7CiAgICBkdXAKICAgIHB1c2hieXRlcyAibGFzdFBheW91dCIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBwb3AKICAgIGRpZyAzCiAgICA9PQogICAgYnogc2V0VG9rZW5QYXlvdXRSYXRpb19hZnRlcl9pZl9lbHNlQDYKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY2OAogICAgLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUudG9rZW5QYXlvdXRSYXRpbwogICAgZGlnIDEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjIDcgLy8gNzAwCiAgICBpbnRjIDYgLy8gMjAwCiAgICBleHRyYWN0MwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjUxCiAgICAvLyBzZXRUb2tlblBheW91dFJhdGlvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiBQb29sVG9rZW5QYXlvdXRSYXRpbyB7CiAgICBiIHNldFRva2VuUGF5b3V0UmF0aW9fYWZ0ZXJfaW5saW5lZF9jb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuc2V0VG9rZW5QYXlvdXRSYXRpb0AxMwoKc2V0VG9rZW5QYXlvdXRSYXRpb19hZnRlcl9pZl9lbHNlQDY6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NzAKICAgIC8vIGNvbnN0IGVwb2NoUm91bmRMZW5ndGggPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5lcG9jaFJvdW5kTGVuZ3RoLmFzVWludDY0KCkKICAgIGRpZyAxCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZXh0cmFjdCAwIDI0MgogICAgcHVzaGludCAxNjkgLy8gMTY5CiAgICBleHRyYWN0X3VpbnQzMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjcxCiAgICAvLyBjb25zdCB0aGlzRXBvY2hCZWdpbjogdWludDY0ID0gY3VyUm91bmQgLSAoY3VyUm91bmQgJSBlcG9jaFJvdW5kTGVuZ3RoKQogICAgZGlnIDUKICAgIGR1cAogICAgY292ZXIgMgogICAgZGlnIDEKICAgICUKICAgIHVuY292ZXIgMgogICAgc3dhcAogICAgLQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjczCiAgICAvLyBpZiAobGFzdFBheW91dFVwZGF0ZSAtIChsYXN0UGF5b3V0VXBkYXRlICUgZXBvY2hSb3VuZExlbmd0aCkgPT09IHRoaXNFcG9jaEJlZ2luKSB7CiAgICBkaWcgNAogICAgZHVwCiAgICB1bmNvdmVyIDMKICAgICUKICAgIC0KICAgID09CiAgICBieiBzZXRUb2tlblBheW91dFJhdGlvX2FmdGVyX2lmX2Vsc2VAOQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Njc0CiAgICAvLyByZXR1cm4gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvCiAgICBkaWcgMQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGMgNyAvLyA3MDAKICAgIGludGMgNiAvLyAyMDAKICAgIGV4dHJhY3QzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2NTEKICAgIC8vIHNldFRva2VuUGF5b3V0UmF0aW8odmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IFBvb2xUb2tlblBheW91dFJhdGlvIHsKICAgIGIgc2V0VG9rZW5QYXlvdXRSYXRpb19hZnRlcl9pbmxpbmVkX2NvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5zZXRUb2tlblBheW91dFJhdGlvQDEzCgpzZXRUb2tlblBheW91dFJhdGlvX2FmdGVyX2lmX2Vsc2VAOToKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY3NwogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS50b2tlblBheW91dFJhdGlvLnVwZGF0ZWRGb3JQYXlvdXQgPSBjdXJSb3VuZAogICAgZGlnIDQKICAgIGl0b2IKICAgIGRpZyAyCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHB1c2hpbnQgODkyIC8vIDg5MgogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Njc5CiAgICAvLyBjb25zdCBjdXJOdW1Qb29scyA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuc3RhdGUubnVtUG9vbHMuYXNVaW50NjQoKQogICAgYm94X2dldAogICAgcG9wCiAgICBleHRyYWN0IDI0MiAyNgogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIGJ1cnkgNwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjgwCiAgICAvLyBjb25zdCB0b3RhbFN0YWtlRm9yVmFsaWRhdG9yID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZS50b3RhbEFsZ29TdGFrZWQKICAgIGV4dHJhY3QgMTAgOAogICAgYnVyeSA3CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2ODEKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBjdXJOdW1Qb29sczsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSA0CgpzZXRUb2tlblBheW91dFJhdGlvX3doaWxlX3RvcEAxMDoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY4MQogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGN1ck51bVBvb2xzOyBpICs9IDEpIHsKICAgIGRpZyAzCiAgICBkaWcgNgogICAgPAogICAgYnogc2V0VG9rZW5QYXlvdXRSYXRpb19hZnRlcl93aGlsZUAxMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Njg3CiAgICAvLyBbdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1tpXS50b3RhbEFsZ29TdGFrZWQsIDFfMDAwXzAwMF0sCiAgICBkaWcgMQogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgaW50YyA0IC8vIDI2OAogICAgaW50YyA1IC8vIDQzMgogICAgZXh0cmFjdDMKICAgIGRpZyA1CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludGNfMiAvLyAxOAogICAgKgogICAgaW50Y18yIC8vIDE4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGV4dHJhY3QgMTAgOAogICAgYnl0ZWMgMTEgLy8gMHgwMDAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGludGMgMTAgLy8gMTAwMDAwMAogICAgaXRvYgogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2ODgKICAgIC8vIFt0b3RhbFN0YWtlRm9yVmFsaWRhdG9yXSwKICAgIHB1c2hieXRlcyAweDAwMDEKICAgIGRpZyAxMAogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo2ODYtNjg5CiAgICAvLyBjb25zdCBvdXJQb29sUGN0T2ZXaG9sZSA9IHdpZGVSYXRpbygKICAgIC8vICAgICBbdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1tpXS50b3RhbEFsZ29TdGFrZWQsIDFfMDAwXzAwMF0sCiAgICAvLyAgICAgW3RvdGFsU3Rha2VGb3JWYWxpZGF0b3JdLAogICAgLy8gKQogICAgY2FsbHN1YiB3aWRlUmF0aW8KICAgIHBvcG4gMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjkwCiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnRva2VuUGF5b3V0UmF0aW8ucG9vbFBjdE9mV2hvbGVbaV0gPSBvdXJQb29sUGN0T2ZXaG9sZQogICAgaXRvYgogICAgZGlnIDEKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIDwKICAgIGFzc2VydCAvLyBpbmRleCBvdXQgb2YgYm91bmRzCiAgICBkaWcgMQogICAgaW50Y18zIC8vIDgKICAgICoKICAgIGludGMgNyAvLyA3MDAKICAgICsKICAgIHVuY292ZXIgMwogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjgxCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgY3VyTnVtUG9vbHM7IGkgKz0gMSkgewogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgNAogICAgYiBzZXRUb2tlblBheW91dFJhdGlvX3doaWxlX3RvcEAxMAoKc2V0VG9rZW5QYXlvdXRSYXRpb19hZnRlcl93aGlsZUAxMjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjY5MgogICAgLy8gcmV0dXJuIHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUudG9rZW5QYXlvdXRSYXRpbwogICAgZGlnIDEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjIDcgLy8gNzAwCiAgICBpbnRjIDYgLy8gMjAwCiAgICBleHRyYWN0MwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NjUxCiAgICAvLyBzZXRUb2tlblBheW91dFJhdGlvKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiBQb29sVG9rZW5QYXlvdXRSYXRpbyB7CiAgICBiIHNldFRva2VuUGF5b3V0UmF0aW9fYWZ0ZXJfaW5saW5lZF9jb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuc2V0VG9rZW5QYXlvdXRSYXRpb0AxMwoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5zdGFrZVVwZGF0ZWRWaWFSZXdhcmRzW3JvdXRpbmddKCkgLT4gdm9pZDoKc3Rha2VVcGRhdGVkVmlhUmV3YXJkczoKICAgIGludGNfMCAvLyAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MDYtNzEyCiAgICAvLyBzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzKAogICAgLy8gICAgIHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXksCiAgICAvLyAgICAgYWxnb1RvQWRkOiB1aW50NjQsCiAgICAvLyAgICAgcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZDogdWludDY0LAogICAgLy8gICAgIHZhbGlkYXRvckNvbW1pc3Npb246IHVpbnQ2NCwKICAgIC8vICAgICBzYXR1cmF0ZWRCdXJuVG9GZWVTaW5rOiB1aW50NjQsCiAgICAvLyApOiB2b2lkIHsKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIGJ0b2kKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDMKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGJ0b2kKICAgIGNvdmVyIDMKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDUKICAgIGJ0b2kKICAgIGNvdmVyIDMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcxMwogICAgLy8gdGhpcy52ZXJpZnlQb29sS2V5Q2FsbGVyKHBvb2xLZXkpCiAgICBjYWxsc3ViIHZlcmlmeVBvb2xLZXlDYWxsZXIKICAgIGR1cAogICAgY292ZXIgMwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzE2CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbEFsZ29TdGFrZWQgKz0gYWxnb1RvQWRkCiAgICBkdXAKICAgIGV4dHJhY3QgMCA4CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgY292ZXIgNAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzE2CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbEFsZ29TdGFrZWQgKz0gYWxnb1RvQWRkCiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICB1bmNvdmVyIDIKICAgIGludGNfMyAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBjb3ZlciA1CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgc3dhcAogICAgaW50YyA0IC8vIDI2OAogICAgaW50YyA1IC8vIDQzMgogICAgZXh0cmFjdDMKICAgIGRpZyAxCiAgICBpbnRjXzIgLy8gMTgKICAgICoKICAgIHN3YXAKICAgIGRpZyAxCiAgICBpbnRjXzIgLy8gMTgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgcHVzaGludCAxMCAvLyAxMAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyA0CiAgICArCiAgICBpdG9iCiAgICB1bmNvdmVyIDIKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgIDwKICAgIGFzc2VydCAvLyBpbmRleCBvdXQgb2YgYm91bmRzCiAgICBzd2FwCiAgICBpbnRjIDEzIC8vIDI3OAogICAgKwogICAgZGlnIDIKICAgIHN3YXAKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcxNwogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnRvdGFsQWxnb1N0YWtlZCArPSBhbGdvVG9BZGQKICAgIGR1cAogICAgYm94X2dldAogICAgcG9wCiAgICBleHRyYWN0IDI0MiAyNgogICAgcHVzaGludCAxMCAvLyAxMAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAyCiAgICArCiAgICBpdG9iCiAgICBkaWcgMQogICAgaW50YyAxNCAvLyAyNTIKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcxOAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnJld2FyZFRva2VuSGVsZEJhY2sgKz0gcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZAogICAgZHVwCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGV4dHJhY3QgMjQyIDI2CiAgICBpbnRjXzIgLy8gMTgKICAgIGV4dHJhY3RfdWludDY0CiAgICB1bmNvdmVyIDMKICAgICsKICAgIGl0b2IKICAgIGRpZyAxCiAgICBwdXNoaW50IDI2MCAvLyAyNjAKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcyMAogICAgLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgKz0gYWxnb1RvQWRkCiAgICBpbnRjXzAgLy8gMAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAzCiAgICAvLyB0b3RhbEFsZ29TdGFrZWQgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiAnc3Rha2VkJyB9KQogICAgYnl0ZWNfMyAvLyAic3Rha2VkIgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzIwCiAgICAvLyB0aGlzLnRvdGFsQWxnb1N0YWtlZC52YWx1ZSArPSBhbGdvVG9BZGQKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gY2hlY2sgR2xvYmFsU3RhdGUgZXhpc3RzCiAgICB1bmNvdmVyIDIKICAgICsKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMwogICAgLy8gdG90YWxBbGdvU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogJ3N0YWtlZCcgfSkKICAgIGJ5dGVjXzMgLy8gInN0YWtlZCIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcyMAogICAgLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgKz0gYWxnb1RvQWRkCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAyOAogICAgLy8gY29uc3QgdmFsaWRhdG9yQ29uZmlnID0gY2xvbmUodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcpCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMjgtMTAyOQogICAgLy8gY29uc3QgdmFsaWRhdG9yQ29uZmlnID0gY2xvbmUodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcpCiAgICAvLyBpZiAodmFsaWRhdG9yQ29uZmlnLm5mZEZvckluZm8gIT09IDApIHsKICAgIGV4dHJhY3QgMCAyNDIKICAgIGR1cAogICAgcHVzaGludCA3MiAvLyA3MgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAyOQogICAgLy8gaWYgKHZhbGlkYXRvckNvbmZpZy5uZmRGb3JJbmZvICE9PSAwKSB7CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBieiBzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAzMwogICAgLy8gY29uc3QgbmZkT3duZXIgPSBuZXcgQWRkcmVzcyhvcC5BcHBHbG9iYWwuZ2V0RXhCeXRlcyh2YWxpZGF0b3JDb25maWcubmZkRm9ySW5mbywgQnl0ZXMoJ2kub3duZXIuYScpKVswXSkKICAgIGR1cAogICAgYnl0ZWMgOSAvLyAiaS5vd25lci5hIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZHVwCiAgICBidXJ5IDEyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDM3CiAgICAvLyBpZiAodmFsaWRhdG9yQ29uZmlnLm93bmVyICE9PSBuZmRPd25lciAmJiB2YWxpZGF0b3JDb25maWcubWFuYWdlciAhPT0gbmZkT3duZXIpIHsKICAgIGRpZyAyCiAgICBleHRyYWN0IDggMzIKICAgICE9CiAgICBieiBzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANQogICAgZGlnIDEKICAgIGV4dHJhY3QgNDAgMzIKICAgIGRpZyAxMQogICAgIT0KICAgIGJ6IHN0YWtlVXBkYXRlZFZpYVJld2FyZHNfYWZ0ZXJfaWZfZWxzZUA1CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDM5CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5uZmRGb3JJbmZvID0gMAogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGRpZyA0CiAgICBwdXNoaW50IDcyIC8vIDcyCiAgICB1bmNvdmVyIDIKICAgIGJveF9yZXBsYWNlCgpzdGFrZVVwZGF0ZWRWaWFSZXdhcmRzX2FmdGVyX2lmX2Vsc2VANToKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcyNwogICAgLy8gcG9vbE51bTogbmV3IFVpbnQxNihwb29sS2V5LnBvb2xJZCksCiAgICBkaWcgMgogICAgaXRvYgogICAgZHVwCiAgICBiaXRsZW4KICAgIHB1c2hpbnQgMTYgLy8gMTYKICAgIDw9CiAgICBhc3NlcnQgLy8gb3ZlcmZsb3cKICAgIGV4dHJhY3QgNiAyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MjgKICAgIC8vIHBvb2xBcHBJZDogcG9vbEtleS5wb29sQXBwSWQsCiAgICBkaWcgNgogICAgZXh0cmFjdCAxNiA4CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3MjUtNzMzCiAgICAvLyBlbWl0PHJldGlPUF9lcG9jaFJld2FyZFVwZGF0ZT4oewogICAgLy8gICAgIGlkOiBwb29sS2V5LmlkLAogICAgLy8gICAgIHBvb2xOdW06IG5ldyBVaW50MTYocG9vbEtleS5wb29sSWQpLAogICAgLy8gICAgIHBvb2xBcHBJZDogcG9vbEtleS5wb29sQXBwSWQsCiAgICAvLyAgICAgYWxnb0FkZGVkOiBhbGdvVG9BZGQsCiAgICAvLyAgICAgcmV3YXJkVG9rZW5IZWxkQmFjazogcmV3YXJkVG9rZW5BbW91bnRSZXNlcnZlZCwKICAgIC8vICAgICBzYXR1cmF0ZWRCdXJuVG9GZWVTaW5rOiBzYXR1cmF0ZWRCdXJuVG9GZWVTaW5rLAogICAgLy8gICAgIHZhbGlkYXRvckNvbW1pc3Npb246IHZhbGlkYXRvckNvbW1pc3Npb24sCiAgICAvLyB9KQogICAgZGlnIDYKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGRpZyA4CiAgICBpdG9iCiAgICBjb25jYXQKICAgIGRpZyA3CiAgICBpdG9iCiAgICBjb25jYXQKICAgIGRpZyAxMAogICAgaXRvYgogICAgY29uY2F0CiAgICBkaWcgOQogICAgaXRvYgogICAgY29uY2F0CiAgICBwdXNoYnl0ZXMgMHhiM2U0N2MzZCAvLyBtZXRob2QgInJldGlPUF9lcG9jaFJld2FyZFVwZGF0ZSh1aW50NjQsdWludDE2LHVpbnQ2NCx1aW50NjQsdWludDY0LHVpbnQ2NCx1aW50NjQpIgogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjcwNi03MTIKICAgIC8vIHN0YWtlVXBkYXRlZFZpYVJld2FyZHMoCiAgICAvLyAgICAgcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleSwKICAgIC8vICAgICBhbGdvVG9BZGQ6IHVpbnQ2NCwKICAgIC8vICAgICByZXdhcmRUb2tlbkFtb3VudFJlc2VydmVkOiB1aW50NjQsCiAgICAvLyAgICAgdmFsaWRhdG9yQ29tbWlzc2lvbjogdWludDY0LAogICAgLy8gICAgIHNhdHVyYXRlZEJ1cm5Ub0ZlZVNpbms6IHVpbnQ2NCwKICAgIC8vICk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5zdGFrZVJlbW92ZWRbcm91dGluZ10oKSAtPiB2b2lkOgpzdGFrZVJlbW92ZWQ6CiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA1CiAgICBieXRlY18yIC8vICIiCiAgICBkdXBuIDEwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NDgtNzU0CiAgICAvLyBzdGFrZVJlbW92ZWQoCiAgICAvLyAgICAgcG9vbEtleTogVmFsaWRhdG9yUG9vbEtleSwKICAgIC8vICAgICBzdGFrZXI6IEFjY291bnQsCiAgICAvLyAgICAgYW1vdW50UmVtb3ZlZDogdWludDY0LAogICAgLy8gICAgIHJld2FyZFJlbW92ZWQ6IHVpbnQ2NCwKICAgIC8vICAgICBzdGFrZXJSZW1vdmVkOiBib29sZWFuLAogICAgLy8gKTogdm9pZCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICBkdXAKICAgIGNvdmVyIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDQKICAgIGR1cAogICAgY292ZXIgMwogICAgYnRvaQogICAgY292ZXIgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgY292ZXIgMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzU1CiAgICAvLyBlbnN1cmVCdWRnZXQoMzAwKQogICAgcHVzaGludCAzMDAgLy8gMzAwCiAgICBpbnRjXzAgLy8gMAogICAgY2FsbHN1YiBlbnN1cmVfYnVkZ2V0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NTYKICAgIC8vIHRoaXMudmVyaWZ5UG9vbEtleUNhbGxlcihwb29sS2V5KQogICAgc3dhcAogICAgY2FsbHN1YiB2ZXJpZnlQb29sS2V5Q2FsbGVyCiAgICBzd2FwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NjAKICAgIC8vIGFzc2VydChhbW91bnRSZW1vdmVkID4gMCB8fCByZXdhcmRSZW1vdmVkID4gMCwgJ3Nob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBhbGdvIG9yIHJld2FyZCB3YXMgcmVtb3ZlZCcpCiAgICBibnogc3Rha2VSZW1vdmVkX2Jvb2xfdHJ1ZUAzCiAgICBkaWcgMgogICAgYnogc3Rha2VSZW1vdmVkX2Jvb2xfZmFsc2VANAoKc3Rha2VSZW1vdmVkX2Jvb2xfdHJ1ZUAzOgogICAgaW50Y18xIC8vIDEKCnN0YWtlUmVtb3ZlZF9ib29sX21lcmdlQDU6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NjAKICAgIC8vIGFzc2VydChhbW91bnRSZW1vdmVkID4gMCB8fCByZXdhcmRSZW1vdmVkID4gMCwgJ3Nob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBhbGdvIG9yIHJld2FyZCB3YXMgcmVtb3ZlZCcpCiAgICBhc3NlcnQgLy8gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIGFsZ28gb3IgcmV3YXJkIHdhcyByZW1vdmVkCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3NjMKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5wb29sc1twb29sS2V5LnBvb2xJZCAtIDFdLnRvdGFsQWxnb1N0YWtlZCAtPSBhbW91bnRSZW1vdmVkCiAgICBkdXBuIDIKICAgIGV4dHJhY3QgMCA4CiAgICBkdXAKICAgIGJ1cnkgMjEKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgYnVyeSAyMwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzYzCiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbEFsZ29TdGFrZWQgLT0gYW1vdW50UmVtb3ZlZAogICAgZHVwCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgdW5jb3ZlciAyCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgYnVyeSAxMAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIHN3YXAKICAgIGludGMgNCAvLyAyNjgKICAgIGludGMgNSAvLyA0MzIKICAgIGV4dHJhY3QzCiAgICBkaWcgMQogICAgaW50Y18yIC8vIDE4CiAgICAqCiAgICBkdXAKICAgIGJ1cnkgMjEKICAgIHN3YXAKICAgIGRpZyAxCiAgICBpbnRjXzIgLy8gMTgKICAgIGV4dHJhY3QzIC8vIG9uIGVycm9yOiBpbmRleCBhY2Nlc3MgaXMgb3V0IG9mIGJvdW5kcwogICAgcHVzaGludCAxMCAvLyAxMAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyA4CiAgICBkdXAKICAgIGNvdmVyIDQKICAgIC0KICAgIGl0b2IKICAgIHVuY292ZXIgMgogICAgcHVzaGludCAyNCAvLyAyNAogICAgPAogICAgYXNzZXJ0IC8vIGluZGV4IG91dCBvZiBib3VuZHMKICAgIHN3YXAKICAgIGludGMgMTMgLy8gMjc4CiAgICArCiAgICBkaWcgMwogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzY0CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuc3RhdGUudG90YWxBbGdvU3Rha2VkIC09IGFtb3VudFJlbW92ZWQKICAgIGRpZyAxCiAgICBib3hfZ2V0CiAgICBwb3AKICAgIGV4dHJhY3QgMjQyIDI2CiAgICBwdXNoaW50IDEwIC8vIDEwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIC0KICAgIGl0b2IKICAgIHVuY292ZXIgMgogICAgaW50YyAxNCAvLyAyNTIKICAgIHVuY292ZXIgMgogICAgYm94X3JlcGxhY2UKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc2NQogICAgLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgLT0gYW1vdW50UmVtb3ZlZAogICAgaW50Y18wIC8vIDAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMwogICAgLy8gdG90YWxBbGdvU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogJ3N0YWtlZCcgfSkKICAgIGJ5dGVjXzMgLy8gInN0YWtlZCIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc2NQogICAgLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgLT0gYW1vdW50UmVtb3ZlZAogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBjaGVjayBHbG9iYWxTdGF0ZSBleGlzdHMKICAgIHN3YXAKICAgIC0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMwogICAgLy8gdG90YWxBbGdvU3Rha2VkID0gR2xvYmFsU3RhdGU8dWludDY0Pih7IGtleTogJ3N0YWtlZCcgfSkKICAgIGJ5dGVjXzMgLy8gInN0YWtlZCIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc2NQogICAgLy8gdGhpcy50b3RhbEFsZ29TdGFrZWQudmFsdWUgLT0gYW1vdW50UmVtb3ZlZAogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc2NwogICAgLy8gaWYgKHJld2FyZFJlbW92ZWQgPiAwKSB7CiAgICBkaWcgMgogICAgYnogc3Rha2VSZW1vdmVkX2Vsc2VfYm9keUAxMAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzY4CiAgICAvLyBjb25zdCByZXdhcmRUb2tlbklEID0gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLmNvbmZpZy5yZXdhcmRUb2tlbklkCiAgICBkaWcgMjAKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgZXh0cmFjdCAwIDI0MgogICAgZHVwCiAgICBleHRyYWN0IDE1MyA4CiAgICBidXJ5IDI1CiAgICBwdXNoaW50IDE1MyAvLyAxNTMKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGJ1cnkgMTQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc2OQogICAgLy8gYXNzZXJ0KHJld2FyZFRva2VuSUQgIT09IDAsICJyZXdhcmRSZW1vdmVkIGNhbid0IGJlIHNldCBpZiB2YWxpZGF0b3IgZG9lc24ndCBoYXZlIHJld2FyZCB0b2tlbiEiKQogICAgYXNzZXJ0IC8vIHJld2FyZFJlbW92ZWQgY2FuJ3QgYmUgc2V0IGlmIHZhbGlkYXRvciBkb2Vzbid0IGhhdmUgcmV3YXJkIHRva2VuIQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzcxCiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuc3RhdGUucmV3YXJkVG9rZW5IZWxkQmFjayA+PSByZXdhcmRSZW1vdmVkLAogICAgZXh0cmFjdCAyNDIgMjYKICAgIGludGNfMiAvLyAxOAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZGlnIDUKICAgIGR1cAogICAgY292ZXIgMwogICAgPj0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc3MC03NzMKICAgIC8vIGFzc2VydCgKICAgIC8vICAgICB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUuc3RhdGUucmV3YXJkVG9rZW5IZWxkQmFjayA+PSByZXdhcmRSZW1vdmVkLAogICAgLy8gICAgICdyZXdhcmQgYmVpbmcgcmVtb3ZlZCBtdXN0IGJlIGNvdmVyZWQgYnkgaG9sZCBiYWNrIGFtb3VudCcsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gcmV3YXJkIGJlaW5nIHJlbW92ZWQgbXVzdCBiZSBjb3ZlcmVkIGJ5IGhvbGQgYmFjayBhbW91bnQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc3NgogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLnJld2FyZFRva2VuSGVsZEJhY2sgLT0gcmV3YXJkUmVtb3ZlZAogICAgc3dhcAogICAgLQogICAgaXRvYgogICAgcHVzaGludCAyNjAgLy8gMjYwCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6NzgxCiAgICAvLyBpZiAocG9vbEtleS5wb29sSWQgIT09IDEpIHsKICAgIGRpZyA2CiAgICBpbnRjXzEgLy8gMQogICAgIT0KICAgIGJ6IHN0YWtlUmVtb3ZlZF9hZnRlcl9pZl9lbHNlQDkKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc4Mi03ODUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5wYXlUb2tlblJld2FyZD4oewogICAgLy8gICAgIGFwcElkOiBBcHBsaWNhdGlvbih0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbMF0ucG9vbEFwcElkKSwKICAgIC8vICAgICBhcmdzOiBbc3Rha2VyLCByZXdhcmRUb2tlbklELCByZXdhcmRSZW1vdmVkXSwKICAgIC8vIH0pCiAgICBpdHhuX2JlZ2luCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3ODMKICAgIC8vIGFwcElkOiBBcHBsaWNhdGlvbih0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbMF0ucG9vbEFwcElkKSwKICAgIGRpZyAyMAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGludGMgNCAvLyAyNjgKICAgIGludGMgNSAvLyA0MzIKICAgIGV4dHJhY3QzCiAgICBleHRyYWN0IDAgMTggLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc4Mi03ODUKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5wYXlUb2tlblJld2FyZD4oewogICAgLy8gICAgIGFwcElkOiBBcHBsaWNhdGlvbih0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbMF0ucG9vbEFwcElkKSwKICAgIC8vICAgICBhcmdzOiBbc3Rha2VyLCByZXdhcmRUb2tlbklELCByZXdhcmRSZW1vdmVkXSwKICAgIC8vIH0pCiAgICBieXRlYyAxNiAvLyBtZXRob2QgInBheVRva2VuUmV3YXJkKGFkZHJlc3MsdWludDY0LHVpbnQ2NCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA2CiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDIyCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgZGlnIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uSUQKICAgIHB1c2hpbnQgNiAvLyBhcHBsCiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIGl0eG5fc3VibWl0CgpzdGFrZVJlbW92ZWRfYWZ0ZXJfaWZfZWxzZUA5OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Nzg5CiAgICAvLyBwb29sTnVtOiBuZXcgVWludDE2KHBvb2xLZXkucG9vbElkKSwKICAgIGRpZyA2CiAgICBpdG9iCiAgICBkdXAKICAgIGJpdGxlbgogICAgcHVzaGludCAxNiAvLyAxNgogICAgPD0KICAgIGFzc2VydCAvLyBvdmVyZmxvdwogICAgZXh0cmFjdCA2IDIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc5MAogICAgLy8gcG9vbEFwcElkOiBwb29sS2V5LnBvb2xBcHBJZCwKICAgIGRpZyAxCiAgICBleHRyYWN0IDE2IDgKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc4Ny03OTUKICAgIC8vIGVtaXQ8cmV0aU9QX3N0YWtlUmVtb3ZlZD4oewogICAgLy8gICAgIGlkOiBwb29sS2V5LmlkLAogICAgLy8gICAgIHBvb2xOdW06IG5ldyBVaW50MTYocG9vbEtleS5wb29sSWQpLAogICAgLy8gICAgIHBvb2xBcHBJZDogcG9vbEtleS5wb29sQXBwSWQsCiAgICAvLyAgICAgc3Rha2VyOiBzdGFrZXIsCiAgICAvLyAgICAgYW1vdW50VW5zdGFrZWQ6IGFtb3VudFJlbW92ZWQsCiAgICAvLyAgICAgcmV3YXJkVG9rZW5Bc3NldElkOiByZXdhcmRUb2tlbklELAogICAgLy8gICAgIHJld2FyZFRva2Vuc1JlY2VpdmVkOiByZXdhcmRSZW1vdmVkLAogICAgLy8gfSkKICAgIGRpZyAyMAogICAgdW5jb3ZlciAyCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZGlnIDYKICAgIGNvbmNhdAogICAgZGlnIDUKICAgIGl0b2IKICAgIGNvbmNhdAogICAgZGlnIDMKICAgIGl0b2IKICAgIGNvbmNhdAogICAgZGlnIDExCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGJ5dGVjIDE3IC8vIG1ldGhvZCAicmV0aU9QX3N0YWtlUmVtb3ZlZCh1aW50NjQsdWludDE2LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCgpzdGFrZVJlbW92ZWRfYWZ0ZXJfaWZfZWxzZUAxMToKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgwOQogICAgLy8gaWYgKHN0YWtlclJlbW92ZWQpIHsKICAgIGRpZyAxCiAgICBieiBzdGFrZVJlbW92ZWRfYWZ0ZXJfaWZfZWxzZUAxNwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODExCiAgICAvLyBjb25zdCB0b3RhbFN0YWtlcnMgPSB0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkudmFsdWUucG9vbHNbcG9vbEtleS5wb29sSWQgLSAxXS50b3RhbFN0YWtlcnMuYXNVaW50NjQoKQogICAgZGlnIDIwCiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBpbnRjIDQgLy8gMjY4CiAgICBpbnRjIDUgLy8gNDMyCiAgICBleHRyYWN0MwogICAgZGlnIDE4CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIGludGNfMiAvLyAxOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzMgLy8gOAogICAgZXh0cmFjdF91aW50MTYKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgxMgogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0udG90YWxTdGFrZXJzID0gbmV3IFVpbnQxNih0b3RhbFN0YWtlcnMgLSAxKQogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDYgMgogICAgc3dhcAogICAgcHVzaGludCAyNzYgLy8gMjc2CiAgICArCiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODE3CiAgICAvLyBwb29sQXBwSWQ6IHBvb2xLZXkucG9vbEFwcElkLAogICAgZHVwCiAgICBleHRyYWN0IDE2IDgKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgxNC04MTgKICAgIC8vIGNvbnN0IHJlbW92ZVJldCA9IHRoaXMucmVtb3ZlRnJvbVN0YWtlclBvb2xTZXQoc3Rha2VyLCB7CiAgICAvLyAgICAgaWQ6IHBvb2xLZXkuaWQsCiAgICAvLyAgICAgcG9vbElkOiBwb29sS2V5LnBvb2xJZCwKICAgIC8vICAgICBwb29sQXBwSWQ6IHBvb2xLZXkucG9vbEFwcElkLAogICAgLy8gfSkKICAgIGRpZyA3CiAgICBpdG9iCiAgICBkaWcgMjAKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICBidXJ5IDEKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNzMKICAgIC8vIGxldCBpblNhbWVWYWxpZGF0b3JQb29sQ291bnQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDEyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTc0CiAgICAvLyBsZXQgaW5BbnlQb29sQ291bnQ6IHVpbnQ2NCA9IDAKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDEzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTc1CiAgICAvLyBsZXQgZm91bmQgPSBmYWxzZQogICAgaW50Y18wIC8vIDAKICAgIGJ1cnkgMTUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExMQogICAgLy8gc3Rha2VyUG9vbFNldCA9IEJveE1hcDxBY2NvdW50LCBGaXhlZEFycmF5PFZhbGlkYXRvclBvb2xLZXksIHR5cGVvZiBNQVhfUE9PTFNfUEVSX1NUQUtFUj4+KHsga2V5UHJlZml4OiAnc3BzJyB9KQogICAgYnl0ZWMgNiAvLyAic3BzIgogICAgZGlnIDYKICAgIGNvbmNhdAogICAgZHVwCiAgICBidXJ5IDIxCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTc3CiAgICAvLyBjb25zdCBwb29sU2V0ID0gY2xvbmUodGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUpCiAgICBib3hfZ2V0CiAgICBzd2FwCiAgICBidXJ5IDE5CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE3OAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlLmxlbmd0aDsgaSArPSAxKSB7CiAgICBpbnRjXzAgLy8gMAogICAgYnVyeSAxNAoKc3Rha2VSZW1vdmVkX3doaWxlX3RvcEAxOToKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNzgKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCB0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZS5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDE5CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkaWcgMTMKICAgIHB1c2hpbnQgNiAvLyA2CiAgICA8CiAgICBieiBzdGFrZVJlbW92ZWRfYWZ0ZXJfd2hpbGVAMzEKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNzkKICAgIC8vIGlmIChwb29sU2V0W2ldLmlkID09PSAwKSB7CiAgICBkaWcgMTMKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgICoKICAgIGR1cAogICAgYnVyeSAxNwogICAgZGlnIDE4CiAgICBzd2FwCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgYnVyeSAyNAogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDY0CiAgICBkdXAKICAgIGJ1cnkgOQogICAgYnogc3Rha2VSZW1vdmVkX2Jsb2NrQDMwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTgyCiAgICAvLyBpbkFueVBvb2xDb3VudCArPSAxCiAgICBkaWcgMTIKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDEzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTgzCiAgICAvLyBpZiAocG9vbFNldFtpXS5pZCA9PT0gcG9vbEtleS5pZCkgewogICAgZHVwCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyA4CiAgICA9PQogICAgZHVwCiAgICBidXJ5IDEwCiAgICBieiBzdGFrZVJlbW92ZWRfYmxvY2tAMzAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExODUtMTE4NgogICAgLy8gcG9vbFNldFtpXS5pZCA9PT0gcG9vbEtleS5pZCAmJgogICAgLy8gcG9vbFNldFtpXS5wb29sSWQgPT09IHBvb2xLZXkucG9vbElkICYmCiAgICBkaWcgOAogICAgYnogc3Rha2VSZW1vdmVkX2Vsc2VfYm9keUAyNwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE4NgogICAgLy8gcG9vbFNldFtpXS5wb29sSWQgPT09IHBvb2xLZXkucG9vbElkICYmCiAgICBkaWcgMjIKICAgIGludGNfMyAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgIGludGNfMyAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgPT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExODUtMTE4NgogICAgLy8gcG9vbFNldFtpXS5pZCA9PT0gcG9vbEtleS5pZCAmJgogICAgLy8gcG9vbFNldFtpXS5wb29sSWQgPT09IHBvb2xLZXkucG9vbElkICYmCiAgICBieiBzdGFrZVJlbW92ZWRfZWxzZV9ib2R5QDI3CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTg3CiAgICAvLyBwb29sU2V0W2ldLnBvb2xBcHBJZCA9PT0gcG9vbEtleS5wb29sQXBwSWQKICAgIGRpZyAyMgogICAgcHVzaGludCAxNiAvLyAxNgogICAgZXh0cmFjdF91aW50NjQKICAgIGRpZyAxCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgPT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExODUtMTE4NwogICAgLy8gcG9vbFNldFtpXS5pZCA9PT0gcG9vbEtleS5pZCAmJgogICAgLy8gcG9vbFNldFtpXS5wb29sSWQgPT09IHBvb2xLZXkucG9vbElkICYmCiAgICAvLyBwb29sU2V0W2ldLnBvb2xBcHBJZCA9PT0gcG9vbEtleS5wb29sQXBwSWQKICAgIGJ6IHN0YWtlUmVtb3ZlZF9lbHNlX2JvZHlAMjcKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExODkKICAgIC8vIGZvdW5kID0gdHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIGJ1cnkgMTUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExOTEKICAgIC8vIHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLnZhbHVlW2ldID0geyBpZDogMCwgcG9vbElkOiAwLCBwb29sQXBwSWQ6IDAgfQogICAgZGlnIDE5CiAgICBkaWcgMTYKICAgIHB1c2hieXRlcyAweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAogICAgYm94X3JlcGxhY2UKCnN0YWtlUmVtb3ZlZF9ibG9ja0AzMDoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjExNzgKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCB0aGlzLnN0YWtlclBvb2xTZXQoc3Rha2VyKS52YWx1ZS5sZW5ndGg7IGkgKz0gMSkgewogICAgZGlnIDEzCiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgYnVyeSAxNAogICAgYiBzdGFrZVJlbW92ZWRfd2hpbGVfdG9wQDE5CgpzdGFrZVJlbW92ZWRfZWxzZV9ib2R5QDI3OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTE5MwogICAgLy8gaW5TYW1lVmFsaWRhdG9yUG9vbENvdW50ICs9IDEKICAgIGRpZyAxMQogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgMTIKICAgIGIgc3Rha2VSZW1vdmVkX2Jsb2NrQDMwCgpzdGFrZVJlbW92ZWRfYWZ0ZXJfd2hpbGVAMzE6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTk3CiAgICAvLyBpZiAoIWZvdW5kKSB7CiAgICBkaWcgMTQKICAgIGFzc2VydCAvLyBObyBtYXRjaGluZyBzbG90IGZvdW5kIHdoZW4gdG9sZCB0byByZW1vdmUgYSBwb29sIGZyb20gdGhlIHN0YWtlcnMgc2V0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjAxCiAgICAvLyByZXR1cm4gW2luU2FtZVZhbGlkYXRvclBvb2xDb3VudCA9PT0gMCwgaW5BbnlQb29sQ291bnQgPT09IDBdCiAgICBkaWcgMTEKICAgICEKICAgIGRpZyAxMwogICAgIQogICAgYnl0ZWMgNyAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAzCiAgICBzZXRiaXQKICAgIGludGNfMSAvLyAxCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODE5CiAgICAvLyBjb25zdCBzdGFrZXJPdXRPZlRoaXNWYWxpZGF0b3IgPSByZW1vdmVSZXRbMF0KICAgIGR1cAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODIwCiAgICAvLyBjb25zdCBzdGFrZXJPdXRPZlByb3RvY29sID0gcmVtb3ZlUmV0WzFdCiAgICBzd2FwCiAgICBpbnRjXzEgLy8gMQogICAgZ2V0Yml0CiAgICBidXJ5IDExCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MjIKICAgIC8vIGlmIChzdGFrZXJPdXRPZlRoaXNWYWxpZGF0b3IpIHsKICAgIGJ6IHN0YWtlUmVtb3ZlZF9hZnRlcl9pZl9lbHNlQDE0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MjMKICAgIC8vIHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS52YWx1ZS5zdGF0ZS50b3RhbFN0YWtlcnMgLT0gMQogICAgZGlnIDIwCiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBleHRyYWN0IDI0MiAyNgogICAgcHVzaGludCAyIC8vIDIKICAgIGV4dHJhY3RfdWludDY0CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgaXRvYgogICAgcHVzaGludCAyNDQgLy8gMjQ0CiAgICBzd2FwCiAgICBib3hfcmVwbGFjZQoKc3Rha2VSZW1vdmVkX2FmdGVyX2lmX2Vsc2VAMTQ6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MjYKICAgIC8vIGlmIChzdGFrZXJPdXRPZlByb3RvY29sKSB7CiAgICBkaWcgOQogICAgYnogc3Rha2VSZW1vdmVkX2FmdGVyX2lmX2Vsc2VAMTcKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgyNwogICAgLy8gdGhpcy5udW1TdGFrZXJzLnZhbHVlIC09IDEKICAgIGludGNfMCAvLyAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDAKICAgIC8vIG51bVN0YWtlcnMgPSBHbG9iYWxTdGF0ZTx1aW50NjQ+KHsga2V5OiAnbnVtU3Rha2VycycgfSkKICAgIGJ5dGVjIDQgLy8gIm51bVN0YWtlcnMiCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4MjcKICAgIC8vIHRoaXMubnVtU3Rha2Vycy52YWx1ZSAtPSAxCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgYXNzZXJ0IC8vIGNoZWNrIEdsb2JhbFN0YXRlIGV4aXN0cwogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMAogICAgLy8gbnVtU3Rha2VycyA9IEdsb2JhbFN0YXRlPHVpbnQ2ND4oeyBrZXk6ICdudW1TdGFrZXJzJyB9KQogICAgYnl0ZWMgNCAvLyAibnVtU3Rha2VycyIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgyNwogICAgLy8gdGhpcy5udW1TdGFrZXJzLnZhbHVlIC09IDEKICAgIHN3YXAKICAgIGFwcF9nbG9iYWxfcHV0CgpzdGFrZVJlbW92ZWRfYWZ0ZXJfaWZfZWxzZUAxNzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjc0OC03NTQKICAgIC8vIHN0YWtlUmVtb3ZlZCgKICAgIC8vICAgICBwb29sS2V5OiBWYWxpZGF0b3JQb29sS2V5LAogICAgLy8gICAgIHN0YWtlcjogQWNjb3VudCwKICAgIC8vICAgICBhbW91bnRSZW1vdmVkOiB1aW50NjQsCiAgICAvLyAgICAgcmV3YXJkUmVtb3ZlZDogdWludDY0LAogICAgLy8gICAgIHN0YWtlclJlbW92ZWQ6IGJvb2xlYW4sCiAgICAvLyApOiB2b2lkIHsKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCnN0YWtlUmVtb3ZlZF9lbHNlX2JvZHlAMTA6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo3OTkKICAgIC8vIHBvb2xOdW06IG5ldyBVaW50MTYocG9vbEtleS5wb29sSWQpLAogICAgZGlnIDYKICAgIGl0b2IKICAgIGR1cAogICAgYml0bGVuCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICA8PQogICAgYXNzZXJ0IC8vIG92ZXJmbG93CiAgICBleHRyYWN0IDYgMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODAwCiAgICAvLyBwb29sQXBwSWQ6IHBvb2xLZXkucG9vbEFwcElkLAogICAgZGlnIDEKICAgIGV4dHJhY3QgMTYgOAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Nzk3LTgwNgogICAgLy8gZW1pdDxyZXRpT1Bfc3Rha2VSZW1vdmVkPih7CiAgICAvLyAgICAgaWQ6IHBvb2xLZXkuaWQsCiAgICAvLyAgICAgcG9vbE51bTogbmV3IFVpbnQxNihwb29sS2V5LnBvb2xJZCksCiAgICAvLyAgICAgcG9vbEFwcElkOiBwb29sS2V5LnBvb2xBcHBJZCwKICAgIC8vICAgICBzdGFrZXI6IHN0YWtlciwKICAgIC8vICAgICBhbW91bnRVbnN0YWtlZDogYW1vdW50UmVtb3ZlZCwKICAgIC8vICAgICAvLyBubyB0b2tlbnMgcmV3YXJkZWQuLgogICAgLy8gICAgIHJld2FyZFRva2VuQXNzZXRJZDogMCwKICAgIC8vICAgICByZXdhcmRUb2tlbnNSZWNlaXZlZDogMCwKICAgIC8vIH0pCiAgICBkaWcgMjAKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGRpZyA2CiAgICBjb25jYXQKICAgIGRpZyA1CiAgICBpdG9iCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjgwNQogICAgLy8gcmV3YXJkVG9rZW5zUmVjZWl2ZWQ6IDAsCiAgICBpbnRjXzAgLy8gMAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6Nzk3LTgwNgogICAgLy8gZW1pdDxyZXRpT1Bfc3Rha2VSZW1vdmVkPih7CiAgICAvLyAgICAgaWQ6IHBvb2xLZXkuaWQsCiAgICAvLyAgICAgcG9vbE51bTogbmV3IFVpbnQxNihwb29sS2V5LnBvb2xJZCksCiAgICAvLyAgICAgcG9vbEFwcElkOiBwb29sS2V5LnBvb2xBcHBJZCwKICAgIC8vICAgICBzdGFrZXI6IHN0YWtlciwKICAgIC8vICAgICBhbW91bnRVbnN0YWtlZDogYW1vdW50UmVtb3ZlZCwKICAgIC8vICAgICAvLyBubyB0b2tlbnMgcmV3YXJkZWQuLgogICAgLy8gICAgIHJld2FyZFRva2VuQXNzZXRJZDogMCwKICAgIC8vICAgICByZXdhcmRUb2tlbnNSZWNlaXZlZDogMCwKICAgIC8vIH0pCiAgICBpdG9iCiAgICBzd2FwCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjIDE3IC8vIG1ldGhvZCAicmV0aU9QX3N0YWtlUmVtb3ZlZCh1aW50NjQsdWludDE2LHVpbnQ2NCxhZGRyZXNzLHVpbnQ2NCx1aW50NjQsdWludDY0KSIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBiIHN0YWtlUmVtb3ZlZF9hZnRlcl9pZl9lbHNlQDExCgpzdGFrZVJlbW92ZWRfYm9vbF9mYWxzZUA0OgogICAgaW50Y18wIC8vIDAKICAgIGIgc3Rha2VSZW1vdmVkX2Jvb2xfbWVyZ2VANQoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcltyb3V0aW5nXSgpIC0+IHZvaWQ6CmZpbmRQb29sRm9yU3Rha2VyOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODQzCiAgICAvLyBAYWJpbWV0aG9kKHsgcmVhZG9ubHk6IHRydWUgfSkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGJ0b2kKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDMKICAgIGJ0b2kKICAgIGNhbGxzdWIgY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmZpbmRQb29sRm9yU3Rha2VyCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgoKLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5Lm1vdmVQb29sVG9Ob2RlW3JvdXRpbmddKCkgLT4gdm9pZDoKbW92ZVBvb2xUb05vZGU6CiAgICBieXRlY18yIC8vICIiCiAgICBkdXBuIDQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkxNwogICAgLy8gbW92ZVBvb2xUb05vZGUodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgcG9vbEFwcElkOiB1aW50NjQsIG5vZGVOdW06IHVpbnQ2NCk6IHZvaWQgewogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgYnRvaQogICAgZHVwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBidG9pCiAgICBzd2FwCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAzCiAgICBidG9pCiAgICBkdXAKICAgIHVuY292ZXIgMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTE4CiAgICAvLyB0aGlzLmNhbGxlck11c3RCZU93bmVyT3JNYW5hZ2VyKHZhbGlkYXRvcklkKQogICAgZHVwCiAgICBjYWxsc3ViIGNhbGxlck11c3RCZU93bmVyT3JNYW5hZ2VyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjAKICAgIC8vIGNvbnN0IG5vZGVQb29sQXNzaWdubWVudHMgPSBjbG9uZSh0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLm5vZGVQb29sQXNzaWdubWVudHMpCiAgICBpdG9iCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIGNvdmVyIDIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkyMAogICAgLy8gY29uc3Qgbm9kZVBvb2xBc3NpZ25tZW50cyA9IGNsb25lKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUubm9kZVBvb2xBc3NpZ25tZW50cykKICAgIGJveF9nZXQKICAgIHN3YXAKICAgIGNvdmVyIDIKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjEKICAgIC8vIGFzc2VydChub2RlTnVtID49IDEgJiYgbm9kZU51bSA8PSBNQVhfTk9ERVMsICdub2RlIG51bWJlciBvdXQgb2YgYWxsb3dhYmxlIHJhbmdlJykKICAgIGJ6IG1vdmVQb29sVG9Ob2RlX2Jvb2xfZmFsc2VANAogICAgZGlnIDIKICAgIGludGNfMyAvLyA4CiAgICA8PQogICAgYnogbW92ZVBvb2xUb05vZGVfYm9vbF9mYWxzZUA0CiAgICBpbnRjXzEgLy8gMQoKbW92ZVBvb2xUb05vZGVfYm9vbF9tZXJnZUA1OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTIxCiAgICAvLyBhc3NlcnQobm9kZU51bSA+PSAxICYmIG5vZGVOdW0gPD0gTUFYX05PREVTLCAnbm9kZSBudW1iZXIgb3V0IG9mIGFsbG93YWJsZSByYW5nZScpCiAgICBhc3NlcnQgLy8gbm9kZSBudW1iZXIgb3V0IG9mIGFsbG93YWJsZSByYW5nZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTIzCiAgICAvLyBmb3IgKGxldCBzcmNOb2RlSWR4OiB1aW50NjQgPSAwOyBzcmNOb2RlSWR4IDwgTUFYX05PREVTOyBzcmNOb2RlSWR4ICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDcKCm1vdmVQb29sVG9Ob2RlX3doaWxlX3RvcEA2OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTIzCiAgICAvLyBmb3IgKGxldCBzcmNOb2RlSWR4OiB1aW50NjQgPSAwOyBzcmNOb2RlSWR4IDwgTUFYX05PREVTOyBzcmNOb2RlSWR4ICs9IDEpIHsKICAgIGRpZyA2CiAgICBpbnRjXzMgLy8gOAogICAgPAogICAgYXNzZXJ0IC8vIGNvdWxkbid0IGZpbmQgcG9vbCBhcHAgaWQgaW4gbm9kZXMgdG8gbW92ZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTI0CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgTUFYX1BPT0xTX1BFUl9OT0RFOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBidXJ5IDgKCm1vdmVQb29sVG9Ob2RlX3doaWxlX3RvcEA4OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTI0CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgTUFYX1BPT0xTX1BFUl9OT0RFOyBpICs9IDEpIHsKICAgIGRpZyA3CiAgICBwdXNoaW50IDMgLy8gMwogICAgPAogICAgZHVwCiAgICBidXJ5IDcKICAgIGJ6IG1vdmVQb29sVG9Ob2RlX2FmdGVyX3doaWxlQDEzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjUKICAgIC8vIGlmIChub2RlUG9vbEFzc2lnbm1lbnRzLm5vZGVzW3NyY05vZGVJZHhdLnBvb2xBcHBJZHNbaV0gPT09IHBvb2xBcHBJZCkgewogICAgZHVwCiAgICBpbnRjIDggLy8gOTAwCiAgICBpbnRjIDkgLy8gMTkyCiAgICBleHRyYWN0MwogICAgZXh0cmFjdCAwIDE5MgogICAgZGlnIDcKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgICoKICAgIGR1cAogICAgYnVyeSAxMgogICAgcHVzaGludCAyNCAvLyAyNAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBleHRyYWN0IDAgMjQKICAgIGRpZyA4CiAgICBpbnRjXzMgLy8gOAogICAgKgogICAgZHVwCiAgICBidXJ5IDExCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDQKICAgID09CiAgICBieiBtb3ZlUG9vbFRvTm9kZV9hZnRlcl9pZl9lbHNlQDEyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjYKICAgIC8vIGFzc2VydChub2RlTnVtIC0gMSAhPT0gc3JjTm9kZUlkeCwgImNhbid0IG1vdmUgdG8gc2FtZSBub2RlIikKICAgIGRpZyAyCiAgICBkdXAKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkaWcgOAogICAgIT0KICAgIGFzc2VydCAvLyBjYW4ndCBtb3ZlIHRvIHNhbWUgbm9kZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTI4CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLm5vZGVQb29sQXNzaWdubWVudHMubm9kZXNbc3JjTm9kZUlkeF0ucG9vbEFwcElkc1tpXSA9IDAKICAgIGludGNfMCAvLyAwCiAgICBpdG9iCiAgICBpbnRjIDggLy8gOTAwCiAgICBkaWcgMTIKICAgICsKICAgIGRpZyA4CiAgICBhc3NlcnQgLy8gaW5kZXggb3V0IG9mIGJvdW5kcwogICAgZGlnIDExCiAgICArCiAgICBkaWcgNAogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTMxLTkzMwogICAgLy8gYWJpQ2FsbDx0eXBlb2YgU3Rha2luZ1Bvb2wucHJvdG90eXBlLmdvT2ZmbGluZT4oewogICAgLy8gICAgIGFwcElkOiBBcHBsaWNhdGlvbihwb29sQXBwSWQpLAogICAgLy8gfSkKICAgIGl0eG5fYmVnaW4KICAgIHB1c2hieXRlcyAweDUxZWYzYjIxIC8vIG1ldGhvZCAiZ29PZmZsaW5lKCl2b2lkIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGRpZyA0CiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25JRAogICAgcHVzaGludCA2IC8vIGFwcGwKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIGludGNfMCAvLyAwCiAgICBpdHhuX2ZpZWxkIEZlZQogICAgaXR4bl9zdWJtaXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkzNgogICAgLy8gdGhpcy5hZGRQb29sVG9Ob2RlKHZhbGlkYXRvcklkLCBwb29sQXBwSWQsIG5vZGVOdW0pCiAgICBkaWcgNgogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICBjYWxsc3ViIGFkZFBvb2xUb05vZGUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkxNwogICAgLy8gbW92ZVBvb2xUb05vZGUodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSwgcG9vbEFwcElkOiB1aW50NjQsIG5vZGVOdW06IHVpbnQ2NCk6IHZvaWQgewogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbW92ZVBvb2xUb05vZGVfYWZ0ZXJfaWZfZWxzZUAxMjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkyNAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IE1BWF9QT09MU19QRVJfTk9ERTsgaSArPSAxKSB7CiAgICBkaWcgNwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGJ1cnkgOAogICAgYiBtb3ZlUG9vbFRvTm9kZV93aGlsZV90b3BAOAoKbW92ZVBvb2xUb05vZGVfYWZ0ZXJfd2hpbGVAMTM6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5MjMKICAgIC8vIGZvciAobGV0IHNyY05vZGVJZHg6IHVpbnQ2NCA9IDA7IHNyY05vZGVJZHggPCBNQVhfTk9ERVM7IHNyY05vZGVJZHggKz0gMSkgewogICAgZGlnIDYKICAgIGludGNfMSAvLyAxCiAgICArCiAgICBidXJ5IDcKICAgIGIgbW92ZVBvb2xUb05vZGVfd2hpbGVfdG9wQDYKCm1vdmVQb29sVG9Ob2RlX2Jvb2xfZmFsc2VANDoKICAgIGludGNfMCAvLyAwCiAgICBiIG1vdmVQb29sVG9Ob2RlX2Jvb2xfbWVyZ2VANQoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5lbXB0eVRva2VuUmV3YXJkc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmVtcHR5VG9rZW5SZXdhcmRzOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTU1CiAgICAvLyBlbXB0eVRva2VuUmV3YXJkcyh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCByZWNlaXZlcjogQWNjb3VudCk6IHVpbnQ2NCB7CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBidG9pCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5NTYKICAgIC8vIHRoaXMuY2FsbGVyTXVzdEJlT3duZXIodmFsaWRhdG9ySWQpCiAgICBkaWcgMQogICAgY2FsbHN1YiBjYWxsZXJNdXN0QmVPd25lcgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTU3CiAgICAvLyBjb25zdCByZXdhcmRUb2tlbklkID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcucmV3YXJkVG9rZW5JZAogICAgc3dhcAogICAgaXRvYgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3CiAgICAvLyB2YWxpZGF0b3JMaXN0ID0gQm94TWFwPFZhbGlkYXRvcklkVHlwZSwgVmFsaWRhdG9ySW5mbz4oeyBrZXlQcmVmaXg6ICd2JyB9KQogICAgYnl0ZWNfMCAvLyAidiIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTU3CiAgICAvLyBjb25zdCByZXdhcmRUb2tlbklkID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcucmV3YXJkVG9rZW5JZAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGR1cAogICAgZXh0cmFjdCAwIDI0MgogICAgZHVwCiAgICBleHRyYWN0IDE1MyA4CiAgICBzd2FwCiAgICBwdXNoaW50IDE1MyAvLyAxNTMKICAgIGV4dHJhY3RfdWludDY0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5NTgKICAgIC8vIGNvbnN0IHJld2FyZFRva2VuSGVsZEJhY2sgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLnJld2FyZFRva2VuSGVsZEJhY2sKICAgIGRpZyAyCiAgICBleHRyYWN0IDI0MiAyNgogICAgaW50Y18yIC8vIDE4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTU5CiAgICAvLyBhc3NlcnQocmV3YXJkVG9rZW5JZCAhPT0gMCwgInRoaXMgdmFsaWRhdG9yIGRvZXNuJ3QgaGF2ZSBhIHJld2FyZCB0b2tlbiBkZWZpbmVkIikKICAgIGRpZyAxCiAgICBhc3NlcnQgLy8gdGhpcyB2YWxpZGF0b3IgZG9lc24ndCBoYXZlIGEgcmV3YXJkIHRva2VuIGRlZmluZWQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk2MAogICAgLy8gY29uc3QgcG9vbE9uZUFwcElkID0gQXBwbGljYXRpb24odGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1swXS5wb29sQXBwSWQpCiAgICB1bmNvdmVyIDMKICAgIGludGMgNCAvLyAyNjgKICAgIGludGMgNSAvLyA0MzIKICAgIGV4dHJhY3QzCiAgICBleHRyYWN0IDAgMTggLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk2MwogICAgLy8gb3AuQXNzZXRIb2xkaW5nLmFzc2V0QmFsYW5jZShwb29sT25lQXBwSWQuYWRkcmVzcywgcmV3YXJkVG9rZW5JZClbMF0gLSByZXdhcmRUb2tlbkhlbGRCYWNrCiAgICBkdXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIGRpZyAzCiAgICBhc3NldF9ob2xkaW5nX2dldCBBc3NldEJhbGFuY2UKICAgIHBvcAogICAgZGlnIDIKICAgIC0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk2Ni05NjkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5wYXlUb2tlblJld2FyZD4oewogICAgLy8gICAgIGFwcElkOiBwb29sT25lQXBwSWQsCiAgICAvLyAgICAgYXJnczogW3JlY2VpdmVyLCByZXdhcmRUb2tlbklkLCB0b2tlblJld2FyZEJhbF0sCiAgICAvLyB9KQogICAgaXR4bl9iZWdpbgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTY4CiAgICAvLyBhcmdzOiBbcmVjZWl2ZXIsIHJld2FyZFRva2VuSWQsIHRva2VuUmV3YXJkQmFsXSwKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk2Ni05NjkKICAgIC8vIGFiaUNhbGw8dHlwZW9mIFN0YWtpbmdQb29sLnByb3RvdHlwZS5wYXlUb2tlblJld2FyZD4oewogICAgLy8gICAgIGFwcElkOiBwb29sT25lQXBwSWQsCiAgICAvLyAgICAgYXJnczogW3JlY2VpdmVyLCByZXdhcmRUb2tlbklkLCB0b2tlblJld2FyZEJhbF0sCiAgICAvLyB9KQogICAgYnl0ZWMgMTYgLy8gbWV0aG9kICJwYXlUb2tlblJld2FyZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQpdm9pZCIKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDUKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICB1bmNvdmVyIDQKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkdXAKICAgIGl0eG5fZmllbGQgQXBwbGljYXRpb25BcmdzCiAgICBkaWcgMQogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICBwdXNoaW50IDYgLy8gYXBwbAogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTcxCiAgICAvLyBvcC5Bc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKHBvb2xPbmVBcHBJZC5hZGRyZXNzLCByZXdhcmRUb2tlbklkKVswXSA9PT0gcmV3YXJkVG9rZW5IZWxkQmFjaywKICAgIHN3YXAKICAgIGFwcF9wYXJhbXNfZ2V0IEFwcEFkZHJlc3MKICAgIGFzc2VydCAvLyBhcHBsaWNhdGlvbiBleGlzdHMKICAgIHVuY292ZXIgMwogICAgYXNzZXRfaG9sZGluZ19nZXQgQXNzZXRCYWxhbmNlCiAgICBwb3AKICAgIHVuY292ZXIgMgogICAgPT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk3MC05NzMKICAgIC8vIGFzc2VydCgKICAgIC8vICAgICBvcC5Bc3NldEhvbGRpbmcuYXNzZXRCYWxhbmNlKHBvb2xPbmVBcHBJZC5hZGRyZXNzLCByZXdhcmRUb2tlbklkKVswXSA9PT0gcmV3YXJkVG9rZW5IZWxkQmFjaywKICAgIC8vICAgICAnYmFsYW5jZSBvZiByZW1haW5pbmcgcmV3YXJkIHRva2VucyBzaG91bGQgbWF0Y2ggdGhlIGhlbGQgYmFjayBhbW91bnQnLAogICAgLy8gKQogICAgYXNzZXJ0IC8vIGJhbGFuY2Ugb2YgcmVtYWluaW5nIHJld2FyZCB0b2tlbnMgc2hvdWxkIG1hdGNoIHRoZSBoZWxkIGJhY2sgYW1vdW50CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5NTUKICAgIC8vIGVtcHR5VG9rZW5SZXdhcmRzKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUsIHJlY2VpdmVyOiBBY2NvdW50KTogdWludDY0IHsKICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHZhbGlkYXRvcklkOiB1aW50NjQpIC0+IHVpbnQ2NDoKY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmdldEN1ck1heFN0YWtlUGVyUG9vbDoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI3NC0yNzUKICAgIC8vIEBhYmltZXRob2QoeyByZWFkb25seTogdHJ1ZSB9KQogICAgLy8gZ2V0Q3VyTWF4U3Rha2VQZXJQb29sKHZhbGlkYXRvcklkOiBWYWxpZGF0b3JJZFR5cGUpOiB1aW50NjQgewogICAgcHJvdG8gMSAxCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzYKICAgIC8vIGNvbnN0IG51bVBvb2xzID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZS5udW1Qb29scy5hc1VpbnQ2NCgpCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI3NgogICAgLy8gY29uc3QgbnVtUG9vbHMgPSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzLmFzVWludDY0KCkKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGV4dHJhY3QgMjQyIDI2CiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50MTYKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI3NwogICAgLy8gY29uc3QgaGFyZE1heERpdmlkZWRCZXR3ZWVuUG9vbHM6IHVpbnQ2NCA9IHRoaXMubWF4QWxsb3dlZFN0YWtlKCkgLyBudW1Qb29scwogICAgY2FsbHN1YiBtYXhBbGxvd2VkU3Rha2UKICAgIHN3YXAKICAgIC8KICAgIHN3YXAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI3OAogICAgLy8gbGV0IG1heFBlclBvb2w6IHVpbnQ2NCA9IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1heEFsZ29QZXJQb29sCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZXh0cmFjdCAwIDI0MgogICAgcHVzaGludCAyMTcgLy8gMjE3CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyNzkKICAgIC8vIGlmIChtYXhQZXJQb29sID09PSAwKSB7CiAgICBibnogY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmdldEN1ck1heFN0YWtlUGVyUG9vbF9hZnRlcl9pZl9lbHNlQDIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzNjkKICAgIC8vIHJldHVybiBHbG9iYWwucGF5b3V0c01heEJhbGFuY2UKICAgIGdsb2JhbCBQYXlvdXRzTWF4QmFsYW5jZQogICAgZnJhbWVfYnVyeSAxCgpjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0Q3VyTWF4U3Rha2VQZXJQb29sX2FmdGVyX2lmX2Vsc2VAMjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjI4MgogICAgLy8gaWYgKGhhcmRNYXhEaXZpZGVkQmV0d2VlblBvb2xzIDwgbWF4UGVyUG9vbCkgewogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2RpZyAxCiAgICA8CiAgICBieiBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0Q3VyTWF4U3Rha2VQZXJQb29sX2FmdGVyX2lmX2Vsc2VANAogICAgZnJhbWVfZGlnIDAKICAgIGZyYW1lX2J1cnkgMQoKY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmdldEN1ck1heFN0YWtlUGVyUG9vbF9hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoyODUKICAgIC8vIHJldHVybiBtYXhQZXJQb29sCiAgICBmcmFtZV9kaWcgMQogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZmluZFBvb2xGb3JTdGFrZXIodmFsaWRhdG9ySWQ6IHVpbnQ2NCwgc3Rha2VyOiBieXRlcywgYW1vdW50VG9TdGFrZTogdWludDY0KSAtPiBieXRlczoKY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmZpbmRQb29sRm9yU3Rha2VyOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODQzLTg0OAogICAgLy8gQGFiaW1ldGhvZCh7IHJlYWRvbmx5OiB0cnVlIH0pCiAgICAvLyBmaW5kUG9vbEZvclN0YWtlcigKICAgIC8vICAgICB2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLAogICAgLy8gICAgIHN0YWtlcjogQWNjb3VudCwKICAgIC8vICAgICBhbW91bnRUb1N0YWtlOiB1aW50NjQsCiAgICAvLyApOiBbVmFsaWRhdG9yUG9vbEtleSwgYm9vbGVhbiwgYm9vbGVhbl0gewogICAgcHJvdG8gMyAxCiAgICBpbnRjXzAgLy8gMAogICAgZHVwbiA0CiAgICBieXRlY18yIC8vICIiCiAgICBkdXBuIDMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg0OQogICAgLy8gbGV0IGlzTmV3U3Rha2VyVG9WYWxpZGF0b3IgPSB0cnVlCiAgICBpbnRjXzEgLy8gMQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODUwCiAgICAvLyBsZXQgaXNOZXdTdGFrZXJUb1Byb3RvY29sID0gdHJ1ZQogICAgZHVwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NTgKICAgIC8vIGNvbnN0IG1heFBlclBvb2wgPSB0aGlzLmdldEN1ck1heFN0YWtlUGVyUG9vbCh2YWxpZGF0b3JJZCkKICAgIGZyYW1lX2RpZyAtMwogICAgY2FsbHN1YiBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZ2V0Q3VyTWF4U3Rha2VQZXJQb29sCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMTEKICAgIC8vIHN0YWtlclBvb2xTZXQgPSBCb3hNYXA8QWNjb3VudCwgRml4ZWRBcnJheTxWYWxpZGF0b3JQb29sS2V5LCB0eXBlb2YgTUFYX1BPT0xTX1BFUl9TVEFLRVI+Pih7IGtleVByZWZpeDogJ3NwcycgfSkKICAgIGJ5dGVjIDYgLy8gInNwcyIKICAgIGZyYW1lX2RpZyAtMgogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2MQogICAgLy8gaWYgKHRoaXMuc3Rha2VyUG9vbFNldChzdGFrZXIpLmV4aXN0cykgewogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBieiBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZmluZFBvb2xGb3JTdGFrZXJfYWZ0ZXJfaWZfZWxzZUAxMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODYyCiAgICAvLyBjb25zdCBwb29sU2V0ID0gY2xvbmUodGhpcy5zdGFrZXJQb29sU2V0KHN0YWtlcikudmFsdWUpCiAgICBmcmFtZV9kaWcgMTIKICAgIGJveF9nZXQKICAgIHN3YXAKICAgIGZyYW1lX2J1cnkgNAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2MwogICAgLy8gYXNzZXJ0KHZhbGlkYXRvcklkICE9PSAwKQogICAgZnJhbWVfZGlnIC0zCiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2NAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHBvb2xTZXQubGVuZ3RoOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDYKCmNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl93aGlsZV90b3BAMjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2NAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHBvb2xTZXQubGVuZ3RoOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyA2CiAgICBwdXNoaW50IDYgLy8gNgogICAgPAogICAgYnogY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmZpbmRQb29sRm9yU3Rha2VyX2FmdGVyX2lmX2Vsc2VAMTIKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2NQogICAgLy8gZW5zdXJlQnVkZ2V0KDMwMCkKICAgIHB1c2hpbnQgMzAwIC8vIDMwMAogICAgaW50Y18wIC8vIDAKICAgIGNhbGxzdWIgZW5zdXJlX2J1ZGdldAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODY2CiAgICAvLyBpZiAocG9vbFNldFtpXS5pZCA9PT0gMCkgewogICAgZnJhbWVfZGlnIDYKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgICoKICAgIGZyYW1lX2RpZyA0CiAgICBzd2FwCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICBpbnRjXzAgLy8gMAogICAgZXh0cmFjdF91aW50NjQKICAgIGR1cAogICAgZnJhbWVfYnVyeSA4CiAgICBieiBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZmluZFBvb2xGb3JTdGFrZXJfYmxvY2tAMTAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2OQogICAgLy8gaXNOZXdTdGFrZXJUb1Byb3RvY29sID0gZmFsc2UKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDEwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NzAKICAgIC8vIGlmIChwb29sU2V0W2ldLmlkID09PSB2YWxpZGF0b3JJZCkgewogICAgZnJhbWVfZGlnIDgKICAgIGZyYW1lX2RpZyAtMwogICAgPT0KICAgIGJ6IGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl9ibG9ja0AxMAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODcyCiAgICAvLyBpc05ld1N0YWtlclRvVmFsaWRhdG9yID0gZmFsc2UKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDkKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg3NAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1twb29sU2V0W2ldLnBvb2xJZCAtIDFdLnRvdGFsQWxnb1N0YWtlZCArCiAgICBmcmFtZV9kaWcgLTMKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg3NAogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1twb29sU2V0W2ldLnBvb2xJZCAtIDFdLnRvdGFsQWxnb1N0YWtlZCArCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZnJhbWVfZGlnIDEKICAgIGludGNfMyAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgaW50Y18xIC8vIDEKICAgIC0KICAgIHN3YXAKICAgIGludGMgNCAvLyAyNjgKICAgIGludGMgNSAvLyA0MzIKICAgIGV4dHJhY3QzCiAgICBzd2FwCiAgICBpbnRjXzIgLy8gMTgKICAgICoKICAgIGludGNfMiAvLyAxOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBwdXNoaW50IDEwIC8vIDEwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODc0LTg3NQogICAgLy8gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1twb29sU2V0W2ldLnBvb2xJZCAtIDFdLnRvdGFsQWxnb1N0YWtlZCArCiAgICAvLyAgICAgYW1vdW50VG9TdGFrZSA8PQogICAgZnJhbWVfZGlnIC0xCiAgICArCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NzQtODc2CiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLnBvb2xzW3Bvb2xTZXRbaV0ucG9vbElkIC0gMV0udG90YWxBbGdvU3Rha2VkICsKICAgIC8vICAgICBhbW91bnRUb1N0YWtlIDw9CiAgICAvLyBtYXhQZXJQb29sCiAgICBmcmFtZV9kaWcgMTEKICAgIDw9CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4NzMtODc3CiAgICAvLyBpZiAoCiAgICAvLyAgICAgdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5wb29sc1twb29sU2V0W2ldLnBvb2xJZCAtIDFdLnRvdGFsQWxnb1N0YWtlZCArCiAgICAvLyAgICAgICAgIGFtb3VudFRvU3Rha2UgPD0KICAgIC8vICAgICBtYXhQZXJQb29sCiAgICAvLyApIHsKICAgIGJ6IGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl9ibG9ja0AxMAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODc4CiAgICAvLyByZXR1cm4gW3Bvb2xTZXRbaV0sIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3IsIGlzTmV3U3Rha2VyVG9Qcm90b2NvbF0KICAgIGZyYW1lX2RpZyAxCiAgICBieXRlYyA3IC8vIDB4MDAKICAgIGNvbmNhdAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCmNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl9ibG9ja0AxMDoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg2NAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IHBvb2xTZXQubGVuZ3RoOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyA2CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA2CiAgICBiIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl93aGlsZV90b3BAMgoKY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmZpbmRQb29sRm9yU3Rha2VyX2FmdGVyX2lmX2Vsc2VAMTI6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4ODYKICAgIC8vIGFtb3VudFRvU3Rha2UgPj0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcubWluRW50cnlTdGFrZSwKICAgIGZyYW1lX2RpZyAtMwogICAgaXRvYgogICAgZHVwCiAgICBmcmFtZV9idXJ5IDMKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg4NgogICAgLy8gYW1vdW50VG9TdGFrZSA+PSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5taW5FbnRyeVN0YWtlLAogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICBjb3ZlciAyCiAgICBmcmFtZV9idXJ5IDAKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBkdXAKICAgIGV4dHJhY3QgMCAyNDIKICAgIHB1c2hpbnQgMjA5IC8vIDIwOQogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAtMQogICAgPD0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg4NS04ODgKICAgIC8vIGFzc2VydCgKICAgIC8vICAgICBhbW91bnRUb1N0YWtlID49IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm1pbkVudHJ5U3Rha2UsCiAgICAvLyAgICAgJ211c3Qgc3Rha2UgYXQgbGVhc3QgdGhlIG1pbmltdW0gZm9yIHRoaXMgcG9vbCcsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gbXVzdCBzdGFrZSBhdCBsZWFzdCB0aGUgbWluaW11bSBmb3IgdGhpcyBwb29sCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4OTIKICAgIC8vIGNvbnN0IGN1ck51bVBvb2xzID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5zdGF0ZS5udW1Qb29scy5hc1VpbnQ2NCgpCiAgICBleHRyYWN0IDI0MiAyNgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9idXJ5IDUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg5MwogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGN1ck51bVBvb2xzOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDcKCmNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl93aGlsZV90b3BAMTM6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4OTMKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBjdXJOdW1Qb29sczsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgNwogICAgZnJhbWVfZGlnIDUKICAgIDwKICAgIGJ6IGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl9hZnRlcl93aGlsZUAxNwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6ODk0CiAgICAvLyBpZiAocG9vbHNbaV0udG90YWxBbGdvU3Rha2VkICsgYW1vdW50VG9TdGFrZSA8PSBtYXhQZXJQb29sKSB7CiAgICBmcmFtZV9kaWcgMAogICAgaW50YyA0IC8vIDI2OAogICAgaW50YyA1IC8vIDQzMgogICAgZXh0cmFjdDMKICAgIGZyYW1lX2RpZyA3CiAgICBpbnRjXzIgLy8gMTgKICAgICoKICAgIGludGNfMiAvLyAxOAogICAgZXh0cmFjdDMgLy8gb24gZXJyb3I6IGluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMgogICAgcHVzaGludCAxMCAvLyAxMAogICAgZXh0cmFjdF91aW50NjQKICAgIGZyYW1lX2RpZyAtMQogICAgKwogICAgZnJhbWVfZGlnIDExCiAgICA8PQogICAgYnogY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmZpbmRQb29sRm9yU3Rha2VyX2FmdGVyX2lmX2Vsc2VAMTYKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg5NgogICAgLy8geyBpZDogdmFsaWRhdG9ySWQsIHBvb2xJZDogaSArIDEsIHBvb2xBcHBJZDogcG9vbHNbaV0ucG9vbEFwcElkIH0sCiAgICBmcmFtZV9kaWcgNwogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2RpZyAyCiAgICBleHRyYWN0IDAgOAogICAgc3dhcAogICAgaXRvYgogICAgZnJhbWVfZGlnIDMKICAgIHN3YXAKICAgIGNvbmNhdAogICAgc3dhcAogICAgY29uY2F0CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo4OTUtODk5CiAgICAvLyByZXR1cm4gWwogICAgLy8gICAgIHsgaWQ6IHZhbGlkYXRvcklkLCBwb29sSWQ6IGkgKyAxLCBwb29sQXBwSWQ6IHBvb2xzW2ldLnBvb2xBcHBJZCB9LAogICAgLy8gICAgIGlzTmV3U3Rha2VyVG9WYWxpZGF0b3IsCiAgICAvLyAgICAgaXNOZXdTdGFrZXJUb1Byb3RvY29sLAogICAgLy8gXQogICAgYnl0ZWMgNyAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfZGlnIDkKICAgIHNldGJpdAogICAgaW50Y18xIC8vIDEKICAgIGZyYW1lX2RpZyAxMAogICAgc2V0Yml0CiAgICBjb25jYXQKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgpjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuZmluZFBvb2xGb3JTdGFrZXJfYWZ0ZXJfaWZfZWxzZUAxNjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjg5MwogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IGN1ck51bVBvb2xzOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyA3CiAgICBpbnRjXzEgLy8gMQogICAgKwogICAgZnJhbWVfYnVyeSA3CiAgICBiIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl93aGlsZV90b3BAMTMKCmNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5maW5kUG9vbEZvclN0YWtlcl9hZnRlcl93aGlsZUAxNzoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjkwMwogICAgLy8gcmV0dXJuIFt7IGlkOiB2YWxpZGF0b3JJZCwgcG9vbElkOiAwLCBwb29sQXBwSWQ6IDAgfSwgaXNOZXdTdGFrZXJUb1ZhbGlkYXRvciwgaXNOZXdTdGFrZXJUb1Byb3RvY29sXQogICAgaW50Y18wIC8vIDAKICAgIGl0b2IKICAgIGZyYW1lX2RpZyAzCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGJ5dGVjIDcgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIGZyYW1lX2RpZyA5CiAgICBzZXRiaXQKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9kaWcgMTAKICAgIHNldGJpdAogICAgY29uY2F0CiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKCi8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjpWYWxpZGF0b3JSZWdpc3RyeS5jYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZDogdWludDY0KSAtPiB2b2lkOgpjYWxsZXJNdXN0QmVPd25lcjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk4MQogICAgLy8gcHJpdmF0ZSBjYWxsZXJNdXN0QmVPd25lcih2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlKTogdm9pZCB7CiAgICBwcm90byAxIDAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk4MwogICAgLy8gVHhuLnNlbmRlciA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcub3duZXIsCiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk4MwogICAgLy8gVHhuLnNlbmRlciA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcub3duZXIsCiAgICBib3hfZ2V0CiAgICBhc3NlcnQgLy8gQm94IG11c3QgaGF2ZSB2YWx1ZQogICAgZXh0cmFjdCAwIDI0MgogICAgZXh0cmFjdCA4IDMyCiAgICA9PQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTgyLTk4NQogICAgLy8gYXNzZXJ0KAogICAgLy8gICAgIFR4bi5zZW5kZXIgPT09IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm93bmVyLAogICAgLy8gICAgICdjYW4gb25seSBiZSBjYWxsZWQgYnkgdmFsaWRhdG9yIG93bmVyJywKICAgIC8vICkKICAgIGFzc2VydCAvLyBjYW4gb25seSBiZSBjYWxsZWQgYnkgdmFsaWRhdG9yIG93bmVyCiAgICByZXRzdWIKCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkuY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXIodmFsaWRhdG9ySWQ6IHVpbnQ2NCkgLT4gdm9pZDoKY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXI6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5ODgKICAgIC8vIHByaXZhdGUgY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXIodmFsaWRhdG9ySWQ6IFZhbGlkYXRvcklkVHlwZSk6IHZvaWQgewogICAgcHJvdG8gMSAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5OTAKICAgIC8vIFR4bi5zZW5kZXIgPT09IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm93bmVyIHx8CiAgICB0eG4gU2VuZGVyCiAgICBmcmFtZV9kaWcgLTEKICAgIGl0b2IKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwNwogICAgLy8gdmFsaWRhdG9yTGlzdCA9IEJveE1hcDxWYWxpZGF0b3JJZFR5cGUsIFZhbGlkYXRvckluZm8+KHsga2V5UHJlZml4OiAndicgfSkKICAgIGJ5dGVjXzAgLy8gInYiCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGR1cAogICAgY292ZXIgMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTkwCiAgICAvLyBUeG4uc2VuZGVyID09PSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5vd25lciB8fAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIEJveCBtdXN0IGhhdmUgdmFsdWUKICAgIGV4dHJhY3QgMCAyNDIKICAgIGV4dHJhY3QgOCAzMgogICAgPT0KICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjk5MC05OTEKICAgIC8vIFR4bi5zZW5kZXIgPT09IHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUuY29uZmlnLm93bmVyIHx8CiAgICAvLyAgICAgVHhuLnNlbmRlciA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcubWFuYWdlciwKICAgIGJueiBjYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcl9ib29sX3RydWVAMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTkxCiAgICAvLyBUeG4uc2VuZGVyID09PSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5tYW5hZ2VyLAogICAgdHhuIFNlbmRlcgogICAgZnJhbWVfZGlnIDAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBleHRyYWN0IDAgMjQyCiAgICBleHRyYWN0IDQwIDMyCiAgICA9PQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OTkwLTk5MQogICAgLy8gVHhuLnNlbmRlciA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcub3duZXIgfHwKICAgIC8vICAgICBUeG4uc2VuZGVyID09PSB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLmNvbmZpZy5tYW5hZ2VyLAogICAgYnogY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXJfYm9vbF9mYWxzZUAzCgpjYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcl9ib29sX3RydWVAMjoKICAgIGludGNfMSAvLyAxCgpjYWxsZXJNdXN0QmVPd25lck9yTWFuYWdlcl9ib29sX21lcmdlQDQ6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo5ODktOTkzCiAgICAvLyBhc3NlcnQoCiAgICAvLyAgICAgVHhuLnNlbmRlciA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcub3duZXIgfHwKICAgIC8vICAgICAgICAgVHhuLnNlbmRlciA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcubWFuYWdlciwKICAgIC8vICAgICAnY2FuIG9ubHkgYmUgY2FsbGVkIGJ5IG93bmVyIG9yIG1hbmFnZXIgb2YgdmFsaWRhdG9yJywKICAgIC8vICkKICAgIGFzc2VydCAvLyBjYW4gb25seSBiZSBjYWxsZWQgYnkgb3duZXIgb3IgbWFuYWdlciBvZiB2YWxpZGF0b3IKICAgIHJldHN1YgoKY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXJfYm9vbF9mYWxzZUAzOgogICAgaW50Y18wIC8vIDAKICAgIGIgY2FsbGVyTXVzdEJlT3duZXJPck1hbmFnZXJfYm9vbF9tZXJnZUA0CgoKLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LnZlcmlmeVBvb2xLZXlDYWxsZXIocG9vbEtleTogYnl0ZXMpIC0+IGJ5dGVzOgp2ZXJpZnlQb29sS2V5Q2FsbGVyOgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAwMQogICAgLy8gcHJpdmF0ZSB2ZXJpZnlQb29sS2V5Q2FsbGVyKHBvb2xLZXk6IFZhbGlkYXRvclBvb2xLZXkpOiB2b2lkIHsKICAgIHByb3RvIDEgMQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAwMgogICAgLy8gYXNzZXJ0KHRoaXMudmFsaWRhdG9yTGlzdChwb29sS2V5LmlkKS5leGlzdHMsICJ0aGUgc3BlY2lmaWVkIHZhbGlkYXRvciBpZCBpc24ndCB2YWxpZCIpCiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwCiAgICBpdG9iCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDcKICAgIC8vIHZhbGlkYXRvckxpc3QgPSBCb3hNYXA8VmFsaWRhdG9ySWRUeXBlLCBWYWxpZGF0b3JJbmZvPih7IGtleVByZWZpeDogJ3YnIH0pCiAgICBieXRlY18wIC8vICJ2IgogICAgc3dhcAogICAgY29uY2F0CiAgICBkdXAKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMDIKICAgIC8vIGFzc2VydCh0aGlzLnZhbGlkYXRvckxpc3QocG9vbEtleS5pZCkuZXhpc3RzLCAidGhlIHNwZWNpZmllZCB2YWxpZGF0b3IgaWQgaXNuJ3QgdmFsaWQiKQogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gdGhlIHNwZWNpZmllZCB2YWxpZGF0b3IgaWQgaXNuJ3QgdmFsaWQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMDMKICAgIC8vIGFzc2VydChwb29sS2V5LnBvb2xJZCA8PSBNQVhfUE9PTFMsICdwb29sIGlkIG5vdCBpbiB2YWxpZCByYW5nZScpCiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMyAvLyA4CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZHVwbiAyCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICA8PQogICAgYXNzZXJ0IC8vIHBvb2wgaWQgbm90IGluIHZhbGlkIHJhbmdlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDA1CiAgICAvLyBwb29sS2V5LnBvb2xJZCA+IDAgJiYgcG9vbEtleS5wb29sSWQgPD0gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzLmFzVWludDY0KCksCiAgICBieiB2ZXJpZnlQb29sS2V5Q2FsbGVyX2Jvb2xfZmFsc2VAMwogICAgZnJhbWVfZGlnIDEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBleHRyYWN0IDI0MiAyNgogICAgaW50Y18wIC8vIDAKICAgIGV4dHJhY3RfdWludDE2CiAgICBmcmFtZV9kaWcgMgogICAgPj0KICAgIGJ6IHZlcmlmeVBvb2xLZXlDYWxsZXJfYm9vbF9mYWxzZUAzCiAgICBpbnRjXzEgLy8gMQoKdmVyaWZ5UG9vbEtleUNhbGxlcl9ib29sX21lcmdlQDQ6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDA0LTEwMDcKICAgIC8vIGFzc2VydCgKICAgIC8vICAgICBwb29sS2V5LnBvb2xJZCA+IDAgJiYgcG9vbEtleS5wb29sSWQgPD0gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnN0YXRlLm51bVBvb2xzLmFzVWludDY0KCksCiAgICAvLyAgICAgJ3Bvb2wgaWQgb3V0c2lkZSBvZiByYW5nZSBvZiBwb29scyBjcmVhdGVkIGZvciB0aGlzIHZhbGlkYXRvcicsCiAgICAvLyApCiAgICBhc3NlcnQgLy8gcG9vbCBpZCBvdXRzaWRlIG9mIHJhbmdlIG9mIHBvb2xzIGNyZWF0ZWQgZm9yIHRoaXMgdmFsaWRhdG9yCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDExCiAgICAvLyBwb29sS2V5LnBvb2xBcHBJZCA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0ucG9vbEFwcElkLAogICAgZnJhbWVfZGlnIC0xCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgZnJhbWVfZGlnIDEKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICBmcmFtZV9kaWcgMgogICAgZHVwCiAgICBjb3ZlciAzCiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgc3dhcAogICAgaW50YyA0IC8vIDI2OAogICAgaW50YyA1IC8vIDQzMgogICAgZXh0cmFjdDMKICAgIHN3YXAKICAgIGludGNfMiAvLyAxOAogICAgKgogICAgaW50Y18yIC8vIDE4CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGludGNfMCAvLyAwCiAgICBleHRyYWN0X3VpbnQ2NAogICAgZGlnIDEKICAgID09CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDEwLTEwMTMKICAgIC8vIGFzc2VydCgKICAgIC8vICAgICBwb29sS2V5LnBvb2xBcHBJZCA9PT0gdGhpcy52YWxpZGF0b3JMaXN0KHBvb2xLZXkuaWQpLnZhbHVlLnBvb2xzW3Bvb2xLZXkucG9vbElkIC0gMV0ucG9vbEFwcElkLAogICAgLy8gICAgICJUaGUgcGFzc2VkIGluIGFwcCBpZCBkb2Vzbid0IG1hdGNoIHRoZSBwYXNzZWQgaW4gaWRzIiwKICAgIC8vICkKICAgIGFzc2VydCAvLyBUaGUgcGFzc2VkIGluIGFwcCBpZCBkb2Vzbid0IG1hdGNoIHRoZSBwYXNzZWQgaW4gaWRzCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMDE1CiAgICAvLyBhc3NlcnQoVHhuLnNlbmRlciA9PT0gQXBwbGljYXRpb24ocG9vbEtleS5wb29sQXBwSWQpLmFkZHJlc3MpCiAgICB0eG4gU2VuZGVyCiAgICBkaWcgMQogICAgYXBwX3BhcmFtc19nZXQgQXBwQWRkcmVzcwogICAgYXNzZXJ0IC8vIGFwcGxpY2F0aW9uIGV4aXN0cwogICAgPT0KICAgIGFzc2VydAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTAxNwogICAgLy8gYXNzZXJ0KHBvb2xLZXkuaWQgPT09IG9wLkFwcEdsb2JhbC5nZXRFeFVpbnQ2NChwb29sS2V5LnBvb2xBcHBJZCwgQnl0ZXMoJ3ZhbGlkYXRvcklkJykpWzBdKQogICAgZHVwCiAgICBwdXNoYnl0ZXMgInZhbGlkYXRvcklkIgogICAgYXBwX2dsb2JhbF9nZXRfZXgKICAgIHBvcAogICAgZnJhbWVfZGlnIDAKICAgID09CiAgICBhc3NlcnQKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEwMTgKICAgIC8vIGFzc2VydChwb29sS2V5LnBvb2xJZCA9PT0gb3AuQXBwR2xvYmFsLmdldEV4VWludDY0KHBvb2xLZXkucG9vbEFwcElkLCBCeXRlcygncG9vbElkJykpWzBdKQogICAgcHVzaGJ5dGVzICJwb29sSWQiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgcG9wCiAgICA9PQogICAgYXNzZXJ0CiAgICBmcmFtZV9kaWcgLTEKICAgIGZyYW1lX2J1cnkgMAogICAgcmV0c3ViCgp2ZXJpZnlQb29sS2V5Q2FsbGVyX2Jvb2xfZmFsc2VAMzoKICAgIGludGNfMCAvLyAwCiAgICBiIHZlcmlmeVBvb2xLZXlDYWxsZXJfYm9vbF9tZXJnZUA0CgoKLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmFkZFBvb2xUb05vZGUodmFsaWRhdG9ySWQ6IHVpbnQ2NCwgcG9vbEFwcElkOiB1aW50NjQsIG5vZGVOdW06IHVpbnQ2NCkgLT4gdm9pZDoKYWRkUG9vbFRvTm9kZToKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMDQKICAgIC8vIHByaXZhdGUgYWRkUG9vbFRvTm9kZSh2YWxpZGF0b3JJZDogVmFsaWRhdG9ySWRUeXBlLCBwb29sQXBwSWQ6IHVpbnQ2NCwgbm9kZU51bTogdWludDY0KSB7CiAgICBwcm90byAzIDAKICAgIGJ5dGVjXzIgLy8gIiIKICAgIGR1cG4gMgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwNQogICAgLy8gY29uc3Qgbm9kZVBvb2xBc3NpZ25tZW50cyA9IGNsb25lKHRoaXMudmFsaWRhdG9yTGlzdCh2YWxpZGF0b3JJZCkudmFsdWUubm9kZVBvb2xBc3NpZ25tZW50cykKICAgIGZyYW1lX2RpZyAtMwogICAgaXRvYgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTA3CiAgICAvLyB2YWxpZGF0b3JMaXN0ID0gQm94TWFwPFZhbGlkYXRvcklkVHlwZSwgVmFsaWRhdG9ySW5mbz4oeyBrZXlQcmVmaXg6ICd2JyB9KQogICAgYnl0ZWNfMCAvLyAidiIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjA1CiAgICAvLyBjb25zdCBub2RlUG9vbEFzc2lnbm1lbnRzID0gY2xvbmUodGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5ub2RlUG9vbEFzc2lnbm1lbnRzKQogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBCb3ggbXVzdCBoYXZlIHZhbHVlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjA2CiAgICAvLyBjb25zdCBtYXhQb29sc1Blck5vZGVGb3JUaGlzVmFsaWRhdG9yID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcucG9vbHNQZXJOb2RlCiAgICBleHRyYWN0IDAgMjQyCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjA4CiAgICAvLyBhc3NlcnQobm9kZU51bSA+PSAxICYmIG5vZGVOdW0gPD0gTUFYX05PREVTLCAnbm9kZSBudW1iZXIgbm90IGluIHZhbGlkIHJhbmdlJykKICAgIGZyYW1lX2RpZyAtMQogICAgYnogYWRkUG9vbFRvTm9kZV9ib29sX2ZhbHNlQDMKICAgIGZyYW1lX2RpZyAtMQogICAgaW50Y18zIC8vIDgKICAgIDw9CiAgICBieiBhZGRQb29sVG9Ob2RlX2Jvb2xfZmFsc2VAMwogICAgaW50Y18xIC8vIDEKCmFkZFBvb2xUb05vZGVfYm9vbF9tZXJnZUA0OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIwOAogICAgLy8gYXNzZXJ0KG5vZGVOdW0gPj0gMSAmJiBub2RlTnVtIDw9IE1BWF9OT0RFUywgJ25vZGUgbnVtYmVyIG5vdCBpbiB2YWxpZCByYW5nZScpCiAgICBhc3NlcnQgLy8gbm9kZSBudW1iZXIgbm90IGluIHZhbGlkIHJhbmdlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjEwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgbWF4UG9vbHNQZXJOb2RlRm9yVGhpc1ZhbGlkYXRvci5hc1VpbnQ2NCgpOyBpICs9IDEpIHsKICAgIGludGNfMCAvLyAwCiAgICBmcmFtZV9idXJ5IDIKCmFkZFBvb2xUb05vZGVfd2hpbGVfdG9wQDU6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjEwCiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgbWF4UG9vbHNQZXJOb2RlRm9yVGhpc1ZhbGlkYXRvci5hc1VpbnQ2NCgpOyBpICs9IDEpIHsKICAgIGZyYW1lX2RpZyA1CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjA2CiAgICAvLyBjb25zdCBtYXhQb29sc1Blck5vZGVGb3JUaGlzVmFsaWRhdG9yID0gdGhpcy52YWxpZGF0b3JMaXN0KHZhbGlkYXRvcklkKS52YWx1ZS5jb25maWcucG9vbHNQZXJOb2RlCiAgICBwdXNoaW50IDIyNSAvLyAyMjUKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMTAKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBtYXhQb29sc1Blck5vZGVGb3JUaGlzVmFsaWRhdG9yLmFzVWludDY0KCk7IGkgKz0gMSkgewogICAgZ2V0Ynl0ZQogICAgZnJhbWVfZGlnIDIKICAgIGR1cAogICAgdW5jb3ZlciAyCiAgICA8CiAgICBhc3NlcnQgLy8gbm8gYXZhaWxhYmxlIHNwYWNlIGluIHNwZWNpZmllZCBub2RlIGZvciB0aGlzIHBvb2wKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEyMTEKICAgIC8vIGlmIChub2RlUG9vbEFzc2lnbm1lbnRzLm5vZGVzW25vZGVOdW0gLSAxXS5wb29sQXBwSWRzW2ldID09PSAwKSB7CiAgICBmcmFtZV9kaWcgLTEKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBmcmFtZV9kaWcgNAogICAgaW50YyA4IC8vIDkwMAogICAgaW50YyA5IC8vIDE5MgogICAgZXh0cmFjdDMKICAgIGV4dHJhY3QgMCAxOTIKICAgIHN3YXAKICAgIHB1c2hpbnQgMjQgLy8gMjQKICAgICoKICAgIGR1cAogICAgZnJhbWVfYnVyeSAwCiAgICBwdXNoaW50IDI0IC8vIDI0CiAgICBleHRyYWN0MyAvLyBvbiBlcnJvcjogaW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGV4dHJhY3QgMCAyNAogICAgc3dhcAogICAgaW50Y18zIC8vIDgKICAgICoKICAgIGR1cAogICAgZnJhbWVfYnVyeSAxCiAgICBleHRyYWN0X3VpbnQ2NAogICAgYm56IGFkZFBvb2xUb05vZGVfYWZ0ZXJfaWZfZWxzZUA4CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMjEzCiAgICAvLyB0aGlzLnZhbGlkYXRvckxpc3QodmFsaWRhdG9ySWQpLnZhbHVlLm5vZGVQb29sQXNzaWdubWVudHMubm9kZXNbbm9kZU51bSAtIDFdLnBvb2xBcHBJZHNbaV0gPSBwb29sQXBwSWQKICAgIGZyYW1lX2RpZyAtMgogICAgaXRvYgogICAgaW50YyA4IC8vIDkwMAogICAgZnJhbWVfZGlnIDAKICAgICsKICAgIGZyYW1lX2RpZyAyCiAgICBwdXNoaW50IDMgLy8gMwogICAgPAogICAgYXNzZXJ0IC8vIGluZGV4IG91dCBvZiBib3VuZHMKICAgIGZyYW1lX2RpZyAxCiAgICArCiAgICBmcmFtZV9kaWcgMwogICAgc3dhcAogICAgdW5jb3ZlciAyCiAgICBib3hfcmVwbGFjZQogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxNAogICAgLy8gcmV0dXJuCiAgICByZXRzdWIKCmFkZFBvb2xUb05vZGVfYWZ0ZXJfaWZfZWxzZUA4OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTIxMAogICAgLy8gZm9yIChsZXQgaTogdWludDY0ID0gMDsgaSA8IG1heFBvb2xzUGVyTm9kZUZvclRoaXNWYWxpZGF0b3IuYXNVaW50NjQoKTsgaSArPSAxKSB7CiAgICBmcmFtZV9kaWcgMgogICAgaW50Y18xIC8vIDEKICAgICsKICAgIGZyYW1lX2J1cnkgMgogICAgYiBhZGRQb29sVG9Ob2RlX3doaWxlX3RvcEA1CgphZGRQb29sVG9Ob2RlX2Jvb2xfZmFsc2VAMzoKICAgIGludGNfMCAvLyAwCiAgICBiIGFkZFBvb2xUb05vZGVfYm9vbF9tZXJnZUA0CgoKLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6OlZhbGlkYXRvclJlZ2lzdHJ5LmlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdChuZmRBcHBJRDogdWludDY0LCBhZGRyVG9GaW5kOiBieXRlcykgLT4gdWludDY0Ogppc0FkZHJlc3NJbk5GRENBQWxnb0xpc3Q6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzI5CiAgICAvLyBwcml2YXRlIGlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdChuZmRBcHBJRDogdWludDY0LCBhZGRyVG9GaW5kOiBBY2NvdW50KTogYm9vbGVhbiB7CiAgICBwcm90byAyIDEKICAgIGludGNfMCAvLyAwCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzMwLTEzMzMKICAgIC8vIGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgICBhcHBJZDogQXBwbGljYXRpb24obmZkQXBwSUQpLAogICAgLy8gICAgIGFwcEFyZ3M6IFtCeXRlcygncmVhZF9wcm9wZXJ0eScpLCBCeXRlcygndi5jYUFsZ28uMC5hcycpXSwKICAgIC8vIH0pLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzMyCiAgICAvLyBhcHBBcmdzOiBbQnl0ZXMoJ3JlYWRfcHJvcGVydHknKSwgQnl0ZXMoJ3YuY2FBbGdvLjAuYXMnKV0sCiAgICBwdXNoYnl0ZXMgInJlYWRfcHJvcGVydHkiCiAgICBpdHhuX2ZpZWxkIEFwcGxpY2F0aW9uQXJncwogICAgcHVzaGJ5dGVzICJ2LmNhQWxnby4wLmFzIgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbkFyZ3MKICAgIGZyYW1lX2RpZyAtMgogICAgaXR4bl9maWVsZCBBcHBsaWNhdGlvbklECiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzMwLTEzMzMKICAgIC8vIGl0eG4uYXBwbGljYXRpb25DYWxsKHsKICAgIC8vICAgICBhcHBJZDogQXBwbGljYXRpb24obmZkQXBwSUQpLAogICAgLy8gICAgIGFwcEFyZ3M6IFtCeXRlcygncmVhZF9wcm9wZXJ0eScpLCBCeXRlcygndi5jYUFsZ28uMC5hcycpXSwKICAgIC8vIH0pLnN1Ym1pdCgpCiAgICBwdXNoaW50IDYgLy8gNgogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTMzNAogICAgLy8gY29uc3QgY2FBbGdvRGF0YSA9IG9wLklUeG4ubGFzdExvZwogICAgaXR4biBMYXN0TG9nCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzM1CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgY2FBbGdvRGF0YS5sZW5ndGg7IGkgKz0gMzIpIHsKICAgIGludGNfMCAvLyAwCgppc0FkZHJlc3NJbk5GRENBQWxnb0xpc3Rfd2hpbGVfdG9wQDI6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzM1CiAgICAvLyBmb3IgKGxldCBpOiB1aW50NjQgPSAwOyBpIDwgY2FBbGdvRGF0YS5sZW5ndGg7IGkgKz0gMzIpIHsKICAgIGZyYW1lX2RpZyAxCiAgICBsZW4KICAgIGZyYW1lX2RpZyAyCiAgICA+CiAgICBieiBpc0FkZHJlc3NJbk5GRENBQWxnb0xpc3RfYWZ0ZXJfd2hpbGVANwogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTMzNgogICAgLy8gY29uc3QgYWRkciA9IG9wLmV4dHJhY3QoY2FBbGdvRGF0YSwgaSwgMzIpCiAgICBmcmFtZV9kaWcgMQogICAgZnJhbWVfZGlnIDIKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgIGV4dHJhY3QzCiAgICBkdXAKICAgIGZyYW1lX2J1cnkgMAogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTMzNwogICAgLy8gaWYgKGFkZHIgIT09IGVuY29kZUFyYzQoR2xvYmFsLnplcm9BZGRyZXNzKSAmJiBhZGRyID09PSBlbmNvZGVBcmM0KGFkZHJUb0ZpbmQpKSB7CiAgICBnbG9iYWwgWmVyb0FkZHJlc3MKICAgICE9CiAgICBieiBpc0FkZHJlc3NJbk5GRENBQWxnb0xpc3RfYWZ0ZXJfaWZfZWxzZUA2CiAgICBmcmFtZV9kaWcgMAogICAgZnJhbWVfZGlnIC0xCiAgICA9PQogICAgYnogaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0X2FmdGVyX2lmX2Vsc2VANgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTMzOAogICAgLy8gcmV0dXJuIHRydWUKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKaXNBZGRyZXNzSW5ORkRDQUFsZ29MaXN0X2FmdGVyX2lmX2Vsc2VANjoKICAgIC8vIGNvbnRyYWN0cy92YWxpZGF0b3JSZWdpc3RyeS5hbGdvLnRzOjEzMzUKICAgIC8vIGZvciAobGV0IGk6IHVpbnQ2NCA9IDA7IGkgPCBjYUFsZ29EYXRhLmxlbmd0aDsgaSArPSAzMikgewogICAgZnJhbWVfZGlnIDIKICAgIHB1c2hpbnQgMzIgLy8gMzIKICAgICsKICAgIGZyYW1lX2J1cnkgMgogICAgYiBpc0FkZHJlc3NJbk5GRENBQWxnb0xpc3Rfd2hpbGVfdG9wQDIKCmlzQWRkcmVzc0luTkZEQ0FBbGdvTGlzdF9hZnRlcl93aGlsZUA3OgogICAgLy8gY29udHJhY3RzL3ZhbGlkYXRvclJlZ2lzdHJ5LmFsZ28udHM6MTM0MQogICAgLy8gcmV0dXJuIGZhbHNlCiAgICBpbnRjXzAgLy8gMAogICAgZnJhbWVfYnVyeSAwCiAgICByZXRzdWIKCgovLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czo6VmFsaWRhdG9yUmVnaXN0cnkubWF4QWxsb3dlZFN0YWtlKCkgLT4gdWludDY0OgptYXhBbGxvd2VkU3Rha2U6CiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzczCiAgICAvLyByZXR1cm4gb3Aub25saW5lU3Rha2UoKQogICAgb25saW5lX3N0YWtlCiAgICAvLyBjb250cmFjdHMvdmFsaWRhdG9yUmVnaXN0cnkuYWxnby50czoxMzYyCiAgICAvLyByZXR1cm4gd2lkZVJhdGlvKFtvbmxpbmUsIE1BWF9WQUxJREFUT1JfSEFSRF9QQ1RfT0ZfT05MSU5FXzFERUNJTUFMXSwgWzEwMDBdKQogICAgaXRvYgogICAgYnl0ZWMgMTEgLy8gMHgwMDAyCiAgICBzd2FwCiAgICBjb25jYXQKICAgIHB1c2hpbnQgMTUwIC8vIDE1MAogICAgaXRvYgogICAgY29uY2F0CiAgICBieXRlYyAxNSAvLyAweDAwMDEwMDAwMDAwMDAwMDAwM2U4CiAgICBjYWxsc3ViIHdpZGVSYXRpbwogICAgcG9wbiAyCiAgICByZXRzdWIK","clear":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBAYWxnb3JhbmRmb3VuZGF0aW9uL2FsZ29yYW5kLXR5cGVzY3JpcHQvYmFzZS1jb250cmFjdC5kLnRzOjpCYXNlQ29udHJhY3QuY2xlYXJTdGF0ZVByb2dyYW0oKSAtPiB1aW50NjQ6Cm1haW46CiAgICBwdXNoaW50IDEgLy8gMQogICAgcmV0dXJuCg=="},"byteCode":{"approval":"CyARAAESCIwCsAPIAbwFhAfAAcCEPeIBgCCWAvwB9MIEACYSAXYEFR98dQAGc3Rha2VkCm51bVN0YWtlcnMZcG9vbFRlbXBsYXRlQXBwcm92YWxCeXRlcwNzcHMBAARudW1WCWkub3duZXIuYQRpbml0AgACAgAAAwaBARAAAAAAAAAAAAAAAAAAAAABCgABAAAAAAAAA+gEY/PyiwQS9L1LMRkURDEYQQEggiEEG16CxgR5Ry2DBF96z9kEMXLKnQSKhxQtBNE2bMMEOwRcXAR1r/YdBB8vAQkEL6IsSwSRDpSsBFcnZ9EEm1BKrwT7xjF4BCRJjPQE+EbdegSDBQUBBHu7bI0E+DlBSgQMMXz7BD4oiXIE3V+q2gQYqsenBPme9U0EEICdTQTneN1aBL9SWdAETfjYbgRBj878BKLcUbUEKHP1BAQFR/T+BMtmg1g2GgCOIQEXASIALAAqAAEBOgGXAaMBtgHJAeUCMgJ1ApcCpQK7Ax0DMgNMA1UEcASNBLAE0wTxBVQGTQmXCqoLpg4lDjkO9gCAJBUffHUAAAAAAAbCFAAAAAAADrOsAAAAAABPu1QAAAAAAAEhdLAjQyNDJwojZyNDgAS4RHs2NhoAjgEAxwCKAgCL/oEKCIsAMgwNQQAqsYEGshCBBbIZJw2yHicNsh+L/40CAAsABLNC/9syALIBQv/1IrIBQv/viYoCAyIqSScOi/4iWSKLBYsEDEEAJIv+VwIAiwVJTgIlCyVYiwOjSRWBEA5EgRCvq4wDIwiMBUL/1CcOjACL/yJZjAEijAKLAosBDEEAJIv/VwIAiwJJTgIlCyVYiwCjSRWBEA5EgRCvq4wAIwiMAkL/1IsDiwCiSRUlDkQlr6sXi/6L/4wCjAGMAIknCiJnJwgiZycEImcrImcjQzYaARcnBUy5SCNDNhoBFzYaAlcCACInCmVEFEQnBU4CuyNDMhaIES51FicLTFCBZBZQJw+I/y1GAk8CFoAoAAAAAAAAAAEAAAAAAA9CQAAAAAAAAAAAAAAAAAAPQkAAAAAAAA9CQExQTwIWUEwWUCUWUIEDFlAhBhZQKUxQsCNDIicIZUQWKUxQsCNDNhoBFxYoTFC+RFcA8ilMULAjQzYaARcWKExQvkRX8hopTFCwI0M2GgEXFihMUL5EVwDySVcIIExXKCBQKUxQsCNDIjYaARcnDEwWKExQvkQiSYEYDEEAMEsBIQQhBVhLASQLJFhJRQUiW0EAG0sCSUsFUEwiWSMIFlcGAlwARQNJIwhFAUL/ySlLA1CwI0M2GgEXNhoCF0lBADNLARYoTFC9RQFESYEYDkEAIiNESwEWKExQvkRLASMJTCEEIQVYTCQLJFhXAAgpTFCwI0MiQv/bNhoBSVcACChMUL5ETCVbIwlMIQQhBVhMJAskWClMULAjQzYaAReIDMoWKUxQsCNDJwY2GgFQvUUBFCcHIk8CVClMULAjQyJHAionBjYaAVBJvUUBQAAIJwwpTFCwI0MnDEUDSb5MRQVEIkUCSwGBBgxBAC9LAYEYC0sETIEYWElFBiJbQQATSwJJSwZQTCJZIwgWVwYCXABFA0sBIwhFAkL/yUsCQv+xNhoBFxYoTFC+RCEHIQZYKUxQsCNDNhoBFxYoTFBJvUUBRL5IIQghCVgpTFCwI0MhEBYpTFCwI0MiKkcEMRYjCUk4ECMSRDYaAkcCVwggSU4CSTIDE0RLAVcoIElOAzIDE0QxABJEgVBVgQQOQQDgI0RLAoGpAVpJRQlBAM5LByEKDkEAxiNESwKBrQFaSUUIIQoOQQCxI0RLBkEACUsCV7EgMgMTREsCSYHRAVshCg9EgeEBVUlFB0EAiEsFgQMOQQCAI0RLAiELW0lFBkEABksEMgcNREsDSTgHMgoSSwE4CIGUhBsSEEQ4AYGAreIEDUQiJwhlRCMIJwhLAWcWSUULKEsBUEmBxAi5SEkiSwZJTgS7Ik8Du4FIW0lFCkEACjEASwknCWVIEkRLCUlLA1BLAlCABKjdIctMULApTFCwI0MiQv99IkL/TCJC/zciQv8dNhoBFzYaAksBiAxBSTIDE0RMFihMUIEoTwK7I0M2GgEXNhoCNhoDSwKIDCFPAhYoTFBJIQtPBLuB6gFPArsjQzYaARc2GgJJF0sCiAv/MQBMJwllSBJETBYoTFCBSE8CuyNDNhoBFzYaAksBiAveSTIDE0RMFihMUIGxAU8CuyNDNhoBF0k2GgJJTwI2GgNOAjYaBE4CNhoFTgI2GgZOAogLqhdJgQQMQQA1I0RJIxJBAAZLBDIDE0RLBhYoTFBJgVBLCLtJgVFLB7tJgXFLBrtJgZEBSwW7gaEBSwO7I0MiQv/IMRYjCUk4ECMSRDYaARc2GgIXSwGIC2hLAjgHMgoSTwM4CIGs5zoSEERLARYoSwFQSb1FAURJvkhJV/IaIllJgRgPFEQjCLEnBSIhDLonBb1IIQwJJwUhDE8CujIIFksDFk8FVwDyV9EIgARZ6QqmshpPArIaSwayGksBshqyGoEDsjiBA7I1gQuyNIAEC4EBQ7JCTwKyQEyyQCKyGYEGshAisgGzSZOBEA5ESVcGAksDgfIBSwK7tD1PAyMJSwEWSwGBGAxETCQLIQQITwVMSwK7TwZPAk8GiAtXSwNPAlBMUIAE+8wPa0xQsLQ9TgJQTBZQKUxQsCNDIkcHKkcOMRYjCUk4ECMSRDYaARdJNhoCF0wWSShMUEcCvUUBRL5IVwDyIQtbQQANSb5EVwDyIQtbMgcNRDEASUUYSwVJTgI4AElFGBJMOAcyChIQREm+RFcA8oFQVUlFCkEA4zEARRZJvkxFHURLCCMSSUUJQAAQSwiBAhJAAAhLCIEDEkEAIUsCREm+RFcA8oGRAVtJRRVAAAMjRRRLFUsDcABISxQPREsHQQAPSwJxC0RLHFcA8ldRIBJESwiBAhJBACciRRIiRQ1LDIEEDEEAFksbVwDyV3EgSw0lC1tLAxJBAlsjRRJLEURLCIEDEkEAE0sbVwDyV3EgIltLA3ELRIgKsURLCIEEEkEAOEsCJwllSEsWEkAACksCSxaICpVBAhgjREsCgA1pLnBhcmVudEFwcElEZUgXSxxXAPJXcSAiWxJESwQ4CEULIkUMJwZLF1BJRRu9RQFBAcpLCkUKSb5EV/IagQpbSwpJTgIIiAqsDERLBEsYTwKIB9VJVwAYSU4CRRtJIQlTRRCBwQFTRRAlW0lFBxQUREsZSb1FAUS+SEUYIkUTIkURSxm9RQFESxCBBgxBAVlLEIEYC0sYTIEYWElFHCJbSUUISxkiWxJBABhLGiVbSwYSQQAOSxqBEFtLGYEQWxJAABlLEkAAC0sGQAAGSxAjCEUTSxAjCEURQv+mSxhXAAgoTFBJRQJJvkRLByMJTCEEIQVYSwEkC0xLASRYIluxSw5LEAlJTgJFFUlyCESyB0yyCCOyECKyAbaABPnHDL2yGksYshpJshiBBrIQIrIBs7cBPlcABCkSRIH0AyKI94dJJwRlTwIrZU8CRERMFkmTgRAORFcGAk8DgRgMREsCgZQCCEsETE8CuxZMIQ0ITLtLDUEAEkcCvkRX8hqBAlsjCBaB9AFMu0sOQQALIicEZUQjCCcETGdHAr5EV/IagQpbSxFJTgIIFk8CIQ5PArsiK2VECCtMZ0sFFkmTgRAORFcGAksZSU4CVxAISwRPAlBMUEsYUEsLFlCABJYrQUNMULApTFCwI0NLEkkUFEQjCYEYC0saTEsau0L+3yEPRQxLCiEPCUUKSxmBkAG5SEL+JSJC/eVLDCMIRQ1C/YEiKkcDNhoBFxYoTFBJvkQhBCEFWFcAEiJbRwJEMQBMcghEE0EAD0sBvkQhByEGWClMULAjQzIGRQVLAb5EIQchBlghCVtJRQRBAE9JgApsYXN0UGF5b3V0ZUhLAxJBAAxLAb5EIQchBlhC/8NLAb5EVwDygakBWksFSU4CSwEYTwJMCUsESU8DGAkSQQAMSwG+RCEHIQZYQv+VSwQWSwJJTgKB/AZPAru+SFfyGkkiWUUHVwoIRQciRQRLA0sGDEEARUsBSb5EIQQhBVhLBUlOAiQLJFhXCggnC0xQIQoWUIACAAFLClCI9fpGAhZLAYEYDERLASULIQcITwNMTwK7IwhFBEL/s0sBvkQhByEGWEL/HCI2GgE2GgIXSU8CNhoDF0lOA04DNhoEF04DNhoFF04DiAY3SU4DSVcACElOBChMUElOBEm+RE8CJVtJTgUjCUwhBCEFWEsBJAtMSwEkWIEKW0sECBZPAoEYDERMIQ0ISwJMTwK7Sb5IV/IagQpbSwIIFksBIQ5PArtJvkhX8hokW08DCBZLAYGEAk8CuyIrZURPAggrTGe+SFcA8kmBSFtJQQAlSScJZUhJRQxLAlcIIBNBABRLAVcoIEsLE0EACSIWSwSBSE8Cu0sCFkmTgRAORFcGAksGVxAISwZPAlBMUEsIFlBLBxZQSwoWUEsJFlCABLPkfD1MULAjQyJHBSpHCjYaAjYaATYaAxdJTgI2GgRJTgMXTgI2GgUiU04CgawCIoj0cEyIBTBMQAAFSwJBAkQjREcCVwAISUUVKExQSUUXSb5ETwIlW0lFCiMJTCEEIQVYSwEkC0lFFUxLASRYgQpbSwhJTgQJFk8CgRgMREwhDQhLA0xPArtLAb5IV/IagQpbSwEJFk8CIQ5PArsiK2VETAkrTGdLAkEBqksUSb5ESVcA8klXmQhFGYGZAVtJRQ5EV/IaJFtJSwVJTgMPREwJFoGEAky7SwYjE0EAKbFLFL5EIQQhBVhXABIiWycQshpLBrIaSxayGksEshqyGIEGshAisgGzSwYWSZOBEA5EVwYCSwFXEAhLFE8CUExQSwZQSwUWUEsDFlBLCxZQJxFMULBLAUEBG0sUSb5EIQQhBVhLEklOAiRYJVkjCRZJk4EQDkRXBgJMgZQCCEy7SVcQCEsHFksUTFBMUEUBIkUMIkUNIkUPJwZLBlBJRRW+TEUTRCJFDksTvUUBREsNgQYMQQB+Sw2BGAtJRRFLEkyBGFhJRRgiW0lFCUEAU0sMIwhFDUkiW0sIEklFCkEAQUsIQQBFSxYlW0sBJVsSQQA5SxaBEFtLAYEQWxJBACsjRQ9LE0sQgBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC7Sw0jCEUOQv99SwsjCEUMQv/uSw5ESwsUSw0UJwciTwNUI08CVEkiU0wjU0ULQQATSxRJvkRX8hqBAlsjCRaB9AFMu0sJQQALIicEZUQjCScETGcjQ0sGFkmTgRAORFcGAksBVxAISxRPAlBMUEsGUEsFFlAiFkxLAVBMUCcRTFCwQv6vIkL9uTYaARc2GgI2GgMXiAFuKUxQsCNDKkcENhoBF0k2GgIXTDYaAxdJTwJJiAKCFihMUElOAr5MTgJEQQCSSwIlDkEAiyNEIkUHSwYlDEQiRQhLB4EDDElFB0EAakkhCCEJWFcAwEsHgRgLSUUMgRhYVwAYSwglC0lFC1tLBBJBADxLAkkjCUsIE0QiFiEISwwISwhESwsISwRMTwK7sYAEUe87IbIaSwRJshiBBrIQIrIBs0sGTE8CiAKoI0NLByMIRQhC/4tLBiMIRQdC/3oiQv9yNhoBFzYaAksBiAG7TBYoTFC+RElXAPJJV5kITIGZAVtLAlfyGiRbSwFETwMhBCEFWFcAEiJbSXIIREsDcABISwIJsRYnELIaTwWyGk8EshpJshpLAbIYgQayECKyAbNMcghETwNwAEhPAhJEKUxQsCNDigEBi/8WKExQSb5EV/IaIlmIAvFMCky+RFcA8oHZAVtJQAAEMhaMAYsAiwEMQQAEiwCMAYsBjACJigMBIkcEKkcDI0mL/Yj/tycGi/5QSb1FAUEAdosMvkyMBESL/UQijAaLBoEGDEEAYYGsAiKI8GeLBoEYC4sETIEYWEmMASJbSYwIQQA7IowKiwiL/RJBADAijAmL/RYoTFC+RIsBJVsjCUwhBCEFWEwkCyRYgQpbi/8IiwsOQQAIiwEnB1CMAImLBiMIjAZC/5eL/RZJjAMoTFC+TElOAowARElXAPKB0QFbi/8ORFfyGiJZjAUijAeLB4sFDEEARIsAIQQhBViLByQLJFhJjAKBCluL/wiLCw5BAB+LByMIiwJXAAhMFosDTFBMUCcHIosJVCOLClRQjACJiwcjCIwHQv+0IhaLA0sBUExQJwciiwlUI4sKVFCMAImKAQAxAIv/FihMUL5EVwDyVwggEkSJigEAMQCL/xYoTFBJTgK+RFcA8lcIIBJAABAxAIsAvkRXAPJXKCASQQADI0SJIkL/+ooBAYv/IltJFihMUEm9RQFEi/8lW0cCgRgOREEAYIsBvkRX8hoiWYsCD0EAUSNEi/+BEFuLAb5EiwJJTgMjCUwhBCEFWEwkCyRYIltLARJEMQBLAXIIRBJESYALdmFsaWRhdG9ySWRlSIsAEkSABnBvb2xJZGVIEkSL/4wAiSJC/6yKAwAqRwKL/RYoTFBJvkxJTwJEVwDyi/9BAF+L/yUOQQBYI0QijAKLBYHhAVWLAklPAgxEi/8jCYsEIQghCVhXAMBMgRgLSYwAgRhYVwAYTCULSYwBW0AAGIv+FiEIiwAIiwKBAwxEiwEIiwNMTwK7iYsCIwiMAkL/rSJC/6WKAgEisYANcmVhZF9wcm9wZXJ0ebIagA12LmNhQWxnby4wLmFzshqL/rIYgQayECKyAbO0PiKLARWLAg1BACaLAYsCgSBYSYwAMgMTQQAMiwCL/xJBAAQjjACJiwKBIAiMAkL/0SKMAIl1FicLTFCBlgEWUCcPiO3+RgKJ","clear":"C4EBQw=="},"events":[{"name":"retiOP_addedValidator","args":[{"type":"uint64","name":"id"},{"type":"address","name":"owner"},{"type":"address","name":"manager"}]},{"name":"retiOP_validatorAddedPool","args":[{"type":"uint64","name":"id"},{"type":"uint16","name":"num"},{"type":"uint64","name":"poolAppId"}]},{"name":"retiOP_stakeAdded","args":[{"type":"uint64","name":"id"},{"type":"uint16","name":"poolNum"},{"type":"uint64","name":"poolAppId"},{"type":"address","name":"staker"},{"type":"uint64","name":"amountStaked"}]},{"name":"retiOP_epochRewardUpdate","args":[{"type":"uint64","name":"id"},{"type":"uint16","name":"poolNum"},{"type":"uint64","name":"poolAppId"},{"type":"uint64","name":"validatorCommission"},{"type":"uint64","name":"saturatedBurnToFeeSink"},{"type":"uint64","name":"algoAdded"},{"type":"uint64","name":"rewardTokenHeldBack"}]},{"name":"retiOP_stakeRemoved","args":[{"type":"uint64","name":"id"},{"type":"uint16","name":"poolNum"},{"type":"uint64","name":"poolAppId"},{"type":"address","name":"staker"},{"type":"uint64","name":"amountUnstaked"},{"type":"uint64","name":"rewardTokensReceived"},{"type":"uint64","name":"rewardTokenAssetId"}]}],"templateVariables":{"NFD_REGISTRY_APP_ID":{"type":"AVMUint64"}}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


// Type definitions for ARC-56 structs

export type Constraints = {
  epochPayoutRoundsMin: bigint,
  epochPayoutRoundsMax: bigint,
  minPctToValidatorWFourDecimals: bigint,
  maxPctToValidatorWFourDecimals: bigint,
  minEntryStake: bigint,
  maxAlgoPerPool: bigint,
  maxAlgoPerValidator: bigint,
  amtConsideredSaturated: bigint,
  maxNodes: bigint,
  maxPoolsPerNode: bigint,
  maxStakersPerPool: bigint
}


/**
 * Converts the ABI tuple representation of a Constraints to the struct representation
 */
export function ConstraintsFromTuple(abiTuple: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.Constraints, APP_SPEC.structs) as Constraints
}

export type MbrAmounts = {
  addValidatorMbr: bigint,
  addPoolMbr: bigint,
  poolInitMbr: bigint,
  addStakerMbr: bigint
}


/**
 * Converts the ABI tuple representation of a MbrAmounts to the struct representation
 */
export function MbrAmountsFromTuple(abiTuple: [bigint, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.MbrAmounts, APP_SPEC.structs) as MbrAmounts
}

export type NodePoolAssignmentConfig = {
  nodes: [[[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]]]
}


/**
 * Converts the ABI tuple representation of a NodePoolAssignmentConfig to the struct representation
 */
export function NodePoolAssignmentConfigFromTuple(abiTuple: [[[[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]]]]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.NodePoolAssignmentConfig, APP_SPEC.structs) as NodePoolAssignmentConfig
}

export type PoolInfo = {
  poolAppId: bigint,
  totalStakers: number,
  totalAlgoStaked: bigint
}


/**
 * Converts the ABI tuple representation of a PoolInfo to the struct representation
 */
export function PoolInfoFromTuple(abiTuple: [bigint, number, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.PoolInfo, APP_SPEC.structs) as PoolInfo
}

export type PoolTokenPayoutRatio = {
  poolPctOfWhole: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint],
  updatedForPayout: bigint
}


/**
 * Converts the ABI tuple representation of a PoolTokenPayoutRatio to the struct representation
 */
export function PoolTokenPayoutRatioFromTuple(abiTuple: [[bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint], bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.PoolTokenPayoutRatio, APP_SPEC.structs) as PoolTokenPayoutRatio
}

export type ValidatorConfig = {
  id: bigint,
  owner: string,
  manager: string,
  nfdForInfo: bigint,
  entryGatingType: number,
  entryGatingAddress: string,
  entryGatingAssets: [bigint, bigint, bigint, bigint],
  gatingAssetMinBalance: bigint,
  rewardTokenId: bigint,
  rewardPerPayout: bigint,
  epochRoundLength: number,
  percentToValidator: number,
  validatorCommissionAddress: string,
  minEntryStake: bigint,
  maxAlgoPerPool: bigint,
  poolsPerNode: number,
  sunsettingOn: bigint,
  sunsettingTo: bigint
}


/**
 * Converts the ABI tuple representation of a ValidatorConfig to the struct representation
 */
export function ValidatorConfigFromTuple(abiTuple: [bigint, string, string, bigint, number, string, [bigint, bigint, bigint, bigint], bigint, bigint, bigint, number, number, string, bigint, bigint, number, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.ValidatorConfig, APP_SPEC.structs) as ValidatorConfig
}

export type ValidatorCurState = {
  numPools: number,
  totalStakers: bigint,
  totalAlgoStaked: bigint,
  rewardTokenHeldBack: bigint
}


/**
 * Converts the ABI tuple representation of a ValidatorCurState to the struct representation
 */
export function ValidatorCurStateFromTuple(abiTuple: [number, bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.ValidatorCurState, APP_SPEC.structs) as ValidatorCurState
}

export type ValidatorInfo = {
  config: ValidatorConfig,
  state: ValidatorCurState,
  pools: [[bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint]],
  tokenPayoutRatio: PoolTokenPayoutRatio,
  nodePoolAssignments: NodePoolAssignmentConfig
}


/**
 * Converts the ABI tuple representation of a ValidatorInfo to the struct representation
 */
export function ValidatorInfoFromTuple(abiTuple: [[bigint, string, string, bigint, number, string, [bigint, bigint, bigint, bigint], bigint, bigint, bigint, number, number, string, bigint, bigint, number, bigint, bigint], [number, bigint, bigint, bigint], [[bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint], [bigint, number, bigint]], [[bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint], bigint], [[[[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]], [[bigint, bigint, bigint]]]]]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.ValidatorInfo, APP_SPEC.structs) as ValidatorInfo
}

export type ValidatorPoolKey = {
  id: bigint,
  poolId: bigint,
  poolAppId: bigint
}


/**
 * Converts the ABI tuple representation of a ValidatorPoolKey to the struct representation
 */
export function ValidatorPoolKeyFromTuple(abiTuple: [bigint, bigint, bigint]) {
  return getABIStructFromABITuple(abiTuple, APP_SPEC.structs.ValidatorPoolKey, APP_SPEC.structs) as ValidatorPoolKey
}

/**
 * Deploy-time template variables
 */
export type TemplateVariables = {
  NFD_REGISTRY_APP_ID: bigint,
}

/**
 * The argument types for the ValidatorRegistry contract
 */
export type ValidatorRegistryArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'createApplication()void': Record<string, never>
    'initStakingContract(uint64)void': {
      approvalProgramSize: bigint | number
    }
    'loadStakingContractData(uint64,byte[])void': {
      offset: bigint | number
      data: Uint8Array
    }
    'finalizeStakingContract()void': Record<string, never>
    'gas()void': Record<string, never>
    'getMbrAmounts()(uint64,uint64,uint64,uint64)': Record<string, never>
    'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': Record<string, never>
    'getNumValidators()uint64': Record<string, never>
    'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)': {
      validatorId: bigint | number
    }
    'getValidatorState(uint64)(uint16,uint64,uint64,uint64)': {
      validatorId: bigint | number
    }
    'getValidatorOwnerAndManager(uint64)(address,address)': {
      validatorId: bigint | number
    }
    'getPools(uint64)(uint64,uint16,uint64)[]': {
      validatorId: bigint | number
    }
    'getPoolAppId(uint64,uint64)uint64': {
      validatorId: bigint | number
      poolId: bigint | number
    }
    'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)': {
      poolKey: ValidatorPoolKey
    }
    'getCurMaxStakePerPool(uint64)uint64': {
      /**
       * - The id of the validator.
       */
      validatorId: bigint | number
    }
    'doesStakerNeedToPayMBR(address)bool': {
      staker: string
    }
    'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]': {
      /**
       * - The account to retrieve staked pools for.
       */
      staker: string
    }
    'getTokenPayoutRatio(uint64)(uint64[24],uint64)': {
      /**
       * - The id of the validator.
       */
      validatorId: bigint | number
    }
    'getNodePoolAssignments(uint64)((uint64[3])[8])': {
      validatorId: bigint | number
    }
    'getNFDRegistryID()uint64': Record<string, never>
    'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64': {
      /**
       * payment from caller which covers mbr increase of new validator storage
       */
      mbrPayment: AppMethodCallTransactionArgument
      /**
       * (Optional) Name of nfd (used as double-check against id specified in config)
       */
      nfdName: string
      /**
       * ValidatorConfig struct
       */
      config: ValidatorConfig
    }
    'changeValidatorManager(uint64,address)void': {
      /**
       * - The id of the validator to change the manager for.
       */
      validatorId: bigint | number
      /**
       * - The new manager address.
       */
      manager: string
    }
    'changeValidatorSunsetInfo(uint64,uint64,uint64)void': {
      /**
       * - The id of the validator to update.
       */
      validatorId: bigint | number
      /**
       * - The new sunset timestamp.
       */
      sunsettingOn: bigint | number
      /**
       * - The new sunset to validator id.
       */
      sunsettingTo: bigint | number
    }
    'changeValidatorNFD(uint64,uint64,string)void': {
      /**
       * - The id of the validator to update.
       */
      validatorId: bigint | number
      /**
       * - The application id of the NFD to assign to the validator.
       */
      nfdAppId: bigint | number
      /**
       * - The name of the NFD (which must match)
       */
      nfdName: string
    }
    'changeValidatorCommissionAddress(uint64,address)void': {
      validatorId: bigint | number
      commissionAddress: string
    }
    'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void': {
      validatorId: bigint | number
      entryGatingType: bigint | number
      entryGatingAddress: string
      entryGatingAssets: [bigint | number, bigint | number, bigint | number, bigint | number]
      gatingAssetMinBalance: bigint | number
      rewardPerPayout: bigint | number
    }
    'addPool(pay,uint64,uint64)(uint64,uint64,uint64)': {
      /**
       * payment from caller which covers mbr increase of adding a new pool
       */
      mbrPayment: AppMethodCallTransactionArgument
      /**
       * is id of validator to pool to (must be owner or manager)
       */
      validatorId: bigint | number
      /**
       * is node number to add to
       */
      nodeNum: bigint | number
    }
    'addStake(pay,uint64,uint64)(uint64,uint64,uint64)': {
      /**
       * - payment coming from staker to place into a pool
       */
      stakedAmountPayment: AppMethodCallTransactionArgument
      /**
       * - The id of the validator.
       */
      validatorId: bigint | number
      /**
      * - only if validator has gating to enter - this is asset id or nfd id that corresponds to gating.
      Txn sender is factored in as well if that is part of gating.
      *

       */
      valueToVerify: bigint | number
    }
    'setTokenPayoutRatio(uint64)(uint64[24],uint64)': {
      /**
       * - validator id (and thus pool) calling us.  Verified so that sender MUST be pool 1 of this validator.
       */
      validatorId: bigint | number
    }
    'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void': {
      /**
       * - ValidatorPoolKey type
       */
      poolKey: ValidatorPoolKey
      /**
       * - amount this validator's total stake increased via rewards
       */
      algoToAdd: bigint | number
      /**
       * - amount this validator's total stake increased via rewards (that should be
       */
      rewardTokenAmountReserved: bigint | number
      /**
       * - the commission amount the validator was paid, if any
       */
      validatorCommission: bigint | number
      /**
      * - if the pool was in saturated state, the amount sent back to the fee sink.
      seen as 'accounted for/pending spent')

       */
      saturatedBurnToFeeSink: bigint | number
    }
    'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void': {
      /**
       * calling us from which stake was removed
       */
      poolKey: ValidatorPoolKey
      staker: string
      /**
       * - algo amount removed
       */
      amountRemoved: bigint | number
      /**
       * - if applicable, amount of token reward removed (by pool 1 caller) or TO remove and pay out (via pool 1 from different pool caller)
       */
      rewardRemoved: bigint | number
      stakerRemoved: boolean
    }
    'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)': {
      /**
       * - The id of the validator.
       */
      validatorId: bigint | number
      /**
       * - The address of the staker.
       */
      staker: string
      /**
       * - The amount to stake.
       */
      amountToStake: bigint | number
    }
    'movePoolToNode(uint64,uint64,uint64)void': {
      /**
       * - The id of the validator.
       */
      validatorId: bigint | number
      poolAppId: bigint | number
      nodeNum: bigint | number
    }
    'emptyTokenRewards(uint64,address)uint64': {
      /**
       * - The id of the validator.
       */
      validatorId: bigint | number
      /**
       * - the account to send the tokens to (must already be opted-in to the reward token)
       */
      receiver: string
    }
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'createApplication()void': []
    'initStakingContract(uint64)void': [approvalProgramSize: bigint | number]
    'loadStakingContractData(uint64,byte[])void': [offset: bigint | number, data: Uint8Array]
    'finalizeStakingContract()void': []
    'gas()void': []
    'getMbrAmounts()(uint64,uint64,uint64,uint64)': []
    'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': []
    'getNumValidators()uint64': []
    'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)': [validatorId: bigint | number]
    'getValidatorState(uint64)(uint16,uint64,uint64,uint64)': [validatorId: bigint | number]
    'getValidatorOwnerAndManager(uint64)(address,address)': [validatorId: bigint | number]
    'getPools(uint64)(uint64,uint16,uint64)[]': [validatorId: bigint | number]
    'getPoolAppId(uint64,uint64)uint64': [validatorId: bigint | number, poolId: bigint | number]
    'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)': [poolKey: ValidatorPoolKey]
    'getCurMaxStakePerPool(uint64)uint64': [validatorId: bigint | number]
    'doesStakerNeedToPayMBR(address)bool': [staker: string]
    'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]': [staker: string]
    'getTokenPayoutRatio(uint64)(uint64[24],uint64)': [validatorId: bigint | number]
    'getNodePoolAssignments(uint64)((uint64[3])[8])': [validatorId: bigint | number]
    'getNFDRegistryID()uint64': []
    'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64': [mbrPayment: AppMethodCallTransactionArgument, nfdName: string, config: ValidatorConfig]
    'changeValidatorManager(uint64,address)void': [validatorId: bigint | number, manager: string]
    'changeValidatorSunsetInfo(uint64,uint64,uint64)void': [validatorId: bigint | number, sunsettingOn: bigint | number, sunsettingTo: bigint | number]
    'changeValidatorNFD(uint64,uint64,string)void': [validatorId: bigint | number, nfdAppId: bigint | number, nfdName: string]
    'changeValidatorCommissionAddress(uint64,address)void': [validatorId: bigint | number, commissionAddress: string]
    'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void': [validatorId: bigint | number, entryGatingType: bigint | number, entryGatingAddress: string, entryGatingAssets: [bigint | number, bigint | number, bigint | number, bigint | number], gatingAssetMinBalance: bigint | number, rewardPerPayout: bigint | number]
    'addPool(pay,uint64,uint64)(uint64,uint64,uint64)': [mbrPayment: AppMethodCallTransactionArgument, validatorId: bigint | number, nodeNum: bigint | number]
    'addStake(pay,uint64,uint64)(uint64,uint64,uint64)': [stakedAmountPayment: AppMethodCallTransactionArgument, validatorId: bigint | number, valueToVerify: bigint | number]
    'setTokenPayoutRatio(uint64)(uint64[24],uint64)': [validatorId: bigint | number]
    'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void': [poolKey: ValidatorPoolKey, algoToAdd: bigint | number, rewardTokenAmountReserved: bigint | number, validatorCommission: bigint | number, saturatedBurnToFeeSink: bigint | number]
    'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void': [poolKey: ValidatorPoolKey, staker: string, amountRemoved: bigint | number, rewardRemoved: bigint | number, stakerRemoved: boolean]
    'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)': [validatorId: bigint | number, staker: string, amountToStake: bigint | number]
    'movePoolToNode(uint64,uint64,uint64)void': [validatorId: bigint | number, poolAppId: bigint | number, nodeNum: bigint | number]
    'emptyTokenRewards(uint64,address)uint64': [validatorId: bigint | number, receiver: string]
  }
}

/**
 * The return type for each method
 */
export type ValidatorRegistryReturns = {
  'createApplication()void': void
  'initStakingContract(uint64)void': void
  'loadStakingContractData(uint64,byte[])void': void
  'finalizeStakingContract()void': void
  'gas()void': void
  'getMbrAmounts()(uint64,uint64,uint64,uint64)': MbrAmounts
  'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)': Constraints
  'getNumValidators()uint64': bigint
  'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)': ValidatorConfig
  'getValidatorState(uint64)(uint16,uint64,uint64,uint64)': ValidatorCurState
  'getValidatorOwnerAndManager(uint64)(address,address)': [string, string]
  'getPools(uint64)(uint64,uint16,uint64)[]': [bigint, number, bigint][]
  'getPoolAppId(uint64,uint64)uint64': bigint
  'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)': PoolInfo
  'getCurMaxStakePerPool(uint64)uint64': bigint
  'doesStakerNeedToPayMBR(address)bool': boolean
  'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]': [bigint, bigint, bigint][]
  'getTokenPayoutRatio(uint64)(uint64[24],uint64)': PoolTokenPayoutRatio
  'getNodePoolAssignments(uint64)((uint64[3])[8])': NodePoolAssignmentConfig
  'getNFDRegistryID()uint64': bigint
  'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64': bigint
  'changeValidatorManager(uint64,address)void': void
  'changeValidatorSunsetInfo(uint64,uint64,uint64)void': void
  'changeValidatorNFD(uint64,uint64,string)void': void
  'changeValidatorCommissionAddress(uint64,address)void': void
  'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void': void
  'addPool(pay,uint64,uint64)(uint64,uint64,uint64)': ValidatorPoolKey
  'addStake(pay,uint64,uint64)(uint64,uint64,uint64)': ValidatorPoolKey
  'setTokenPayoutRatio(uint64)(uint64[24],uint64)': PoolTokenPayoutRatio
  'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void': void
  'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void': void
  'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)': [[bigint, bigint, bigint], boolean, boolean]
  'movePoolToNode(uint64,uint64,uint64)void': void
  'emptyTokenRewards(uint64,address)uint64': bigint
}

/**
 * Defines the types of available calls and state of the ValidatorRegistry smart contract.
 */
export type ValidatorRegistryTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication()void' | 'createApplication', {
      argsObj: ValidatorRegistryArgs['obj']['createApplication()void']
      argsTuple: ValidatorRegistryArgs['tuple']['createApplication()void']
      returns: ValidatorRegistryReturns['createApplication()void']
    }>
    & Record<'initStakingContract(uint64)void' | 'initStakingContract', {
      argsObj: ValidatorRegistryArgs['obj']['initStakingContract(uint64)void']
      argsTuple: ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']
      returns: ValidatorRegistryReturns['initStakingContract(uint64)void']
    }>
    & Record<'loadStakingContractData(uint64,byte[])void' | 'loadStakingContractData', {
      argsObj: ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void']
      argsTuple: ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']
      returns: ValidatorRegistryReturns['loadStakingContractData(uint64,byte[])void']
    }>
    & Record<'finalizeStakingContract()void' | 'finalizeStakingContract', {
      argsObj: ValidatorRegistryArgs['obj']['finalizeStakingContract()void']
      argsTuple: ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']
      returns: ValidatorRegistryReturns['finalizeStakingContract()void']
    }>
    & Record<'gas()void' | 'gas', {
      argsObj: ValidatorRegistryArgs['obj']['gas()void']
      argsTuple: ValidatorRegistryArgs['tuple']['gas()void']
      returns: ValidatorRegistryReturns['gas()void']
    }>
    & Record<'getMbrAmounts()(uint64,uint64,uint64,uint64)' | 'getMbrAmounts', {
      argsObj: ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']
      returns: ValidatorRegistryReturns['getMbrAmounts()(uint64,uint64,uint64,uint64)']
    }>
    & Record<'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)' | 'getProtocolConstraints', {
      argsObj: ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
      returns: ValidatorRegistryReturns['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
    }>
    & Record<'getNumValidators()uint64' | 'getNumValidators', {
      argsObj: ValidatorRegistryArgs['obj']['getNumValidators()uint64']
      argsTuple: ValidatorRegistryArgs['tuple']['getNumValidators()uint64']
      returns: ValidatorRegistryReturns['getNumValidators()uint64']
    }>
    & Record<'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)' | 'getValidatorConfig', {
      argsObj: ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
      returns: ValidatorRegistryReturns['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
    }>
    & Record<'getValidatorState(uint64)(uint16,uint64,uint64,uint64)' | 'getValidatorState', {
      argsObj: ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
      returns: ValidatorRegistryReturns['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
    }>
    & Record<'getValidatorOwnerAndManager(uint64)(address,address)' | 'getValidatorOwnerAndManager', {
      argsObj: ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)']
      argsTuple: ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']
      returns: ValidatorRegistryReturns['getValidatorOwnerAndManager(uint64)(address,address)']
    }>
    & Record<'getPools(uint64)(uint64,uint16,uint64)[]' | 'getPools', {
      argsObj: ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]']
      argsTuple: ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']
      /**
      * - array of pools
      Not callable from other contracts because >1K return but can be called w/ simulate which bumps log returns

       */
      returns: ValidatorRegistryReturns['getPools(uint64)(uint64,uint16,uint64)[]']
    }>
    & Record<'getPoolAppId(uint64,uint64)uint64' | 'getPoolAppId', {
      argsObj: ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64']
      argsTuple: ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']
      returns: ValidatorRegistryReturns['getPoolAppId(uint64,uint64)uint64']
    }>
    & Record<'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)' | 'getPoolInfo', {
      argsObj: ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
      returns: ValidatorRegistryReturns['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
    }>
    & Record<'getCurMaxStakePerPool(uint64)uint64' | 'getCurMaxStakePerPool', {
      argsObj: ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64']
      argsTuple: ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']
      returns: ValidatorRegistryReturns['getCurMaxStakePerPool(uint64)uint64']
    }>
    & Record<'doesStakerNeedToPayMBR(address)bool' | 'doesStakerNeedToPayMBR', {
      argsObj: ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool']
      argsTuple: ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']
      returns: ValidatorRegistryReturns['doesStakerNeedToPayMBR(address)bool']
    }>
    & Record<'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]' | 'getStakedPoolsForAccount', {
      argsObj: ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      argsTuple: ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
      /**
       * - The array of staked pools for the account.
       */
      returns: ValidatorRegistryReturns['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
    }>
    & Record<'getTokenPayoutRatio(uint64)(uint64[24],uint64)' | 'getTokenPayoutRatio', {
      argsObj: ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
      /**
       * - The token payout ratio for the validator.
       */
      returns: ValidatorRegistryReturns['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
    }>
    & Record<'getNodePoolAssignments(uint64)((uint64[3])[8])' | 'getNodePoolAssignments', {
      argsObj: ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])']
      argsTuple: ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']
      returns: ValidatorRegistryReturns['getNodePoolAssignments(uint64)((uint64[3])[8])']
    }>
    & Record<'getNFDRegistryID()uint64' | 'getNFDRegistryID', {
      argsObj: ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64']
      argsTuple: ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']
      returns: ValidatorRegistryReturns['getNFDRegistryID()uint64']
    }>
    & Record<'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64' | 'addValidator', {
      argsObj: ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
      argsTuple: ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
      /**
       * validator id
       */
      returns: ValidatorRegistryReturns['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']
    }>
    & Record<'changeValidatorManager(uint64,address)void' | 'changeValidatorManager', {
      argsObj: ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void']
      argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']
      returns: ValidatorRegistryReturns['changeValidatorManager(uint64,address)void']
    }>
    & Record<'changeValidatorSunsetInfo(uint64,uint64,uint64)void' | 'changeValidatorSunsetInfo', {
      argsObj: ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
      argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
      returns: ValidatorRegistryReturns['changeValidatorSunsetInfo(uint64,uint64,uint64)void']
    }>
    & Record<'changeValidatorNFD(uint64,uint64,string)void' | 'changeValidatorNFD', {
      argsObj: ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void']
      argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']
      returns: ValidatorRegistryReturns['changeValidatorNFD(uint64,uint64,string)void']
    }>
    & Record<'changeValidatorCommissionAddress(uint64,address)void' | 'changeValidatorCommissionAddress', {
      argsObj: ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void']
      argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']
      returns: ValidatorRegistryReturns['changeValidatorCommissionAddress(uint64,address)void']
    }>
    & Record<'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void' | 'changeValidatorRewardInfo', {
      argsObj: ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
      argsTuple: ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
      returns: ValidatorRegistryReturns['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']
    }>
    & Record<'addPool(pay,uint64,uint64)(uint64,uint64,uint64)' | 'addPool', {
      argsObj: ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
      /**
       * pool key to created pool
       */
      returns: ValidatorRegistryReturns['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']
    }>
    & Record<'addStake(pay,uint64,uint64)(uint64,uint64,uint64)' | 'addStake', {
      argsObj: ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
      /**
       * - The key of the validator pool.
       */
      returns: ValidatorRegistryReturns['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']
    }>
    & Record<'setTokenPayoutRatio(uint64)(uint64[24],uint64)' | 'setTokenPayoutRatio', {
      argsObj: ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
      argsTuple: ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
      /**
       * PoolTokenPayoutRatio - the finished ratio data
       */
      returns: ValidatorRegistryReturns['setTokenPayoutRatio(uint64)(uint64[24],uint64)']
    }>
    & Record<'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void' | 'stakeUpdatedViaRewards', {
      argsObj: ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
      argsTuple: ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
      returns: ValidatorRegistryReturns['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']
    }>
    & Record<'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void' | 'stakeRemoved', {
      argsObj: ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
      argsTuple: ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
      returns: ValidatorRegistryReturns['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']
    }>
    & Record<'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)' | 'findPoolForStaker', {
      argsObj: ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      argsTuple: ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
      /**
      * , boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'
      to this VALIDATOR, and true/false if staker is new to the protocol.

       */
      returns: ValidatorRegistryReturns['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
    }>
    & Record<'movePoolToNode(uint64,uint64,uint64)void' | 'movePoolToNode', {
      argsObj: ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void']
      argsTuple: ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']
      returns: ValidatorRegistryReturns['movePoolToNode(uint64,uint64,uint64)void']
    }>
    & Record<'emptyTokenRewards(uint64,address)uint64' | 'emptyTokenRewards', {
      argsObj: ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64']
      argsTuple: ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']
      /**
       * the amount of reward token sent
       */
      returns: ValidatorRegistryReturns['emptyTokenRewards(uint64,address)uint64']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        stakingPoolInitialized: bigint
        numValidators: bigint
        numStakers: bigint
        totalAlgoStaked: bigint
      }
      maps: {}
    }
    box: {
      keys: {
        stakingPoolApprovalProgram: BinaryState
      }
      maps: {
        validatorList: Map<bigint | number, ValidatorInfo>
        stakerPoolSet: Map<string, [[bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint]]>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type ValidatorRegistrySignatures = keyof ValidatorRegistryTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type ValidatorRegistryNonVoidMethodSignatures = keyof ValidatorRegistryTypes['methods'] extends infer T ? T extends keyof ValidatorRegistryTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the ValidatorRegistry smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends ValidatorRegistrySignatures> = ValidatorRegistryTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the ValidatorRegistry smart contract to the method's return type
 */
export type MethodReturn<TSignature extends ValidatorRegistrySignatures> = ValidatorRegistryTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = ValidatorRegistryTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = ValidatorRegistryTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type ValidatorRegistryCreateCallParams =
  | Expand<CallParams<ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']> & {method: 'createApplication'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
  | Expand<CallParams<ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']> & {method: 'createApplication()void'} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines arguments required for the deploy method.
 */
export type ValidatorRegistryDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: ValidatorRegistryCreateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the ValidatorRegistry smart contract
 */
export abstract class ValidatorRegistryParamsFactory {
  /**
   * Gets available create ABI call param factories
   */
  static get create() {
    return {
      _resolveByMethod<TParams extends ValidatorRegistryCreateCallParams & {method: string}>(params: TParams) {
        switch(params.method) {
          case 'createApplication':
          case 'createApplication()void':
            return ValidatorRegistryParamsFactory.create.createApplication(params)
        }
        throw new Error(`Unknown ' + verb + ' method`)
      },

      /**
       * Constructs create ABI call params for the ValidatorRegistry smart contract using the createApplication()void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      createApplication(params: CallParams<ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']> & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC}): AppClientMethodCallParams & AppClientCompilationParams & {onComplete?: OnApplicationComplete.NoOpOC} {
        return {
          ...params,
          method: 'createApplication()void' as const,
          args: Array.isArray(params.args) ? params.args : [],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the initStakingContract(uint64)void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static initStakingContract(params: CallParams<ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'initStakingContract(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.approvalProgramSize],
    }
  }
  /**
   * Constructs a no op call for the loadStakingContractData(uint64,byte[])void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static loadStakingContractData(params: CallParams<ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void'] | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'loadStakingContractData(uint64,byte[])void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.offset, params.args.data],
    }
  }
  /**
   * Constructs a no op call for the finalizeStakingContract()void ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static finalizeStakingContract(params: CallParams<ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'finalizeStakingContract()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the gas()void ABI method
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static gas(params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'gas()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the getMbrAmounts()(uint64,uint64,uint64,uint64) ABI method
   *
  * Returns the MBR amounts needed for various actions:
  [
  addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
  addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
  poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
  addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
  ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getMbrAmounts(params: CallParams<ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getMbrAmounts()(uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method
   *
   * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getProtocolConstraints(params: CallParams<ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the getNumValidators()uint64 ABI method
   *
   * Returns the current number of validators
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getNumValidators(params: CallParams<ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getNumValidators()uint64' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getValidatorConfig(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getValidatorState(uint64)(uint16,uint64,uint64,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getValidatorState(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getValidatorState(uint64)(uint16,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getValidatorOwnerAndManager(uint64)(address,address) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getValidatorOwnerAndManager(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)'] | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getValidatorOwnerAndManager(uint64)(address,address)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getPools(uint64)(uint64,uint16,uint64)[] ABI method
   *
   * Return list of all pools for this validator.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getPools(params: CallParams<ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]'] | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getPools(uint64)(uint64,uint16,uint64)[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getPoolAppId(uint64,uint64)uint64 ABI method
   *
  * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
  want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
  (which contains reward tokens if being used) so that the amount available can be determined.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getPoolAppId(params: CallParams<ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64'] | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getPoolAppId(uint64,uint64)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.poolId],
    }
  }
  /**
   * Constructs a no op call for the getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getPoolInfo(params: CallParams<ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolKey],
    }
  }
  /**
   * Constructs a no op call for the getCurMaxStakePerPool(uint64)uint64 ABI method
   *
  * Calculate the maximum stake per pool for a given validator.
  Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
  as pools are added the max allowed per pool can reduce.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getCurMaxStakePerPool(params: CallParams<ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64'] | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getCurMaxStakePerPool(uint64)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the doesStakerNeedToPayMBR(address)bool ABI method
   *
   * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static doesStakerNeedToPayMbr(params: CallParams<ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool'] | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'doesStakerNeedToPayMBR(address)bool' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.staker],
    }
  }
  /**
   * Constructs a no op call for the getStakedPoolsForAccount(address)(uint64,uint64,uint64)[] ABI method
   *
   * Retrieves the staked pools for an account.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getStakedPoolsForAccount(params: CallParams<ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.staker],
    }
  }
  /**
   * Constructs a no op call for the getTokenPayoutRatio(uint64)(uint64[24],uint64) ABI method
   *
  * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
  payouts across pools can be based on a stable snaphost of stake.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getTokenPayoutRatio(params: CallParams<ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getTokenPayoutRatio(uint64)(uint64[24],uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getNodePoolAssignments(uint64)((uint64[3])[8]) ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getNodePoolAssignments(params: CallParams<ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])'] | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getNodePoolAssignments(uint64)((uint64[3])[8])' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the getNFDRegistryID()uint64 ABI method
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getNfdRegistryId(params: CallParams<ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'getNFDRegistryID()uint64' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64 ABI method
   *
  * Adds a new validator
  Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addValidator(params: CallParams<ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'] | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.mbrPayment, params.args.nfdName, params.args.config],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorManager(uint64,address)void ABI method
   *
  * Changes the Validator manager for a specific Validator id.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorManager(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorManager(uint64,address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.manager],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorSunsetInfo(uint64,uint64,uint64)void ABI method
   *
  * Updates the sunset information for a given validator.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorSunsetInfo(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorSunsetInfo(uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.sunsettingOn, params.args.sunsettingTo],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorNFD(uint64,uint64,string)void ABI method
   *
  * Changes the NFD for a validator in the validatorList contract.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorNfd(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void'] | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorNFD(uint64,uint64,string)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.nfdAppId, params.args.nfdName],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorCommissionAddress(uint64,address)void ABI method
   *
  * Change the commission address that validator rewards are sent to.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorCommissionAddress(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorCommissionAddress(uint64,address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.commissionAddress],
    }
  }
  /**
   * Constructs a no op call for the changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void ABI method
   *
  * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static changeValidatorRewardInfo(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.entryGatingType, params.args.entryGatingAddress, params.args.entryGatingAssets, params.args.gatingAssetMinBalance, params.args.rewardPerPayout],
    }
  }
  /**
   * Constructs a no op call for the addPool(pay,uint64,uint64)(uint64,uint64,uint64) ABI method
   *
  * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
  The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
  
  [ ONLY OWNER OR MANAGER CAN call ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addPool(params: CallParams<ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addPool(pay,uint64,uint64)(uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.mbrPayment, params.args.validatorId, params.args.nodeNum],
    }
  }
  /**
   * Constructs a no op call for the addStake(pay,uint64,uint64)(uint64,uint64,uint64) ABI method
   *
   * Adds stake to a validator pool.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static addStake(params: CallParams<ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'addStake(pay,uint64,uint64)(uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.stakedAmountPayment, params.args.validatorId, params.args.valueToVerify],
    }
  }
  /**
   * Constructs a no op call for the setTokenPayoutRatio(uint64)(uint64[24],uint64) ABI method
   *
  * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
  of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
  in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
  pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
  It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
  their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
  during the epoch updates across pools)
  
  Multiple pools will call us via pool 1 (pool2->pool1->validator, etc.) so don't assert on pool1 calling multiple
  times in same epoch.  Just return.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setTokenPayoutRatio(params: CallParams<ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'setTokenPayoutRatio(uint64)(uint64[24],uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId],
    }
  }
  /**
   * Constructs a no op call for the stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void ABI method
   *
  * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
  stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
  The calling App id is validated against our pool list as well.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stakeUpdatedViaRewards(params: CallParams<ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolKey, params.args.algoToAdd, params.args.rewardTokenAmountReserved, params.args.validatorCommission, params.args.saturatedBurnToFeeSink],
    }
  }
  /**
   * Constructs a no op call for the stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void ABI method
   *
  * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
  from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
  If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
  The calling App id is validated against our pool list as well.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static stakeRemoved(params: CallParams<ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'] | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.poolKey, params.args.staker, params.args.amountRemoved, params.args.rewardRemoved, params.args.stakerRemoved],
    }
  }
  /**
   * Constructs a no op call for the findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool) ABI method
   *
  * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
  First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
  to new pool if necessary.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static findPoolForStaker(params: CallParams<ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.staker, params.args.amountToStake],
    }
  }
  /**
   * Constructs a no op call for the movePoolToNode(uint64,uint64,uint64)void ABI method
   *
  * Find the specified pool (in any node number) and move it to the specified node.
  The pool account is forced offline if moved so prior node will still run for 320 rounds but
  new key goes online on new node soon after (320 rounds after it goes online)
  No-op if success, asserts if not found or can't move  (no space in target)
  [ ONLY OWNER OR MANAGER CAN CHANGE ]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static movePoolToNode(params: CallParams<ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'movePoolToNode(uint64,uint64,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.poolAppId, params.args.nodeNum],
    }
  }
  /**
   * Constructs a no op call for the emptyTokenRewards(uint64,address)uint64 ABI method
   *
  * Sends the reward tokens held in pool 1 to specified receiver.
  This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
  the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
  NOT be sent as they must be held back for stakers to later claim.
  [ ONLY OWNER CAN CALL]

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static emptyTokenRewards(params: CallParams<ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64'] | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'emptyTokenRewards(uint64,address)uint64' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.validatorId, params.args.receiver],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the ValidatorRegistry smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class ValidatorRegistryFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `ValidatorRegistryFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new ValidatorRegistryClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new ValidatorRegistryClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the ValidatorRegistry smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: ValidatorRegistryDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
      createParams: params.createParams?.method ? ValidatorRegistryParamsFactory.create._resolveByMethod(params.createParams) : params.createParams ? params.createParams as (ValidatorRegistryCreateCallParams & { args: Uint8Array[] }) : undefined,
    })
    return { result: result.result, appClient: new ValidatorRegistryClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ValidatorRegistry smart contract using the createApplication()void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create params
       */
      createApplication: (params: CallParams<ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
        return this.appFactory.params.create(ValidatorRegistryParamsFactory.create.createApplication(params))
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ValidatorRegistry smart contract using the createApplication()void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create transaction
       */
      createApplication: (params: CallParams<ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']> & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
        return this.appFactory.createTransaction.create(ValidatorRegistryParamsFactory.create.createApplication(params))
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the ValidatorRegistry smart contract using an ABI method call using the createApplication()void ABI method.
       *
       * @param params The params for the smart contract call
       * @returns The create result
       */
      createApplication: async (params: CallParams<ValidatorRegistryArgs['obj']['createApplication()void'] | ValidatorRegistryArgs['tuple']['createApplication()void']> & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
        const result = await this.appFactory.send.create(ValidatorRegistryParamsFactory.create.createApplication(params))
        return { result: { ...result.result, return: result.result.return as unknown as (undefined | ValidatorRegistryReturns['createApplication()void']) }, appClient: new ValidatorRegistryClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the ValidatorRegistry smart contract
 */
export class ValidatorRegistryClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `ValidatorRegistryClient`
   *
   * @param appClient An `AppClient` instance which has been created with the ValidatorRegistry app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `ValidatorRegistryClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends ValidatorRegistryNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `ValidatorRegistryClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<ValidatorRegistryClient> {
    return new ValidatorRegistryClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `ValidatorRegistryClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<ValidatorRegistryClient> {
    return new ValidatorRegistryClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `initStakingContract(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    initStakingContract: (params: CallParams<ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.initStakingContract(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `loadStakingContractData(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    loadStakingContractData: (params: CallParams<ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void'] | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.loadStakingContractData(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `finalizeStakingContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    finalizeStakingContract: (params: CallParams<ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.finalizeStakingContract(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `gas()void` ABI method.
     *
     * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    gas: (params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.gas(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getMbrAmounts()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the MBR amounts needed for various actions:
    [
    addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
    addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
    poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
    addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
    ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getMbrAmounts: (params: CallParams<ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getMbrAmounts(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getProtocolConstraints: (params: CallParams<ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getProtocolConstraints(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNumValidators()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current number of validators
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getNumValidators: (params: CallParams<ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getNumValidators(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getValidatorConfig: (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getValidatorConfig(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorState(uint64)(uint16,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getValidatorState: (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getValidatorState(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorOwnerAndManager(uint64)(address,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getValidatorOwnerAndManager: (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)'] | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getValidatorOwnerAndManager(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPools(uint64)(uint64,uint16,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Return list of all pools for this validator.
     *
     * @param params The params for the smart contract call
    * @returns The call params: - array of pools
    Not callable from other contracts because >1K return but can be called w/ simulate which bumps log returns

     */
    getPools: (params: CallParams<ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]'] | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getPools(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolAppId(uint64,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
    want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
    (which contains reward tokens if being used) so that the amount available can be determined.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getPoolAppId: (params: CallParams<ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64'] | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getPoolAppId(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getPoolInfo: (params: CallParams<ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getPoolInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getCurMaxStakePerPool(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate the maximum stake per pool for a given validator.
    Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
    as pools are added the max allowed per pool can reduce.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getCurMaxStakePerPool: (params: CallParams<ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64'] | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getCurMaxStakePerPool(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `doesStakerNeedToPayMBR(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    doesStakerNeedToPayMbr: (params: CallParams<ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool'] | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.doesStakerNeedToPayMbr(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the staked pools for an account.
     *
     * @param params The params for the smart contract call
     * @returns The call params: - The array of staked pools for the account.
     */
    getStakedPoolsForAccount: (params: CallParams<ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getStakedPoolsForAccount(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
    payouts across pools can be based on a stable snaphost of stake.

     *
     * @param params The params for the smart contract call
     * @returns The call params: - The token payout ratio for the validator.
     */
    getTokenPayoutRatio: (params: CallParams<ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getTokenPayoutRatio(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNodePoolAssignments(uint64)((uint64[3])[8])` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getNodePoolAssignments: (params: CallParams<ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])'] | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getNodePoolAssignments(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNFDRegistryID()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    getNfdRegistryId: (params: CallParams<ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.getNfdRegistryId(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64` ABI method.
     *
    * Adds a new validator
    Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

     *
     * @param params The params for the smart contract call
     * @returns The call params: validator id
     */
    addValidator: (params: CallParams<ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'] | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.addValidator(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorManager(uint64,address)void` ABI method.
     *
    * Changes the Validator manager for a specific Validator id.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorManager: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorManager(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorSunsetInfo(uint64,uint64,uint64)void` ABI method.
     *
    * Updates the sunset information for a given validator.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorSunsetInfo: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorSunsetInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorNFD(uint64,uint64,string)void` ABI method.
     *
    * Changes the NFD for a validator in the validatorList contract.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorNfd: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void'] | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorNfd(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorCommissionAddress(uint64,address)void` ABI method.
     *
    * Change the commission address that validator rewards are sent to.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorCommissionAddress: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorCommissionAddress(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void` ABI method.
     *
    * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    changeValidatorRewardInfo: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.changeValidatorRewardInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addPool(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
    * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
    The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
    
    [ ONLY OWNER OR MANAGER CAN call ]

     *
     * @param params The params for the smart contract call
     * @returns The call params: pool key to created pool
     */
    addPool: (params: CallParams<ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.addPool(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addStake(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
     * Adds stake to a validator pool.
     *
     * @param params The params for the smart contract call
     * @returns The call params: - The key of the validator pool.
     */
    addStake: (params: CallParams<ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.addStake(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `setTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     *
    * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
    of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
    in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
    pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
    It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
    their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
    during the epoch updates across pools)
    
    Multiple pools will call us via pool 1 (pool2->pool1->validator, etc.) so don't assert on pool1 calling multiple
    times in same epoch.  Just return.

     *
     * @param params The params for the smart contract call
     * @returns The call params: PoolTokenPayoutRatio - the finished ratio data
     */
    setTokenPayoutRatio: (params: CallParams<ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.setTokenPayoutRatio(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void` ABI method.
     *
    * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
    stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stakeUpdatedViaRewards: (params: CallParams<ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.stakeUpdatedViaRewards(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void` ABI method.
     *
    * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
    from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    stakeRemoved: (params: CallParams<ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'] | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.stakeRemoved(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
    First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
    to new pool if necessary.

     *
     * @param params The params for the smart contract call
    * @returns The call params: , boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'
    to this VALIDATOR, and true/false if staker is new to the protocol.

     */
    findPoolForStaker: (params: CallParams<ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.findPoolForStaker(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `movePoolToNode(uint64,uint64,uint64)void` ABI method.
     *
    * Find the specified pool (in any node number) and move it to the specified node.
    The pool account is forced offline if moved so prior node will still run for 320 rounds but
    new key goes online on new node soon after (320 rounds after it goes online)
    No-op if success, asserts if not found or can't move  (no space in target)
    [ ONLY OWNER OR MANAGER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    movePoolToNode: (params: CallParams<ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.movePoolToNode(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `emptyTokenRewards(uint64,address)uint64` ABI method.
     *
    * Sends the reward tokens held in pool 1 to specified receiver.
    This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
    the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
    NOT be sent as they must be held back for stakers to later claim.
    [ ONLY OWNER CAN CALL]

     *
     * @param params The params for the smart contract call
     * @returns The call params: the amount of reward token sent
     */
    emptyTokenRewards: (params: CallParams<ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64'] | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(ValidatorRegistryParamsFactory.emptyTokenRewards(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `initStakingContract(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    initStakingContract: (params: CallParams<ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.initStakingContract(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `loadStakingContractData(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    loadStakingContractData: (params: CallParams<ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void'] | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.loadStakingContractData(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `finalizeStakingContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    finalizeStakingContract: (params: CallParams<ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.finalizeStakingContract(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `gas()void` ABI method.
     *
     * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    gas: (params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.gas(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getMbrAmounts()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the MBR amounts needed for various actions:
    [
    addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
    addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
    poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
    addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
    ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getMbrAmounts: (params: CallParams<ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getMbrAmounts(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getProtocolConstraints: (params: CallParams<ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getProtocolConstraints(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNumValidators()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current number of validators
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getNumValidators: (params: CallParams<ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getNumValidators(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getValidatorConfig: (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getValidatorConfig(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorState(uint64)(uint16,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getValidatorState: (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getValidatorState(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorOwnerAndManager(uint64)(address,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getValidatorOwnerAndManager: (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)'] | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getValidatorOwnerAndManager(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPools(uint64)(uint64,uint16,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Return list of all pools for this validator.
     *
     * @param params The params for the smart contract call
    * @returns The call transaction: - array of pools
    Not callable from other contracts because >1K return but can be called w/ simulate which bumps log returns

     */
    getPools: (params: CallParams<ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]'] | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getPools(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolAppId(uint64,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
    want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
    (which contains reward tokens if being used) so that the amount available can be determined.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getPoolAppId: (params: CallParams<ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64'] | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getPoolAppId(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getPoolInfo: (params: CallParams<ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getPoolInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getCurMaxStakePerPool(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate the maximum stake per pool for a given validator.
    Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
    as pools are added the max allowed per pool can reduce.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getCurMaxStakePerPool: (params: CallParams<ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64'] | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getCurMaxStakePerPool(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `doesStakerNeedToPayMBR(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    doesStakerNeedToPayMbr: (params: CallParams<ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool'] | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.doesStakerNeedToPayMbr(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the staked pools for an account.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: - The array of staked pools for the account.
     */
    getStakedPoolsForAccount: (params: CallParams<ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getStakedPoolsForAccount(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
    payouts across pools can be based on a stable snaphost of stake.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: - The token payout ratio for the validator.
     */
    getTokenPayoutRatio: (params: CallParams<ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getTokenPayoutRatio(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNodePoolAssignments(uint64)((uint64[3])[8])` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getNodePoolAssignments: (params: CallParams<ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])'] | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getNodePoolAssignments(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNFDRegistryID()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    getNfdRegistryId: (params: CallParams<ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.getNfdRegistryId(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64` ABI method.
     *
    * Adds a new validator
    Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: validator id
     */
    addValidator: (params: CallParams<ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'] | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.addValidator(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorManager(uint64,address)void` ABI method.
     *
    * Changes the Validator manager for a specific Validator id.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorManager: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorManager(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorSunsetInfo(uint64,uint64,uint64)void` ABI method.
     *
    * Updates the sunset information for a given validator.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorSunsetInfo: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorSunsetInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorNFD(uint64,uint64,string)void` ABI method.
     *
    * Changes the NFD for a validator in the validatorList contract.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorNfd: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void'] | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorNfd(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorCommissionAddress(uint64,address)void` ABI method.
     *
    * Change the commission address that validator rewards are sent to.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorCommissionAddress: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorCommissionAddress(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void` ABI method.
     *
    * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    changeValidatorRewardInfo: (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.changeValidatorRewardInfo(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addPool(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
    * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
    The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
    
    [ ONLY OWNER OR MANAGER CAN call ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: pool key to created pool
     */
    addPool: (params: CallParams<ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.addPool(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addStake(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
     * Adds stake to a validator pool.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: - The key of the validator pool.
     */
    addStake: (params: CallParams<ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.addStake(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `setTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     *
    * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
    of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
    in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
    pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
    It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
    their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
    during the epoch updates across pools)
    
    Multiple pools will call us via pool 1 (pool2->pool1->validator, etc.) so don't assert on pool1 calling multiple
    times in same epoch.  Just return.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: PoolTokenPayoutRatio - the finished ratio data
     */
    setTokenPayoutRatio: (params: CallParams<ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.setTokenPayoutRatio(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void` ABI method.
     *
    * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
    stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stakeUpdatedViaRewards: (params: CallParams<ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.stakeUpdatedViaRewards(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void` ABI method.
     *
    * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
    from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    stakeRemoved: (params: CallParams<ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'] | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.stakeRemoved(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
    First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
    to new pool if necessary.

     *
     * @param params The params for the smart contract call
    * @returns The call transaction: , boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'
    to this VALIDATOR, and true/false if staker is new to the protocol.

     */
    findPoolForStaker: (params: CallParams<ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.findPoolForStaker(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `movePoolToNode(uint64,uint64,uint64)void` ABI method.
     *
    * Find the specified pool (in any node number) and move it to the specified node.
    The pool account is forced offline if moved so prior node will still run for 320 rounds but
    new key goes online on new node soon after (320 rounds after it goes online)
    No-op if success, asserts if not found or can't move  (no space in target)
    [ ONLY OWNER OR MANAGER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    movePoolToNode: (params: CallParams<ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.movePoolToNode(params))
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `emptyTokenRewards(uint64,address)uint64` ABI method.
     *
    * Sends the reward tokens held in pool 1 to specified receiver.
    This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
    the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
    NOT be sent as they must be held back for stakers to later claim.
    [ ONLY OWNER CAN CALL]

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: the amount of reward token sent
     */
    emptyTokenRewards: (params: CallParams<ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64'] | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(ValidatorRegistryParamsFactory.emptyTokenRewards(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `initStakingContract(uint64)void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    initStakingContract: async (params: CallParams<ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.initStakingContract(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['initStakingContract(uint64)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `loadStakingContractData(uint64,byte[])void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    loadStakingContractData: async (params: CallParams<ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void'] | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.loadStakingContractData(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['loadStakingContractData(uint64,byte[])void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `finalizeStakingContract()void` ABI method.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    finalizeStakingContract: async (params: CallParams<ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.finalizeStakingContract(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['finalizeStakingContract()void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `gas()void` ABI method.
     *
     * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    gas: async (params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.gas(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['gas()void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getMbrAmounts()(uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Returns the MBR amounts needed for various actions:
    [
    addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
    addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
    poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
    addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
    ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getMbrAmounts: async (params: CallParams<ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getMbrAmounts(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getMbrAmounts()(uint64,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getProtocolConstraints: async (params: CallParams<ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getProtocolConstraints(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNumValidators()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Returns the current number of validators
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getNumValidators: async (params: CallParams<ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNumValidators(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getNumValidators()uint64'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getValidatorConfig: async (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorConfig(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorState(uint64)(uint16,uint64,uint64,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getValidatorState: async (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorState(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getValidatorOwnerAndManager(uint64)(address,address)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getValidatorOwnerAndManager: async (params: CallParams<ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)'] | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorOwnerAndManager(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getValidatorOwnerAndManager(uint64)(address,address)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPools(uint64)(uint64,uint16,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Return list of all pools for this validator.
     *
     * @param params The params for the smart contract call
    * @returns The call result: - array of pools
    Not callable from other contracts because >1K return but can be called w/ simulate which bumps log returns

     */
    getPools: async (params: CallParams<ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]'] | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPools(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getPools(uint64)(uint64,uint16,uint64)[]'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolAppId(uint64,uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
    want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
    (which contains reward tokens if being used) so that the amount available can be determined.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getPoolAppId: async (params: CallParams<ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64'] | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPoolAppId(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getPoolAppId(uint64,uint64)uint64'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getPoolInfo: async (params: CallParams<ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPoolInfo(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getCurMaxStakePerPool(uint64)uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Calculate the maximum stake per pool for a given validator.
    Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
    as pools are added the max allowed per pool can reduce.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getCurMaxStakePerPool: async (params: CallParams<ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64'] | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getCurMaxStakePerPool(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getCurMaxStakePerPool(uint64)uint64'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `doesStakerNeedToPayMBR(address)bool` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    doesStakerNeedToPayMbr: async (params: CallParams<ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool'] | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.doesStakerNeedToPayMbr(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['doesStakerNeedToPayMBR(address)bool'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Retrieves the staked pools for an account.
     *
     * @param params The params for the smart contract call
     * @returns The call result: - The array of staked pools for the account.
     */
    getStakedPoolsForAccount: async (params: CallParams<ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getStakedPoolsForAccount(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
    payouts across pools can be based on a stable snaphost of stake.

     *
     * @param params The params for the smart contract call
     * @returns The call result: - The token payout ratio for the validator.
     */
    getTokenPayoutRatio: async (params: CallParams<ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getTokenPayoutRatio(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getTokenPayoutRatio(uint64)(uint64[24],uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNodePoolAssignments(uint64)((uint64[3])[8])` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getNodePoolAssignments: async (params: CallParams<ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])'] | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNodePoolAssignments(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getNodePoolAssignments(uint64)((uint64[3])[8])'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `getNFDRegistryID()uint64` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    getNfdRegistryId: async (params: CallParams<ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNfdRegistryId(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['getNFDRegistryID()uint64'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64` ABI method.
     *
    * Adds a new validator
    Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

     *
     * @param params The params for the smart contract call
     * @returns The call result: validator id
     */
    addValidator: async (params: CallParams<ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'] | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.addValidator(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorManager(uint64,address)void` ABI method.
     *
    * Changes the Validator manager for a specific Validator id.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorManager: async (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorManager(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['changeValidatorManager(uint64,address)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorSunsetInfo(uint64,uint64,uint64)void` ABI method.
     *
    * Updates the sunset information for a given validator.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorSunsetInfo: async (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorSunsetInfo(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['changeValidatorSunsetInfo(uint64,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorNFD(uint64,uint64,string)void` ABI method.
     *
    * Changes the NFD for a validator in the validatorList contract.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorNfd: async (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void'] | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorNfd(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['changeValidatorNFD(uint64,uint64,string)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorCommissionAddress(uint64,address)void` ABI method.
     *
    * Change the commission address that validator rewards are sent to.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorCommissionAddress: async (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorCommissionAddress(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['changeValidatorCommissionAddress(uint64,address)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void` ABI method.
     *
    * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
    [ ONLY OWNER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    changeValidatorRewardInfo: async (params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.changeValidatorRewardInfo(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addPool(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
    * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
    The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
    
    [ ONLY OWNER OR MANAGER CAN call ]

     *
     * @param params The params for the smart contract call
     * @returns The call result: pool key to created pool
     */
    addPool: async (params: CallParams<ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.addPool(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `addStake(pay,uint64,uint64)(uint64,uint64,uint64)` ABI method.
     *
     * Adds stake to a validator pool.
     *
     * @param params The params for the smart contract call
     * @returns The call result: - The key of the validator pool.
     */
    addStake: async (params: CallParams<ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.addStake(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `setTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
     *
    * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
    of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
    in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
    pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
    It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
    their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
    during the epoch updates across pools)
    
    Multiple pools will call us via pool 1 (pool2->pool1->validator, etc.) so don't assert on pool1 calling multiple
    times in same epoch.  Just return.

     *
     * @param params The params for the smart contract call
     * @returns The call result: PoolTokenPayoutRatio - the finished ratio data
     */
    setTokenPayoutRatio: async (params: CallParams<ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.setTokenPayoutRatio(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['setTokenPayoutRatio(uint64)(uint64[24],uint64)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void` ABI method.
     *
    * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
    stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stakeUpdatedViaRewards: async (params: CallParams<ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.stakeUpdatedViaRewards(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void` ABI method.
     *
    * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
    from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
    If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
    The calling App id is validated against our pool list as well.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    stakeRemoved: async (params: CallParams<ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'] | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.stakeRemoved(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)` ABI method.
     * 
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
    * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
    First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
    to new pool if necessary.

     *
     * @param params The params for the smart contract call
    * @returns The call result: , boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'
    to this VALIDATOR, and true/false if staker is new to the protocol.

     */
    findPoolForStaker: async (params: CallParams<ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.findPoolForStaker(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `movePoolToNode(uint64,uint64,uint64)void` ABI method.
     *
    * Find the specified pool (in any node number) and move it to the specified node.
    The pool account is forced offline if moved so prior node will still run for 320 rounds but
    new key goes online on new node soon after (320 rounds after it goes online)
    No-op if success, asserts if not found or can't move  (no space in target)
    [ ONLY OWNER OR MANAGER CAN CHANGE ]

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    movePoolToNode: async (params: CallParams<ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.movePoolToNode(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['movePoolToNode(uint64,uint64,uint64)void'])}
    },

    /**
     * Makes a call to the ValidatorRegistry smart contract using the `emptyTokenRewards(uint64,address)uint64` ABI method.
     *
    * Sends the reward tokens held in pool 1 to specified receiver.
    This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
    the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
    NOT be sent as they must be held back for stakers to later claim.
    [ ONLY OWNER CAN CALL]

     *
     * @param params The params for the smart contract call
     * @returns The call result: the amount of reward token sent
     */
    emptyTokenRewards: async (params: CallParams<ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64'] | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.emptyTokenRewards(params))
      return {...result, return: result.return as unknown as (undefined | ValidatorRegistryReturns['emptyTokenRewards(uint64,address)uint64'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new ValidatorRegistryClient(this.appClient.clone(params))
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getMbrAmounts()(uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Returns the MBR amounts needed for various actions:
  [
  addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
  addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
  poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
  addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
  ]

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getMbrAmounts(params: CallParams<ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']> = {args: []}) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getMbrAmounts(params))
    return result.return as unknown as ValidatorRegistryReturns['getMbrAmounts()(uint64,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getProtocolConstraints(params: CallParams<ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> = {args: []}) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getProtocolConstraints(params))
    return result.return as unknown as ValidatorRegistryReturns['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getNumValidators()uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Returns the current number of validators
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getNumValidators(params: CallParams<ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']> = {args: []}) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNumValidators(params))
    return result.return as unknown as ValidatorRegistryReturns['getNumValidators()uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getValidatorConfig(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorConfig(params))
    return result.return as unknown as ValidatorRegistryReturns['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getValidatorState(uint64)(uint16,uint64,uint64,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getValidatorState(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorState(params))
    return result.return as unknown as ValidatorRegistryReturns['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getValidatorOwnerAndManager(uint64)(address,address)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getValidatorOwnerAndManager(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)'] | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getValidatorOwnerAndManager(params))
    return result.return as unknown as ValidatorRegistryReturns['getValidatorOwnerAndManager(uint64)(address,address)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getPools(uint64)(uint64,uint16,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Return list of all pools for this validator.
   *
   * @param params The params for the smart contract call
  * @returns The call result: - array of pools
  Not callable from other contracts because >1K return but can be called w/ simulate which bumps log returns

   */
  async getPools(params: CallParams<ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]'] | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPools(params))
    return result.return as unknown as ValidatorRegistryReturns['getPools(uint64)(uint64,uint16,uint64)[]']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getPoolAppId(uint64,uint64)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
  want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
  (which contains reward tokens if being used) so that the amount available can be determined.

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getPoolAppId(params: CallParams<ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64'] | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPoolAppId(params))
    return result.return as unknown as ValidatorRegistryReturns['getPoolAppId(uint64,uint64)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getPoolInfo(params: CallParams<ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getPoolInfo(params))
    return result.return as unknown as ValidatorRegistryReturns['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getCurMaxStakePerPool(uint64)uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Calculate the maximum stake per pool for a given validator.
  Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
  as pools are added the max allowed per pool can reduce.

   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getCurMaxStakePerPool(params: CallParams<ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64'] | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getCurMaxStakePerPool(params))
    return result.return as unknown as ValidatorRegistryReturns['getCurMaxStakePerPool(uint64)uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `doesStakerNeedToPayMBR(address)bool` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async doesStakerNeedToPayMbr(params: CallParams<ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool'] | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.doesStakerNeedToPayMbr(params))
    return result.return as unknown as ValidatorRegistryReturns['doesStakerNeedToPayMBR(address)bool']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * Retrieves the staked pools for an account.
   *
   * @param params The params for the smart contract call
   * @returns The call result: - The array of staked pools for the account.
   */
  async getStakedPoolsForAccount(params: CallParams<ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getStakedPoolsForAccount(params))
    return result.return as unknown as ValidatorRegistryReturns['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getTokenPayoutRatio(uint64)(uint64[24],uint64)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
  payouts across pools can be based on a stable snaphost of stake.

   *
   * @param params The params for the smart contract call
   * @returns The call result: - The token payout ratio for the validator.
   */
  async getTokenPayoutRatio(params: CallParams<ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getTokenPayoutRatio(params))
    return result.return as unknown as ValidatorRegistryReturns['getTokenPayoutRatio(uint64)(uint64[24],uint64)']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getNodePoolAssignments(uint64)((uint64[3])[8])` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getNodePoolAssignments(params: CallParams<ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])'] | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNodePoolAssignments(params))
    return result.return as unknown as ValidatorRegistryReturns['getNodePoolAssignments(uint64)((uint64[3])[8])']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `getNFDRegistryID()uint64` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
   * @param params The params for the smart contract call
   * @returns The call result
   */
  async getNfdRegistryId(params: CallParams<ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']> = {args: []}) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.getNfdRegistryId(params))
    return result.return as unknown as ValidatorRegistryReturns['getNFDRegistryID()uint64']
  }

  /**
   * Makes a readonly (simulated) call to the ValidatorRegistry smart contract using the `findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)` ABI method.
   * 
   * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
   *
  * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
  First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
  to new pool if necessary.

   *
   * @param params The params for the smart contract call
  * @returns The call result: , boolean, boolean} - The pool for the staker, true/false on whether the staker is 'new'
  to this VALIDATOR, and true/false if staker is new to the protocol.

   */
  async findPoolForStaker(params: CallParams<ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']>) {
    const result = await this.appClient.send.call(ValidatorRegistryParamsFactory.findPoolForStaker(params))
    return result.return as unknown as ValidatorRegistryReturns['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']
  }

  /**
   * Methods to access state for the current ValidatorRegistry app
   */
  state = {
    /**
     * Methods to access global state for the current ValidatorRegistry app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          stakingPoolInitialized: result.stakingPoolInitialized,
          numValidators: result.numValidators,
          numStakers: result.numStakers,
          totalAlgoStaked: result.totalAlgoStaked,
        }
      },
      /**
       * Get the current value of the stakingPoolInitialized key in global state
       */
      stakingPoolInitialized: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("stakingPoolInitialized")) as bigint | undefined },
      /**
       * Get the current value of the numValidators key in global state
       */
      numValidators: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("numValidators")) as bigint | undefined },
      /**
       * Get the current value of the numStakers key in global state
       */
      numStakers: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("numStakers")) as bigint | undefined },
      /**
       * Get the current value of the totalAlgoStaked key in global state
       */
      totalAlgoStaked: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("totalAlgoStaked")) as bigint | undefined },
    },
    /**
     * Methods to access box state for the current ValidatorRegistry app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
          stakingPoolApprovalProgram: new BinaryStateValue(result.stakingPoolApprovalProgram),
        }
      },
      /**
       * Get the current value of the stakingPoolApprovalProgram key in box state
       */
      stakingPoolApprovalProgram: async (): Promise<BinaryState> => { return new BinaryStateValue((await this.appClient.state.box.getValue("stakingPoolApprovalProgram")) as Uint8Array | undefined) },
      /**
       * Get values from the validatorList map in box state
       */
      validatorList: {
        /**
         * Get all current values of the validatorList map in box state
         */
        getMap: async (): Promise<Map<bigint, ValidatorInfo>> => { return (await this.appClient.state.box.getMap("validatorList")) as Map<bigint, ValidatorInfo> },
        /**
         * Get a current value of the validatorList map by key from box state
         */
        value: async (key: bigint | number): Promise<ValidatorInfo | undefined> => { return await this.appClient.state.box.getMapValue("validatorList", key) as ValidatorInfo | undefined },
      },
      /**
       * Get values from the stakerPoolSet map in box state
       */
      stakerPoolSet: {
        /**
         * Get all current values of the stakerPoolSet map in box state
         */
        getMap: async (): Promise<Map<string, [[bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint]]>> => { return (await this.appClient.state.box.getMap("stakerPoolSet")) as Map<string, [[bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint]]> },
        /**
         * Get a current value of the stakerPoolSet map by key from box state
         */
        value: async (key: string): Promise<[[bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint]] | undefined> => { return await this.appClient.state.box.getMapValue("stakerPoolSet", key) as [[bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint], [bigint, bigint, bigint]] | undefined },
      },
    },
  }

  public newGroup(): ValidatorRegistryComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a initStakingContract(uint64)void method call against the ValidatorRegistry contract
       */
      initStakingContract(params: CallParams<ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.initStakingContract(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a loadStakingContractData(uint64,byte[])void method call against the ValidatorRegistry contract
       */
      loadStakingContractData(params: CallParams<ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void'] | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.loadStakingContractData(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a finalizeStakingContract()void method call against the ValidatorRegistry contract
       */
      finalizeStakingContract(params: CallParams<ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.finalizeStakingContract(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a gas()void method call against the ValidatorRegistry contract
       */
      gas(params: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.gas(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a getMbrAmounts()(uint64,uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      getMbrAmounts(params: CallParams<ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getMbrAmounts(params)))
        resultMappers.push((v) => client.decodeReturnValue('getMbrAmounts()(uint64,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      getProtocolConstraints(params: CallParams<ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getProtocolConstraints(params)))
        resultMappers.push((v) => client.decodeReturnValue('getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a getNumValidators()uint64 method call against the ValidatorRegistry contract
       */
      getNumValidators(params: CallParams<ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getNumValidators(params)))
        resultMappers.push((v) => client.decodeReturnValue('getNumValidators()uint64', v))
        return this
      },
      /**
       * Add a getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64) method call against the ValidatorRegistry contract
       */
      getValidatorConfig(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getValidatorConfig(params)))
        resultMappers.push((v) => client.decodeReturnValue('getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)', v))
        return this
      },
      /**
       * Add a getValidatorState(uint64)(uint16,uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      getValidatorState(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getValidatorState(params)))
        resultMappers.push((v) => client.decodeReturnValue('getValidatorState(uint64)(uint16,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a getValidatorOwnerAndManager(uint64)(address,address) method call against the ValidatorRegistry contract
       */
      getValidatorOwnerAndManager(params: CallParams<ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)'] | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getValidatorOwnerAndManager(params)))
        resultMappers.push((v) => client.decodeReturnValue('getValidatorOwnerAndManager(uint64)(address,address)', v))
        return this
      },
      /**
       * Add a getPools(uint64)(uint64,uint16,uint64)[] method call against the ValidatorRegistry contract
       */
      getPools(params: CallParams<ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]'] | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getPools(params)))
        resultMappers.push((v) => client.decodeReturnValue('getPools(uint64)(uint64,uint16,uint64)[]', v))
        return this
      },
      /**
       * Add a getPoolAppId(uint64,uint64)uint64 method call against the ValidatorRegistry contract
       */
      getPoolAppId(params: CallParams<ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64'] | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getPoolAppId(params)))
        resultMappers.push((v) => client.decodeReturnValue('getPoolAppId(uint64,uint64)uint64', v))
        return this
      },
      /**
       * Add a getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64) method call against the ValidatorRegistry contract
       */
      getPoolInfo(params: CallParams<ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getPoolInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)', v))
        return this
      },
      /**
       * Add a getCurMaxStakePerPool(uint64)uint64 method call against the ValidatorRegistry contract
       */
      getCurMaxStakePerPool(params: CallParams<ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64'] | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getCurMaxStakePerPool(params)))
        resultMappers.push((v) => client.decodeReturnValue('getCurMaxStakePerPool(uint64)uint64', v))
        return this
      },
      /**
       * Add a doesStakerNeedToPayMBR(address)bool method call against the ValidatorRegistry contract
       */
      doesStakerNeedToPayMbr(params: CallParams<ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool'] | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.doesStakerNeedToPayMbr(params)))
        resultMappers.push((v) => client.decodeReturnValue('doesStakerNeedToPayMBR(address)bool', v))
        return this
      },
      /**
       * Add a getStakedPoolsForAccount(address)(uint64,uint64,uint64)[] method call against the ValidatorRegistry contract
       */
      getStakedPoolsForAccount(params: CallParams<ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getStakedPoolsForAccount(params)))
        resultMappers.push((v) => client.decodeReturnValue('getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]', v))
        return this
      },
      /**
       * Add a getTokenPayoutRatio(uint64)(uint64[24],uint64) method call against the ValidatorRegistry contract
       */
      getTokenPayoutRatio(params: CallParams<ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getTokenPayoutRatio(params)))
        resultMappers.push((v) => client.decodeReturnValue('getTokenPayoutRatio(uint64)(uint64[24],uint64)', v))
        return this
      },
      /**
       * Add a getNodePoolAssignments(uint64)((uint64[3])[8]) method call against the ValidatorRegistry contract
       */
      getNodePoolAssignments(params: CallParams<ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])'] | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getNodePoolAssignments(params)))
        resultMappers.push((v) => client.decodeReturnValue('getNodePoolAssignments(uint64)((uint64[3])[8])', v))
        return this
      },
      /**
       * Add a getNFDRegistryID()uint64 method call against the ValidatorRegistry contract
       */
      getNfdRegistryId(params: CallParams<ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getNfdRegistryId(params)))
        resultMappers.push((v) => client.decodeReturnValue('getNFDRegistryID()uint64', v))
        return this
      },
      /**
       * Add a addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64 method call against the ValidatorRegistry contract
       */
      addValidator(params: CallParams<ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'] | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addValidator(params)))
        resultMappers.push((v) => client.decodeReturnValue('addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64', v))
        return this
      },
      /**
       * Add a changeValidatorManager(uint64,address)void method call against the ValidatorRegistry contract
       */
      changeValidatorManager(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorManager(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a changeValidatorSunsetInfo(uint64,uint64,uint64)void method call against the ValidatorRegistry contract
       */
      changeValidatorSunsetInfo(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorSunsetInfo(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a changeValidatorNFD(uint64,uint64,string)void method call against the ValidatorRegistry contract
       */
      changeValidatorNfd(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void'] | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorNfd(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a changeValidatorCommissionAddress(uint64,address)void method call against the ValidatorRegistry contract
       */
      changeValidatorCommissionAddress(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorCommissionAddress(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void method call against the ValidatorRegistry contract
       */
      changeValidatorRewardInfo(params: CallParams<ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.changeValidatorRewardInfo(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a addPool(pay,uint64,uint64)(uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      addPool(params: CallParams<ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addPool(params)))
        resultMappers.push((v) => client.decodeReturnValue('addPool(pay,uint64,uint64)(uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a addStake(pay,uint64,uint64)(uint64,uint64,uint64) method call against the ValidatorRegistry contract
       */
      addStake(params: CallParams<ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.addStake(params)))
        resultMappers.push((v) => client.decodeReturnValue('addStake(pay,uint64,uint64)(uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a setTokenPayoutRatio(uint64)(uint64[24],uint64) method call against the ValidatorRegistry contract
       */
      setTokenPayoutRatio(params: CallParams<ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setTokenPayoutRatio(params)))
        resultMappers.push((v) => client.decodeReturnValue('setTokenPayoutRatio(uint64)(uint64[24],uint64)', v))
        return this
      },
      /**
       * Add a stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void method call against the ValidatorRegistry contract
       */
      stakeUpdatedViaRewards(params: CallParams<ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stakeUpdatedViaRewards(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void method call against the ValidatorRegistry contract
       */
      stakeRemoved(params: CallParams<ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'] | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.stakeRemoved(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool) method call against the ValidatorRegistry contract
       */
      findPoolForStaker(params: CallParams<ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.findPoolForStaker(params)))
        resultMappers.push((v) => client.decodeReturnValue('findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)', v))
        return this
      },
      /**
       * Add a movePoolToNode(uint64,uint64,uint64)void method call against the ValidatorRegistry contract
       */
      movePoolToNode(params: CallParams<ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.movePoolToNode(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a emptyTokenRewards(uint64,address)uint64 method call against the ValidatorRegistry contract
       */
      emptyTokenRewards(params: CallParams<ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64'] | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.emptyTokenRewards(params)))
        resultMappers.push((v) => client.decodeReturnValue('emptyTokenRewards(uint64,address)uint64', v))
        return this
      },
      /**
       * Add a clear state call to the ValidatorRegistry contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as ValidatorRegistryComposer
  }
}
export type ValidatorRegistryComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the initStakingContract(uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  initStakingContract(params?: CallParams<ValidatorRegistryArgs['obj']['initStakingContract(uint64)void'] | ValidatorRegistryArgs['tuple']['initStakingContract(uint64)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['initStakingContract(uint64)void'] | undefined]>

  /**
   * Calls the loadStakingContractData(uint64,byte[])void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  loadStakingContractData(params?: CallParams<ValidatorRegistryArgs['obj']['loadStakingContractData(uint64,byte[])void'] | ValidatorRegistryArgs['tuple']['loadStakingContractData(uint64,byte[])void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['loadStakingContractData(uint64,byte[])void'] | undefined]>

  /**
   * Calls the finalizeStakingContract()void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finalizeStakingContract(params?: CallParams<ValidatorRegistryArgs['obj']['finalizeStakingContract()void'] | ValidatorRegistryArgs['tuple']['finalizeStakingContract()void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['finalizeStakingContract()void'] | undefined]>

  /**
   * Calls the gas()void ABI method.
   *
   * gas is a dummy no-op call that can be used to pool-up resource references and opcode cost
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  gas(params?: CallParams<ValidatorRegistryArgs['obj']['gas()void'] | ValidatorRegistryArgs['tuple']['gas()void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['gas()void'] | undefined]>

  /**
   * Calls the getMbrAmounts()(uint64,uint64,uint64,uint64) ABI method.
   *
  * Returns the MBR amounts needed for various actions:
  [
  addValidatorMbr: uint64 - mbr needed to add a new validator - paid to validator contract
  addPoolMbr: uint64 - mbr needed to add a new pool - paid to validator
  poolInitMbr: uint64 - mbr needed to initStorage() of pool - paid to pool itself
  addStakerMbr: uint64 - mbr staker needs to add to first staking payment (stays w/ validator)
  ]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getMbrAmounts(params?: CallParams<ValidatorRegistryArgs['obj']['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getMbrAmounts()(uint64,uint64,uint64,uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getMbrAmounts()(uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64) ABI method.
   *
   * Returns the protocol constraints so that UIs can limit what users specify for validator configuration parameters.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getProtocolConstraints(params?: CallParams<ValidatorRegistryArgs['obj']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getProtocolConstraints()(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the getNumValidators()uint64 ABI method.
   *
   * Returns the current number of validators
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNumValidators(params?: CallParams<ValidatorRegistryArgs['obj']['getNumValidators()uint64'] | ValidatorRegistryArgs['tuple']['getNumValidators()uint64']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getNumValidators()uint64'] | undefined]>

  /**
   * Calls the getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorConfig(params?: CallParams<ValidatorRegistryArgs['obj']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getValidatorConfig(uint64)(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64)'] | undefined]>

  /**
   * Calls the getValidatorState(uint64)(uint16,uint64,uint64,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorState(params?: CallParams<ValidatorRegistryArgs['obj']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['getValidatorState(uint64)(uint16,uint64,uint64,uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getValidatorState(uint64)(uint16,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the getValidatorOwnerAndManager(uint64)(address,address) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getValidatorOwnerAndManager(params?: CallParams<ValidatorRegistryArgs['obj']['getValidatorOwnerAndManager(uint64)(address,address)'] | ValidatorRegistryArgs['tuple']['getValidatorOwnerAndManager(uint64)(address,address)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getValidatorOwnerAndManager(uint64)(address,address)'] | undefined]>

  /**
   * Calls the getPools(uint64)(uint64,uint16,uint64)[] ABI method.
   *
   * Return list of all pools for this validator.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPools(params?: CallParams<ValidatorRegistryArgs['obj']['getPools(uint64)(uint64,uint16,uint64)[]'] | ValidatorRegistryArgs['tuple']['getPools(uint64)(uint64,uint16,uint64)[]']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getPools(uint64)(uint64,uint16,uint64)[]'] | undefined]>

  /**
   * Calls the getPoolAppId(uint64,uint64)uint64 ABI method.
   *
  * getPoolAppId is useful for callers to determine app to call for removing stake if they don't have staking or
  want to get staker list for an account.  The staking pool also uses it to get the app id of staking pool 1
  (which contains reward tokens if being used) so that the amount available can be determined.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPoolAppId(params?: CallParams<ValidatorRegistryArgs['obj']['getPoolAppId(uint64,uint64)uint64'] | ValidatorRegistryArgs['tuple']['getPoolAppId(uint64,uint64)uint64']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getPoolAppId(uint64,uint64)uint64'] | undefined]>

  /**
   * Calls the getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getPoolInfo(params?: CallParams<ValidatorRegistryArgs['obj']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | ValidatorRegistryArgs['tuple']['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getPoolInfo((uint64,uint64,uint64))(uint64,uint16,uint64)'] | undefined]>

  /**
   * Calls the getCurMaxStakePerPool(uint64)uint64 ABI method.
   *
  * Calculate the maximum stake per pool for a given validator.
  Normally this would be maxAlgoPerPool, but it should also never go above MaxAllowedStake / numPools so
  as pools are added the max allowed per pool can reduce.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getCurMaxStakePerPool(params?: CallParams<ValidatorRegistryArgs['obj']['getCurMaxStakePerPool(uint64)uint64'] | ValidatorRegistryArgs['tuple']['getCurMaxStakePerPool(uint64)uint64']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getCurMaxStakePerPool(uint64)uint64'] | undefined]>

  /**
   * Calls the doesStakerNeedToPayMBR(address)bool ABI method.
   *
   * Helper callers can call w/ simulate to determine if 'AddStaker' MBR should be included w/ staking amount
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  doesStakerNeedToPayMbr(params?: CallParams<ValidatorRegistryArgs['obj']['doesStakerNeedToPayMBR(address)bool'] | ValidatorRegistryArgs['tuple']['doesStakerNeedToPayMBR(address)bool']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['doesStakerNeedToPayMBR(address)bool'] | undefined]>

  /**
   * Calls the getStakedPoolsForAccount(address)(uint64,uint64,uint64)[] ABI method.
   *
   * Retrieves the staked pools for an account.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getStakedPoolsForAccount(params?: CallParams<ValidatorRegistryArgs['obj']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | ValidatorRegistryArgs['tuple']['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getStakedPoolsForAccount(address)(uint64,uint64,uint64)[]'] | undefined]>

  /**
   * Calls the getTokenPayoutRatio(uint64)(uint64[24],uint64) ABI method.
   *
  * Retrieves the token payout ratio for a given validator - returning the pool ratios of whole so that token
  payouts across pools can be based on a stable snaphost of stake.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getTokenPayoutRatio(params?: CallParams<ValidatorRegistryArgs['obj']['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['getTokenPayoutRatio(uint64)(uint64[24],uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getTokenPayoutRatio(uint64)(uint64[24],uint64)'] | undefined]>

  /**
   * Calls the getNodePoolAssignments(uint64)((uint64[3])[8]) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNodePoolAssignments(params?: CallParams<ValidatorRegistryArgs['obj']['getNodePoolAssignments(uint64)((uint64[3])[8])'] | ValidatorRegistryArgs['tuple']['getNodePoolAssignments(uint64)((uint64[3])[8])']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getNodePoolAssignments(uint64)((uint64[3])[8])'] | undefined]>

  /**
   * Calls the getNFDRegistryID()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getNfdRegistryId(params?: CallParams<ValidatorRegistryArgs['obj']['getNFDRegistryID()uint64'] | ValidatorRegistryArgs['tuple']['getNFDRegistryID()uint64']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['getNFDRegistryID()uint64'] | undefined]>

  /**
   * Calls the addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64 ABI method.
   *
  * Adds a new validator
  Requires at least 10 ALGO as the 'fee' for the transaction to help dissuade spammed validator adds.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addValidator(params?: CallParams<ValidatorRegistryArgs['obj']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'] | ValidatorRegistryArgs['tuple']['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['addValidator(pay,string,(uint64,address,address,uint64,uint8,address,uint64[4],uint64,uint64,uint64,uint32,uint32,address,uint64,uint64,uint8,uint64,uint64))uint64'] | undefined]>

  /**
   * Calls the changeValidatorManager(uint64,address)void ABI method.
   *
  * Changes the Validator manager for a specific Validator id.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorManager(params?: CallParams<ValidatorRegistryArgs['obj']['changeValidatorManager(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorManager(uint64,address)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorManager(uint64,address)void'] | undefined]>

  /**
   * Calls the changeValidatorSunsetInfo(uint64,uint64,uint64)void ABI method.
   *
  * Updates the sunset information for a given validator.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorSunsetInfo(params?: CallParams<ValidatorRegistryArgs['obj']['changeValidatorSunsetInfo(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorSunsetInfo(uint64,uint64,uint64)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorSunsetInfo(uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the changeValidatorNFD(uint64,uint64,string)void ABI method.
   *
  * Changes the NFD for a validator in the validatorList contract.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorNfd(params?: CallParams<ValidatorRegistryArgs['obj']['changeValidatorNFD(uint64,uint64,string)void'] | ValidatorRegistryArgs['tuple']['changeValidatorNFD(uint64,uint64,string)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorNFD(uint64,uint64,string)void'] | undefined]>

  /**
   * Calls the changeValidatorCommissionAddress(uint64,address)void ABI method.
   *
  * Change the commission address that validator rewards are sent to.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorCommissionAddress(params?: CallParams<ValidatorRegistryArgs['obj']['changeValidatorCommissionAddress(uint64,address)void'] | ValidatorRegistryArgs['tuple']['changeValidatorCommissionAddress(uint64,address)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorCommissionAddress(uint64,address)void'] | undefined]>

  /**
   * Calls the changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void ABI method.
   *
  * Allow the additional rewards (gating entry, additional token rewards) information be changed at will.
  [ ONLY OWNER CAN CHANGE ]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  changeValidatorRewardInfo(params?: CallParams<ValidatorRegistryArgs['obj']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['changeValidatorRewardInfo(uint64,uint8,address,uint64[4],uint64,uint64)void'] | undefined]>

  /**
   * Calls the addPool(pay,uint64,uint64)(uint64,uint64,uint64) ABI method.
   *
  * Adds a new pool to a validator's pool set, returning the 'key' to reference the pool in the future for staking, etc.
  The caller must pay the cost of the validators MBR increase as well as the MBR that will be needed for the pool itself.
  
  [ ONLY OWNER OR MANAGER CAN call ]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addPool(params?: CallParams<ValidatorRegistryArgs['obj']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addPool(pay,uint64,uint64)(uint64,uint64,uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['addPool(pay,uint64,uint64)(uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the addStake(pay,uint64,uint64)(uint64,uint64,uint64) ABI method.
   *
   * Adds stake to a validator pool.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  addStake(params?: CallParams<ValidatorRegistryArgs['obj']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'] | ValidatorRegistryArgs['tuple']['addStake(pay,uint64,uint64)(uint64,uint64,uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['addStake(pay,uint64,uint64)(uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the setTokenPayoutRatio(uint64)(uint64[24],uint64) ABI method.
   *
  * setTokenPayoutRatio is called by Staking Pool # 1 (ONLY) to ask the validator (us) to calculate the ratios
  of stake in the pools for subsequent token payouts (ie: 2 pools, '100' algo total staked, 60 in pool 1, and 40
  in pool 2)  This is done so we have a stable snapshot of stake - taken once per epoch - only triggered by
  pool 1 doing payout.  pools other than 1 doing payout call pool 1 to ask it do it first.
  It would be 60/40% in the poolPctOfWhole values.  The token reward payouts then use these values instead of
  their 'current' stake which changes as part of the payouts themselves (and people could be changing stake
  during the epoch updates across pools)
  
  Multiple pools will call us via pool 1 (pool2->pool1->validator, etc.) so don't assert on pool1 calling multiple
  times in same epoch.  Just return.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setTokenPayoutRatio(params?: CallParams<ValidatorRegistryArgs['obj']['setTokenPayoutRatio(uint64)(uint64[24],uint64)'] | ValidatorRegistryArgs['tuple']['setTokenPayoutRatio(uint64)(uint64[24],uint64)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['setTokenPayoutRatio(uint64)(uint64[24],uint64)'] | undefined]>

  /**
   * Calls the stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void ABI method.
   *
  * stakeUpdatedViaRewards is called by Staking pools to inform the validator (us) that a particular amount of total
  stake has been added to the specified pool.  This is used to update the stats we have in our PoolInfo storage.
  The calling App id is validated against our pool list as well.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stakeUpdatedViaRewards(params?: CallParams<ValidatorRegistryArgs['obj']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['stakeUpdatedViaRewards((uint64,uint64,uint64),uint64,uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void ABI method.
   *
  * stakeRemoved is called by Staking pools to inform the validator (us) that a particular amount of total stake has been removed
  from the specified pool.  This is used to update the stats we have in our PoolInfo storage.
  If any amount of rewardRemoved is specified, then that amount of reward is sent to the use
  The calling App id is validated against our pool list as well.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  stakeRemoved(params?: CallParams<ValidatorRegistryArgs['obj']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'] | ValidatorRegistryArgs['tuple']['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['stakeRemoved((uint64,uint64,uint64),address,uint64,uint64,bool)void'] | undefined]>

  /**
   * Calls the findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool) ABI method.
   *
  * Finds the pool for a staker based on the provided validator id, staker address, and amount to stake.
  First checks the stakers 'already staked list' for the validator preferring those (adding if possible) then adds
  to new pool if necessary.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  findPoolForStaker(params?: CallParams<ValidatorRegistryArgs['obj']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | ValidatorRegistryArgs['tuple']['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['findPoolForStaker(uint64,address,uint64)((uint64,uint64,uint64),bool,bool)'] | undefined]>

  /**
   * Calls the movePoolToNode(uint64,uint64,uint64)void ABI method.
   *
  * Find the specified pool (in any node number) and move it to the specified node.
  The pool account is forced offline if moved so prior node will still run for 320 rounds but
  new key goes online on new node soon after (320 rounds after it goes online)
  No-op if success, asserts if not found or can't move  (no space in target)
  [ ONLY OWNER OR MANAGER CAN CHANGE ]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  movePoolToNode(params?: CallParams<ValidatorRegistryArgs['obj']['movePoolToNode(uint64,uint64,uint64)void'] | ValidatorRegistryArgs['tuple']['movePoolToNode(uint64,uint64,uint64)void']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['movePoolToNode(uint64,uint64,uint64)void'] | undefined]>

  /**
   * Calls the emptyTokenRewards(uint64,address)uint64 ABI method.
   *
  * Sends the reward tokens held in pool 1 to specified receiver.
  This is intended to be used by the owner when they want to get reward tokens 'back' which they sent to
  the first pool (likely because validator is sunsetting.  Any tokens currently 'reserved' for stakers to claim will
  NOT be sent as they must be held back for stakers to later claim.
  [ ONLY OWNER CAN CALL]

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  emptyTokenRewards(params?: CallParams<ValidatorRegistryArgs['obj']['emptyTokenRewards(uint64,address)uint64'] | ValidatorRegistryArgs['tuple']['emptyTokenRewards(uint64,address)uint64']>): ValidatorRegistryComposer<[...TReturns, ValidatorRegistryReturns['emptyTokenRewards(uint64,address)uint64'] | undefined]>

  /**
   * Makes a clear_state call to an existing instance of the ValidatorRegistry smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): ValidatorRegistryComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): ValidatorRegistryComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<ValidatorRegistryComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<ValidatorRegistryComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<ValidatorRegistryComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<ValidatorRegistryComposerResults<TReturns>>
}
export type ValidatorRegistryComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

